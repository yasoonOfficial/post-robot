{"version":3,"sources":["webpack://postRobot/webpack/universalModuleDefinition","webpack://postRobot/webpack/bootstrap","webpack://postRobot/./node_modules/@krakenjs/cross-domain-utils/src/util.js","webpack://postRobot/./node_modules/@krakenjs/cross-domain-utils/src/constants.js","webpack://postRobot/./node_modules/@krakenjs/cross-domain-utils/src/utils.js","webpack://postRobot/./node_modules/@krakenjs/zalgo-promise/src/utils.js","webpack://postRobot/./node_modules/@krakenjs/zalgo-promise/src/exceptions.js","webpack://postRobot/./node_modules/@krakenjs/zalgo-promise/src/flush.js","webpack://postRobot/./node_modules/@krakenjs/zalgo-promise/src/promise.js","webpack://postRobot/./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js","webpack://postRobot/./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js","webpack://postRobot/./node_modules/@krakenjs/cross-domain-safe-weakmap/src/util.js","webpack://postRobot/./node_modules/@krakenjs/cross-domain-safe-weakmap/src/weakmap.js","webpack://postRobot/./node_modules/@krakenjs/belter/src/util.js","webpack://postRobot/./node_modules/@krakenjs/cross-domain-safe-weakmap/src/native.js","webpack://postRobot/./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","webpack://postRobot/./node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js","webpack://postRobot/./node_modules/@babel/runtime/helpers/esm/construct.js","webpack://postRobot/./node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js","webpack://postRobot/./node_modules/@babel/runtime/helpers/esm/isNativeFunction.js","webpack://postRobot/./node_modules/@krakenjs/belter/src/dom.js","webpack://postRobot/./src/global.js","webpack://postRobot/./node_modules/@krakenjs/belter/src/constants.js","webpack://postRobot/./src/lib/hello.js","webpack://postRobot/./src/conf/constants.js","webpack://postRobot/./src/lib/windows.js","webpack://postRobot/./node_modules/@krakenjs/universal-serialize/src/common.js","webpack://postRobot/./node_modules/@krakenjs/universal-serialize/src/constants.js","webpack://postRobot/./node_modules/@krakenjs/universal-serialize/src/serialize.js","webpack://postRobot/./node_modules/@krakenjs/universal-serialize/src/serializers/function.js","webpack://postRobot/./node_modules/@krakenjs/universal-serialize/src/serializers/error.js","webpack://postRobot/./node_modules/@krakenjs/universal-serialize/src/serializers/promise.js","webpack://postRobot/./node_modules/@krakenjs/universal-serialize/src/serializers/regex.js","webpack://postRobot/./node_modules/@krakenjs/universal-serialize/src/serializers/date.js","webpack://postRobot/./node_modules/@krakenjs/universal-serialize/src/serializers/array.js","webpack://postRobot/./node_modules/@krakenjs/universal-serialize/src/serializers/object.js","webpack://postRobot/./node_modules/@krakenjs/universal-serialize/src/serializers/string.js","webpack://postRobot/./node_modules/@krakenjs/universal-serialize/src/serializers/number.js","webpack://postRobot/./node_modules/@krakenjs/universal-serialize/src/serializers/boolean.js","webpack://postRobot/./node_modules/@krakenjs/universal-serialize/src/serializers/null.js","webpack://postRobot/./node_modules/@krakenjs/universal-serialize/src/serializers/undefined.js","webpack://postRobot/./node_modules/@krakenjs/universal-serialize/src/deserialize.js","webpack://postRobot/./src/bridge/common.js","webpack://postRobot/./src/bridge/parent.js","webpack://postRobot/./src/bridge/setup.js","webpack://postRobot/./src/bridge/bridge.js","webpack://postRobot/./src/bridge/child.js","webpack://postRobot/./src/serialize/window.js","webpack://postRobot/./src/serialize/function.js","webpack://postRobot/./src/serialize/serialize.js","webpack://postRobot/./src/serialize/promise.js","webpack://postRobot/./src/drivers/send/strategies.js","webpack://postRobot/./src/drivers/send/index.js","webpack://postRobot/./src/drivers/listeners.js","webpack://postRobot/./src/drivers/receive/index.js","webpack://postRobot/./src/drivers/receive/types.js","webpack://postRobot/./src/public/on.js","webpack://postRobot/./src/lib/compat.js","webpack://postRobot/./src/public/send.js","webpack://postRobot/./src/conf/config.js","webpack://postRobot/./src/setup.js","webpack://postRobot/./src/types.js","webpack://postRobot/./src/index.js","webpack://postRobot/./src/clean.js"],"names":["root","factory","exports","module","define","amd","self","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","hasOwnProperty","p","s","isRegex","item","toString","IE_WIN_ACCESS_ERROR","getActualProtocol","win","window","location","protocol","getProtocol","mockDomain","split","isAboutProtocol","getParent","parent","err","getOpener","opener","canReadFromWindow","getActualDomain","Error","PROTOCOL","host","getDomain","domain","indexOf","isSameDomain","desc","getOwnPropertyDescriptor","isMockProtocol","isActuallySameDomain","assertSameDomain","isAncestorParent","child","childParent","result","push","getParents","getFrames","frames","len","length","frame","getAllChildFrames","_i3","_getFrames2","_i5","_getAllChildFrames2","getTop","top","_i7","_getAllChildFrames4","getAllFramesInWindow","concat","iframeWindows","iframeFrames","isWindowClosed","allowMock","closed","message","mockclosed","iframeIndex","collection","safeIndexOf","contentWindow","parentNode","doc","ownerDocument","documentElement","contains","isFrameWindowClosed","getUserAgent","navigator","mockUserAgent","userAgent","getFrameByName","winFrames","_i9","childFrame","isOpener","getAncestor","anyMatch","collection1","collection2","_i17","item1","_i19","isSameTopWindow","win1","win2","top1","top2","allFrames1","allFrames2","opener1","opener2","matchDomain","pattern","origin","Array","isArray","Boolean","match","JSON","stringify","some","subpattern","getDomainFromUrl","url","slice","join","isWindow","obj","Window","__cross_domain_utils_window_check__","getFrameForWindow","frameElement","_i21","_document$querySelect2","document","querySelectorAll","closeWindow","isIframe","parentElement","removeChild","close","isPromise","Promise","constructor","then","flushPromise","dispatchedErrors","possiblyUnhandledPromiseHandlers","activeCount","flushActive","promise","resolve","startActive","endActive","ZalgoPromise","handler","_this","resolved","rejected","errorHandled","error","handlers","dispatching","stack","isAsync","res","reject","_proto","prototype","dispatch","_this2","setTimeout","j","dispatchPossiblyUnhandledError","asyncReject","chain","firstPromise","secondPromise","_handlers$i","onSuccess","onError","promiseResult","catch","undefined","finally","onFinally","try","timeout","time","_this3","clearTimeout","toPromise","TypeError","lazy","all","promises","count","results","prom","hash","awaitPromises","_loop","map","items","method","onPossiblyUnhandledException","cancel","splice","context","args","apply","delay","flush","_setPrototypeOf","setPrototypeOf","__proto__","_inheritsLoose","subClass","superClass","objectIDs","CrossDomainSafeWeakMap","weakmap","keys","values","Math","random","WeakMap","freeze","testWeakMap","testKey","set","hasNativeWeakMap","_cleanupClosedWindows","delete","isSafeToReadWrite","entry","writable","index","has","getOrSet","_getPrototypeOf","getPrototypeOf","_isNativeReflectConstruct","Reflect","construct","sham","Proxy","Date","e","_construct","Parent","Class","isNativeReflectConstruct","a","instance","Function","arguments","_wrapNativeSuper","_cache","Map","Wrapper","configurable","getFunctionName","fn","__name__","displayName","setFunctionName","uniqueID","chars","replace","charAt","floor","str","btoa","encodeURIComponent","p1","String","fromCharCode","parseInt","Buffer","from","base64encode","toISOString","toLowerCase","serializeArgs","subkey","val","uid","getObjectID","element","passed","Element","nodeType","style","_","isElement","getEmptyObject","memoizeGlobalIndex","memoizeGlobalIndexValidFrom","memoize","options","simpleCache","thisCache","_options$thisNamespac","thisNamespace","cacheTime","memoizeIndex","memoizedFunction","_len","_key","cache","cacheKey","_unused","cacheResult","now","reset","memoizePromise","memoizedPromiseFunction","_arguments","_len2","_key2","noop","stringifyError","level","newErr","clear","_ExtendableError","ExtendableError","_Error","_this6","captureStackTrace","getBody","body","isDocumentReady","readyState","isDocumentInteractive","interval","setInterval","clearInterval","currentScript","getCurrentScript","getStackTrace","stackDetails","exec","scriptLocation","_i22","_Array$prototype$slic2","getElementsByTagName","reverse","script","src","inferCurrentScript","currentUID","getGlobal","globalKey","__POST_ROBOT__","getAttribute","ATTRIBUTES","hashedString","total","charCodeAt","abs","strHashStr","dataset","setAttribute","getObj","globalStore","defStore","store","storeKey","defVal","del","WildCard","getWildcard","global","WINDOW_WILDCARD","windowStore","winStore","getStore","getInstanceID","resolveHelloPromise","_ref","helloPromises","existingPromise","newPromise","sayHello","_ref4","send","instanceID","_ref5","data","getWindowInstanceID","_ref6","_ref7","awaitWindowHello","getHelloPromise","markWindowKnown","isSerializedType","__type__","determineType","serializeType","type","__val__","SERIALIZER","_SERIALIZER","code","source","toJSON","defaultSerializers","DESERIALIZER","_DESERIALIZER","_ref2","RegExp","defaultDeserializers","needsBridgeForBrowser","needsBridgeForWin","needsBridgeForDomain","needsBridge","getBridgeName","BRIDGE_NAME_PREFIX","isBridge","documentBodyReady","registerRemoteWindow","findRemoteWindow","remoteWinPromise","registerRemoteSendMessage","sendMessage","remoteWin","remoteDomain","fireAndForget","rejectRemoteSendMessage","linkWindow","_ref3","popupWindowsByName","popupWindowsByWin","_i2","_popupWindowsByName$k2","winName","details","setupBridge","windowOpen","on","receiveMessage","open","last","normalizeMockUrl","bridgePromise","bridge","getWindowDetails","listenForOpenTunnel","openTunnelToParent","canary","tunnelWindows","parentWindow","id","_tunnelWindows$keys2","cleanTunnelWindows","addTunnelWindow","tunnelWindow","setupOpenTunnelToParent","openTunnelToOpener","cleanupProxyWindows","idToProxyWindow","_idToProxyWindow$keys2","shouldClean","getSerializedWindow","winPromise","_ref$id","windowNamePromise","windowTypePromise","getName","getType","focus","isClosed","setLocation","href","opts","_opts$method","target","_ref3$method","form","createElement","display","_i24","_Object$keys4","_body$key","input","appendChild","submit","submitForm","setName","sameDomain","ProxyWindow","serializedWindow","isProxyWindow","actualWindow","actualWindowPromise","getID","setWindow","isPopup","_this4","isPopupPromise","getNamePromise","reopenPromise","focusPromise","getWindow","awaitWindow","matchWindow","_this5","proxyInstanceID","knownWindowInstanceID","unwrap","serialize","toProxyWindow","deserialize","_ref8","_ref9","addMethod","methodStore","proxyWindowMethods","lookupMethod","serializeFunction","destination","meth","methodSource","arg","__id__","serializeMessage","_serialize","serializers","serializer","serializePromise","deserializeMessage","_deserialize","deserializers","parse","deserializer","serializedPromise","deserializePromise","serializedFunction","getDeserializedFunction","crossDomainFunctionWrapper","__origin__","__source__","deserializeFunction","SEND_MESSAGE_STRATEGIES","domainBuffer","buffer","serializedMessage","strategies","errors","strategyName","getResponseListener","deleteResponseListener","isResponseListenerErrored","getRequestListener","requestListeners","_i4","winQualifier","nameListeners","domainListeners","_i6","_domainListeners$__DO2","_domainListeners$__DO3","listener","regex","event","receivedMessages","messages","parsedMessage","parseMessages","deserializeMessages","_ret","v","logName","sendResponse","ack","pathname","handleError","handleRequest","handleResponse","handleAck","requestListener","addRequestListener","winCandidate","requestListenerPromise","actualWin","listenersCollection","_i8","_win2","_i10","_i12","_domain2","_i14","existingListener","strDomain","winNameDomainRegexListeners","winNameDomainRegexListener","winNameListeners","winNameDomainListeners","errorHandler","once","postMessage","messagingChild","messagingParent","sendBridgeMessage","foreignGlobal","winOrProxyWin","domainMatcher","responseTimeout","childTimeout","validateOptions","actualParent","_i15","_getFrames8","isAncestor","_temp","targetDomain","actualDomain","normalizedDomain","normalizeDomain","responseListener","addResponseListener","reqPromises","markResponseListenerErrored","totalAckTimeout","isWindowKnown","totalResTimeout","ackTimeout","resTimeout","cancelled","max","loop","internalSerializeMessage","internalDeserializeMessage","createProxyWindow","setup","initialized","addEventListener","sourceElement","originalEvent","messageListener","removeEventListener","listenForMessages","initHello","destroy","responseListeners","_responseListeners$ke2","cancelResponseListeners","TYPES","cleanUpWindow","_requestPromises$get2","openBridge","bridges","bridgeFrames","iframe","openBridgeFrame","linkUrl","hasBridge","destroyBridges","_bridgeFrames$keys2"],"mappings":"CAAA,SAA2CA,EAAMC,GAC1B,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,IACQ,mBAAXG,QAAyBA,OAAOC,IAC9CD,OAAO,YAAa,GAAIH,GACE,iBAAZC,QACdA,QAAmB,UAAID,IAEvBD,EAAgB,UAAIC,IARtB,CASoB,oBAATK,KAAuBA,KAAOC,MAAO,WAChD,O,YCTE,IAAIC,EAAmB,GAGvB,SAASC,EAAoBC,GAG5B,GAAGF,EAAiBE,GACnB,OAAOF,EAAiBE,GAAUR,QAGnC,IAAIC,EAASK,EAAiBE,GAAY,CACzCC,EAAGD,EACHE,GAAG,EACHV,QAAS,IAUV,OANAW,EAAQH,GAAUI,KAAKX,EAAOD,QAASC,EAAQA,EAAOD,QAASO,GAG/DN,EAAOS,GAAI,EAGJT,EAAOD,QA0Df,OArDAO,EAAoBM,EAAIF,EAGxBJ,EAAoBO,EAAIR,EAGxBC,EAAoBQ,EAAI,SAASf,EAASgB,EAAMC,GAC3CV,EAAoBW,EAAElB,EAASgB,IAClCG,OAAOC,eAAepB,EAASgB,EAAM,CAAEK,YAAY,EAAMC,IAAKL,KAKhEV,EAAoBgB,EAAI,SAASvB,GACX,oBAAXwB,QAA0BA,OAAOC,aAC1CN,OAAOC,eAAepB,EAASwB,OAAOC,YAAa,CAAEC,MAAO,WAE7DP,OAAOC,eAAepB,EAAS,aAAc,CAAE0B,OAAO,KAQvDnB,EAAoBoB,EAAI,SAASD,EAAOE,GAEvC,GADU,EAAPA,IAAUF,EAAQnB,EAAoBmB,IAC/B,EAAPE,EAAU,OAAOF,EACpB,GAAW,EAAPE,GAA8B,iBAAVF,GAAsBA,GAASA,EAAMG,WAAY,OAAOH,EAChF,IAAII,EAAKX,OAAOY,OAAO,MAGvB,GAFAxB,EAAoBgB,EAAEO,GACtBX,OAAOC,eAAeU,EAAI,UAAW,CAAET,YAAY,EAAMK,MAAOA,IACtD,EAAPE,GAA4B,iBAATF,EAAmB,IAAI,IAAIM,KAAON,EAAOnB,EAAoBQ,EAAEe,EAAIE,EAAK,SAASA,GAAO,OAAON,EAAMM,IAAQC,KAAK,KAAMD,IAC9I,OAAOF,GAIRvB,EAAoB2B,EAAI,SAASjC,GAChC,IAAIgB,EAAShB,GAAUA,EAAO4B,WAC7B,WAAwB,OAAO5B,EAAgB,SAC/C,WAA8B,OAAOA,GAEtC,OADAM,EAAoBQ,EAAEE,EAAQ,IAAKA,GAC5BA,GAIRV,EAAoBW,EAAI,SAASiB,EAAQC,GAAY,MAAOjB,GAAiBkB,eAAezB,KAAKuB,EAAQC,IAGzG7B,EAAoB+B,EAAI,GAIjB/B,EAAoBA,EAAoBgC,EAAI,G,+BChF9C,SAASC,EAAQC,GAEtB,MAAgD,oBAAzCtB,GAAiBuB,SAAS9B,KAAK6B,G,mpBCFjC,ICSDE,EAAsB,mCAErB,SAASC,EAAkBC,GAChC,YADyD,IAAzBA,MAA4BC,QACrDD,EAAIE,SAASC,SAGf,SAASC,EAAYJ,GAC1B,QADmD,IAAzBA,MAA4BC,QAClDD,EAAIK,WAAY,CAClB,IAAMF,EAAWH,EAAIK,WAAWC,MAAM,MAAM,GAE5C,GAAIH,EACF,OAAOA,EAIX,OAAOJ,EAAkBC,GAOpB,SAASO,EAAgBP,GAC9B,YADuD,IAAzBA,MAA4BC,QD5BlD,WC6BDG,EAAYJ,GAOd,SAASQ,EACdR,GAEA,QAF2B,IAA3BA,MAA8BC,QAEzBD,EAIL,IACE,GAAIA,EAAIS,QAAUT,EAAIS,SAAWT,EAC/B,OAAOA,EAAIS,OAEb,MAAOC,KAKJ,SAASC,EACdX,GAEA,QAF2B,IAA3BA,MAA8BC,QAEzBD,IAKDQ,EAAUR,GAId,IACE,OAAOA,EAAIY,OACX,MAAOF,KAKJ,SAASG,EACdb,GAEA,IAGE,OAAO,EACP,MAAOU,IAIT,OAAO,EAGF,SAASI,EAAgBd,QAA0B,IAA1BA,MAA6BC,QAC3D,IAAMC,EAAWF,EAAIE,SAErB,IAAKA,EACH,MAAM,IAAIa,MAAM,gCAGlB,IAAMZ,EAAWJ,EAAkBC,GAEnC,IAAKG,EACH,MAAM,IAAIY,MAAM,gCAGlB,GDnGO,UCmGHZ,EACF,MAAUa,UAGZ,GDtGQ,WCsGJb,EAA6B,CAC/B,IAAMM,EAASD,EAAUR,GACzB,OAAIS,GAAUI,IAELC,EAAgBL,GAGfO,WAGZ,IAAMC,EAAOf,EAASe,KAEtB,IAAKA,EACH,MAAM,IAAIF,MAAM,4BAGlB,OAAUZ,EAAQ,KAAKc,EAGlB,SAASC,EAAUlB,QAA0B,IAA1BA,MAA6BC,QACrD,IAAMkB,EAASL,EAAgBd,GAE/B,OAAImB,GAAUnB,EAAIK,YAAwD,IAA1CL,EAAIK,WAAWe,QD9HxC,SC+HEpB,EAAIK,WAGNc,EAqEF,SAASE,EACdrB,GAEA,IApDK,SAA8BA,GACnC,IACE,GAAIA,IAAQC,OACV,OAAO,EAET,MAAOS,IAIT,IACE,IAAMY,EAAOhD,OAAOiD,yBAAyBvB,EAAK,YAElD,GAAIsB,IAA4B,IAApBA,EAAK9C,WACf,OAAO,EAET,MAAOkC,IAIT,IAEE,GAAIH,EAAgBP,IAAQa,IAC1B,OAAO,EAET,MAAOH,IAIT,IAEE,GAlJG,SAAwBV,GAC7B,YADsD,IAAzBA,MAA4BC,QDlClD,UCmCAG,EAAYJ,GAiJbwB,CAAexB,IAAQa,IACzB,OAAO,EAET,MAAOH,IAIT,IAEE,GAAII,EAAgBd,KAASc,EAAgBb,QAC3C,OAAO,EAET,MAAOS,IAIT,OAAO,EAMFe,CAAqBzB,GACxB,OAAO,EAGT,IACE,GAAIA,IAAQC,OACV,OAAO,EAIT,GAAIM,EAAgBP,IAAQa,IAC1B,OAAO,EAIT,GAAIK,EAAUjB,UAAYiB,EAAUlB,GAClC,OAAO,EAET,MAAOU,IAIT,OAAO,EAGF,SAASgB,EACd1B,GAEA,IAAKqB,EAAarB,GAChB,MAAM,IAAIe,MAAM,qCAIlB,OAAOf,EAoBF,SAAS2B,EACdlB,EACAmB,GAEA,IAAKnB,IAAWmB,EACd,OAAO,EAGT,IAAMC,EAAcrB,EAAUoB,GAE9B,OAAIC,EACKA,IAAgBpB,GAGkB,IA/BtC,SACLT,GAEA,IAAM8B,EAAS,GAEf,IACE,KAAO9B,EAAIS,SAAWT,GACpB8B,EAAOC,KAAK/B,EAAIS,QAChBT,EAAMA,EAAIS,OAEZ,MAAOC,IAIT,OAAOoB,EAiBHE,CAAWJ,GAAOR,QAAQX,GAOzB,SAASwB,EACdjC,GAEA,IAEIkC,EAQAC,EAVEL,EAAS,GAIf,IACEI,EAASlC,EAAIkC,OACb,MAAOxB,GACPwB,EAASlC,EAKX,IACEmC,EAAMD,EAAOE,OACb,MAAO1B,IAIT,GAAY,IAARyB,EACF,OAAOL,EAGT,GAAIK,EAAK,CACP,IAAK,IAAIvE,EAAI,EAAGA,EAAIuE,EAAKvE,IAAK,CAC5B,IAAIyE,OAAK,EAET,IACEA,EAAQH,EAAOtE,GACf,MAAO8C,GACP,SAGFoB,EAAOC,KAAKM,GAGd,OAAOP,EAGT,IAAK,IAAIlE,EAAI,EAAGA,EAAI,IAAKA,IAAK,CAC5B,IAAIyE,OAAK,EAET,IACEA,EAAQH,EAAOtE,GACf,MAAO8C,GACP,OAAOoB,EAGT,IAAKO,EACH,OAAOP,EAGTA,EAAOC,KAAKM,GAGd,OAAOP,EAGF,SAASQ,EACdtC,GAEkB,IAAlB,IAAM8B,EAAS,GAAGS,EAAA,EAAAC,EAEEP,EAAUjC,GAAIuC,EAAAC,EAAAJ,OAAAG,IAAE,CAA/B,IAAMF,EAAKG,EAAAD,GACdT,EAAOC,KAAKM,GAAO,QAAAI,EAAA,EAAAC,EAEMJ,EAAkBD,GAAMI,EAAAC,EAAAN,OAAAK,IAC/CX,EAAOC,KADYW,EAAAD,IAKvB,OAAOX,EAGF,SAASa,EACd3C,QAA2B,IAA3BA,MAA8BC,QAE9B,IACE,GAAID,EAAI4C,IACN,OAAO5C,EAAI4C,IAEb,MAAOlC,IAIT,GAAIF,EAAUR,KAASA,EACrB,OAAOA,EAGT,IACE,GAAI2B,EAAiB1B,OAAQD,IAAQC,OAAO2C,IAC1C,OAAO3C,OAAO2C,IAEhB,MAAOlC,IAIT,IACE,GAAIiB,EAAiB3B,EAAKC,SAAWA,OAAO2C,IAC1C,OAAO3C,OAAO2C,IAEhB,MAAOlC,IAER,QAAAmC,EAAA,EAAAC,EAEmBR,EAAkBtC,GAAI6C,EAAAC,EAAAV,OAAAS,IAAE,CAAvC,IAAMR,EAAKS,EAAAD,GACd,IACE,GAAIR,EAAMO,IACR,OAAOP,EAAMO,IAEf,MAAOlC,IAIT,GAAIF,EAAU6B,KAAWA,EACvB,OAAOA,GAuBN,SAASU,EACd/C,GAEA,IAAM4C,EAAMD,EAAO3C,GAEnB,IAAK4C,EACH,MAAM,IAAI7B,MAAM,gCAGlB,IAAIe,EAAS,GAAHkB,OAAOV,EAAkBM,GAAM,CAAAA,IAOzC,OAJ6B,IAAzBd,EAAOV,QAAQpB,KACjB8B,EAAS,GAAHkB,OAAOlB,EAAQ,CAAA9B,GAAQsC,EAAkBtC,KAG1C8B,EA6DT,IAAMmB,EAAgB,GAChBC,EAAe,GAEd,SAASC,EACdnD,EACAoD,QAAkB,IAAlBA,OAAqB,GAErB,IACE,GAAIpD,IAAQC,OACV,OAAO,EAET,MAAOS,GACP,OAAO,EAGT,IACE,IAAKV,EACH,OAAO,EAET,MAAOU,GACP,OAAO,EAGT,IACE,GAAIV,EAAIqD,OACN,OAAO,EAET,MAAO3C,GAGP,OAAIA,GAAOA,EAAI4C,UAAYxD,EAO7B,GAAIsD,GAAa/B,EAAarB,GAC5B,IAEE,GAAIA,EAAIuD,WACN,OAAO,EAET,MAAO7C,IAOX,IACE,IAAKV,EAAIS,SAAWT,EAAI4C,IACtB,OAAO,EAET,MAAOlC,IAeT,IAAM8C,EAnFR,SAAwBC,EAA+B7D,GACrD,IAAK,IAAIhC,EAAI,EAAGA,EAAI6F,EAAWrB,OAAQxE,IACrC,IACE,GAAI6F,EAAW7F,KAAOgC,EACpB,OAAOhC,EAET,MAAO8C,IAKX,OAAQ,EAwEYgD,CAAYT,EAAejD,GAE/C,IAAqB,IAAjBwD,EAAoB,CACtB,IAAMnB,EAAQa,EAAaM,GAE3B,GAAInB,GAnHD,SAA6BA,GAClC,IAAKA,EAAMsB,cACT,OAAO,EAGT,IAAKtB,EAAMuB,WACT,OAAO,EAGT,IAAMC,EAAMxB,EAAMyB,cAElB,GAAID,GAAOA,EAAIE,kBAAoBF,EAAIE,gBAAgBC,SAAS3B,GAAQ,CAGtE,IAFA,IAAI5B,EAAS4B,EAEN5B,EAAOmD,YAAcnD,EAAOmD,aAAenD,GAChDA,EAASA,EAAOmD,WAIlB,IAAKnD,EAAOQ,OAAS4C,EAAIE,gBAAgBC,SAASvD,EAAOQ,MACvD,OAAO,EAIX,OAAO,EA2FQgD,CAAoB5B,GAC/B,OAAO,EAIX,OAAO,EAiCF,SAAS6B,EAAalE,GAE3B,OADAA,EAAMA,GAAOC,QACFkE,UAAUC,eAAiBpE,EAAImE,UAAUE,UAG/C,SAASC,EACdtE,EACA7B,GAEiC,IAAjC,IAAMoG,EAAYtC,EAAUjC,GAAKwE,EAAA,EAAAA,EAERD,EAASnC,OAAAoC,IAAE,CAA/B,IAAMC,EAAcF,EAASC,GAChC,IACE,GACEnD,EAAaoD,IAEbA,EAAWtG,OAASA,IACe,IAAnCoG,EAAUnD,QAAQqD,GAElB,OAAOA,EAET,MAAO/D,KAKX,IAEE,IAA6C,IAAzC6D,EAAUnD,QAAQpB,EAAIkC,OAAO/D,IAE/B,OAAO6B,EAAIkC,OAAO/D,GAEpB,MAAOuC,IAIT,IACE,IAAsC,IAAlC6D,EAAUnD,QAAQpB,EAAI7B,IACxB,OAAO6B,EAAI7B,GAEb,MAAOuC,KA0DJ,SAASgE,EACdjE,EACAmB,GAEA,OAAOnB,IAAWE,EAAUiB,GAGvB,SAAS+C,EACd3E,GAMA,YAN2B,IAA3BA,MAA8BC,QAIfU,EAFfX,EAAMA,GAAOC,SAQEO,EAAUR,SAEzB,EAiEF,SAAS4E,EAASC,EAAaC,GAAsB,QAAAC,EAAA,EAAAA,EAC/BF,EAAWzC,OAAA2C,IAAf,IAAX,IAAMC,EAASH,EAAWE,GAAfE,EAAA,EAAAA,EACMH,EAAW1C,OAAA6C,IAC7B,GAAID,IADcF,EAAWG,GAE3B,OAAO,EAKb,OAAO,EA2CF,SAASC,EACdC,EACAC,GAEA,IAAMC,EAAO1C,EAAOwC,IAASA,EACvBG,EAAO3C,EAAOyC,IAASA,EAE7B,IACE,GAAIC,GAAQC,EACV,OAAID,IAASC,EAMf,MAAO5E,IAIT,IAAM6E,EAAaxC,EAAqBoC,GAClCK,EAAazC,EAAqBqC,GAExC,GAAIR,EAASW,EAAYC,GACvB,OAAO,EAGT,IAAMC,EAAU9E,EAAU0E,GACpBK,EAAU/E,EAAU2E,GAE1B,OAAIG,GAAWb,EAAS7B,EAAqB0C,GAAUD,IAInDE,GAAWd,EAAS7B,EAAqB2C,GAAUH,IAH9C,EAUJ,SAASI,EACdC,EACAC,GAEA,GAAuB,iBAAZD,EAAsB,CAC/B,GAAsB,iBAAXC,EACT,MDj3BkB,MCi3BXD,GAAwBC,IAAWD,EAG5C,GAAIjG,EAAQkG,GACV,OAAO,EAGT,GAAIC,MAAMC,QAAQF,GAChB,OAAO,EAIX,OAAIlG,EAAQiG,GACNjG,EAAQkG,GACHD,EAAQ/F,aAAegG,EAAOhG,YAGnCiG,MAAMC,QAAQF,IAKXG,QAAQH,EAAOI,MAAML,MAG1BE,MAAMC,QAAQH,KACZE,MAAMC,QAAQF,GACTK,KAAKC,UAAUP,KAAaM,KAAKC,UAAUN,IAGhDlG,EAAQkG,IAILD,EAAQQ,MAAK,SAACC,GAAU,OAAKV,EAAYU,EAAYR,OAgBzD,SAASS,EAAiBC,GAG/B,OAAIA,EAAIN,MAAM,4BACHM,EAKKjG,MAAM,KAAKkG,MAAM,EAAG,GAAGC,KAAK,KAHnCvF,IA6CJ,SAASwF,EAASC,GACvB,IACE,GAAIA,IAAQ1G,OACV,OAAO,EAET,MAAOS,GACP,GAAIA,GAAOA,EAAI4C,UAAYxD,EACzB,OAAO,EAIX,IAEE,GAA4C,oBAAxCxB,GAAiBuB,SAAS9B,KAAK4I,GACjC,OAAO,EAET,MAAOjG,GACP,GAAIA,GAAOA,EAAI4C,UAAYxD,EACzB,OAAO,EAIX,IACE,GAAIG,OAAO2G,QAAUD,aAAe1G,OAAO2G,OACzC,OAAO,EAET,MAAOlG,GACP,GAAIA,GAAOA,EAAI4C,UAAYxD,EACzB,OAAO,EAIX,IACE,GAAI6G,GAAOA,EAAIpJ,OAASoJ,EACtB,OAAO,EAET,MAAOjG,GACP,GAAIA,GAAOA,EAAI4C,UAAYxD,EACzB,OAAO,EAIX,IACE,GAAI6G,GAAOA,EAAIlG,SAAWkG,EACxB,OAAO,EAET,MAAOjG,GACP,GAAIA,GAAOA,EAAI4C,UAAYxD,EACzB,OAAO,EAIX,IACE,GAAI6G,GAAOA,EAAI/D,MAAQ+D,EACrB,OAAO,EAET,MAAOjG,GACP,GAAIA,GAAOA,EAAI4C,UAAYxD,EACzB,OAAO,EAaX,IACE,GACE6G,GAC4C,uBAA5CA,EAAIE,oCAEJ,OAAO,EAET,MAAOnG,GACP,OAAO,EAGT,IACE,GAAI,gBAAiBiG,GAAO,SAAUA,GAAO,aAAcA,EACzD,OAAO,EAET,MAAOjG,IAIT,OAAO,EAiCF,SAASoG,EAAkB9G,GAChC,GAAIqB,EAAarB,GACf,OAAO0B,EAAiB1B,GAAK+G,aAC9B,QAAAC,EAAA,EAAAC,EAEmBC,SAASC,iBAAiB,UAASH,EAAAC,EAAA7E,OAAA4E,IAAE,CAApD,IAAM3E,EAAK4E,EAAAD,GACd,GAAI3E,GAASA,EAAMsB,eAAiBtB,EAAMsB,gBAAkB3D,EAC1D,OAAOqC,GAKN,SAAS+E,EAAYpH,GAC1B,GAvVK,SAAkBA,GACvB,YADkD,IAA3BA,MAA8BC,QAC9C+F,QAAQxF,EAAUR,IAsVrBqH,CAASrH,GAAM,CACjB,IAAMqC,EAAQyE,EAAkB9G,GAChC,GAAIqC,GAASA,EAAMiF,cAEjB,YADAjF,EAAMiF,cAAcC,YAAYlF,GAKpC,IACErC,EAAIwH,QACJ,MAAO9G,KC9mCJ,SAAS+G,EAAU7H,GACtB,IACI,IAAKA,EACD,OAAO,EAGX,GAAuB,oBAAZ8H,SAA2B9H,aAAgB8H,QAClD,OAAO,EAGX,GAAsB,oBAAXzH,QAAmD,mBAAlBA,OAAO2G,QAAyBhH,aAAgBK,OAAO2G,OAC/F,OAAO,EAGX,GAAsB,oBAAX3G,QAAwD,mBAAvBA,OAAO0H,aAA8B/H,aAAgBK,OAAO0H,YACpG,OAAO,EAGX,IAAM9H,EAAY,GAAIA,SAEtB,GAAIA,EAAU,CACV,IAAM1B,EAAO0B,EAAS9B,KAAK6B,GAE3B,GAAa,oBAATzB,GAAuC,oBAATA,GAAuC,uBAATA,EAC5D,OAAO,EAIf,GAAyB,mBAAdyB,EAAKgI,KACZ,OAAO,EAEb,MAAOlH,GACL,OAAO,EAGX,OAAO,ECjCX,ICCImH,EDDEC,EAAmB,GACnBC,EAA4F,GCD9FC,EAAc,EAGlB,SAASC,IACL,IAAKD,GAAeH,EAAc,CAC9B,IAAMK,EAAUL,EAChBA,EAAe,KACfK,EAAQC,WAIT,SAASC,IACZJ,GAAe,EAGZ,SAASK,IACZL,GAAe,EACfC,ICdG,IAAMK,EAAY,WAgBrB,SAAAA,EAAYC,GAAuF,IAAAC,EAAA,KAQ/F,GAR+F,KAdnGC,cAAQ,OACRC,cAAQ,OACRC,kBAAY,OACZ9J,WAAK,OACL+J,WAAK,OAELC,cAAQ,OAKRC,iBAAW,OACXC,WAAK,EAIDvL,KAAKiL,UAAW,EAChBjL,KAAKkL,UAAW,EAChBlL,KAAKmL,cAAe,EAEpBnL,KAAKqL,SAAW,GAEZN,EAAS,CAET,IAAIzG,EACA8G,EACAH,GAAW,EACXC,GAAW,EACXM,GAAU,EAEdZ,IAEA,IACIG,GAAQ,SAAAU,GACAD,EACAR,EAAKL,QAAQc,IAEbR,GAAW,EACX3G,EAASmH,MAGd,SAAAvI,GACKsI,EACAR,EAAKU,OAAOxI,IAEZgI,GAAW,EACXE,EAAQlI,MAIlB,MAAOA,GAGL,OAFA2H,SACA7K,KAAK0L,OAAOxI,GAIhB2H,IAEAW,GAAU,EAENP,EAEAjL,KAAK2K,QAAQrG,GACN4G,GACPlL,KAAK0L,OAAON,IAWvB,IAAAO,EAAAb,EAAAc,UAwXA,OAxXAD,EAEDhB,QAAA,SAAQrG,GACJ,GAAItE,KAAKiL,UAAYjL,KAAKkL,SACtB,OAAOlL,KAGX,GAAIiK,EAAU3F,GACV,MAAM,IAAIf,MAAM,gDAOpB,OAJAvD,KAAKiL,UAAW,EAChBjL,KAAKqB,MAAQiD,EACbtE,KAAK6L,WAEE7L,MACV2L,EAEDD,OAAA,SAAON,GAAiC,IAAAU,EAAA,KACpC,GAAI9L,KAAKiL,UAAYjL,KAAKkL,SACtB,OAAOlL,KAGX,GAAIiK,EAAUmB,GACV,MAAM,IAAI7H,MAAM,+CAGpB,IAAK6H,EAAO,CAER,IAAMlI,EAAOkI,GAAmC,mBAAnBA,EAAM/I,SAA0B+I,EAAM/I,WAAavB,GAAiBuB,SAAS9B,KAAK6K,GAC/GA,EAAQ,IAAI7H,MAAM,gDAAiDL,GAgBvE,OAbAlD,KAAKkL,UAAW,EAChBlL,KAAKoL,MAAQA,EAERpL,KAAKmL,cACNY,YAAW,WACFD,EAAKX,cFnHnB,SAA2CjI,EAAawH,GAE3D,IAAuC,IAAnCJ,EAAiB1G,QAAQV,GAA7B,CAIAoH,EAAiB/F,KAAKrB,GAEtB6I,YAAW,WAMP,MAAM7I,IACP,GAEH,IAAK,IAAI8I,EAAI,EAAGA,EAAIzB,EAAiC3F,OAAQoH,IAEzDzB,EAAiCyB,GAAG9I,EAAKwH,IEiG7BuB,CAA+Bb,EAAOU,KAE3C,GAGP9L,KAAK6L,WAEE7L,MACV2L,EAEDO,YAAA,SAAYd,GAGR,OAFApL,KAAKmL,cAAe,EACpBnL,KAAK0L,OAAON,GACLpL,MACV2L,EAEDE,SAAA,WAEI,IAAqBZ,EAAiCjL,KAAjCiL,SAAUC,EAAuBlL,KAAvBkL,SAAUG,EAAarL,KAAbqL,SAEzC,IAFsDrL,KAA9CsL,cAMHL,GAAaC,GAAlB,CAIAlL,KAAKsL,aAAc,EACnBV,IAUA,IARA,IAAMuB,EAAQ,SAAIC,EAAgCC,GAC9C,OAAOD,EAAahC,MAAK,SAAAqB,GACrBY,EAAc1B,QAAQc,MACvB,SAAAvI,GACCmJ,EAAcX,OAAOxI,OAIpB9C,EAAI,EAAGA,EAAIiL,EAASzG,OAAQxE,IAAK,CAEtC,IAAAkM,EAAwCjB,EAASjL,GAAzCmM,EAASD,EAATC,UAAWC,EAAOF,EAAPE,QAAS9B,EAAO4B,EAAP5B,QAExBpG,OAAM,EAEV,GAAI2G,EAEA,IACI3G,EAASiI,EAAYA,EAAUvM,KAAKqB,OAASrB,KAAKqB,MACpD,MAAO6B,GACLwH,EAAQgB,OAAOxI,GACf,cAGD,GAAIgI,EAAU,CAEjB,IAAKsB,EAAS,CACV9B,EAAQgB,OAAO1L,KAAKoL,OACpB,SAGJ,IACI9G,EAASkI,EAAQxM,KAAKoL,OACxB,MAAOlI,GACLwH,EAAQgB,OAAOxI,GACf,UAIR,GAAIoB,aAAkBwG,IAAiBxG,EAAO2G,UAAY3G,EAAO4G,UAAW,CACxE,IAAMuB,EAAkCnI,EAEpCmI,EAAcxB,SACdP,EAAQC,QAAQ8B,EAAcpL,OAE9BqJ,EAAQgB,OAAOe,EAAcrB,OAGjCqB,EAActB,cAAe,OAEtBlB,EAAU3F,GAEbA,aAAkBwG,IAAiBxG,EAAO2G,UAAY3G,EAAO4G,UACzD5G,EAAO2G,SACPP,EAAQC,QAAQrG,EAAOjD,OAEvBqJ,EAAQgB,OAAOpH,EAAO8G,OAK1Be,EAAM7H,EAAQoG,GAKlBA,EAAQC,QAAQrG,GAIxB+G,EAASzG,OAAS,EAClB5E,KAAKsL,aAAc,EACnBT,MACHc,EAEDvB,KAAA,SAAWmC,EAA0DC,GAEjE,GAAID,GAAkC,mBAAdA,IAA6BA,EAAUhM,KAC3D,MAAM,IAAIgD,MAAM,wDAGpB,GAAIiJ,GAA8B,mBAAZA,IAA2BA,EAAQjM,KACrD,MAAM,IAAIgD,MAAM,sDAGpB,IAAMmH,EAAU,IAAII,EAYpB,OAVA9K,KAAKqL,SAAS9G,KAAK,CACfmG,UACA6B,YACAC,YAGJxM,KAAKmL,cAAe,EAEpBnL,KAAK6L,WAEEnB,GACViB,EAEDe,MAAA,SAAYF,GAGR,OAD4CxM,KAAKoK,UAAKuC,EAAWH,IAEpEb,EAEDiB,QAAA,SAAQC,GAEJ,GAAIA,GAAkC,mBAAdA,IAA6BA,EAAUtM,KAC3D,MAAM,IAAIgD,MAAM,uCAGpB,OAAOvD,KAAKoK,MAAK,SAAC9F,GACd,OAAOwG,EAAagC,IAAID,GACnBzC,MAAK,WACF,OAAO9F,QAEhB,SAACpB,GACA,OAAO4H,EAAagC,IAAID,GACnBzC,MAAK,WACF,MAAMlH,SAGrByI,EAEDoB,QAAA,SAAQC,EAAe9J,GAAgC,IAAA+J,EAAA,KAEnD,GAAIjN,KAAKiL,UAAYjL,KAAKkL,SACtB,OAAOlL,KAGX,IAAM+M,EAAUhB,YAAW,WAEnBkB,EAAKhC,UAAYgC,EAAK/B,UAI1B+B,EAAKvB,OAAOxI,GAAO,IAAIK,MAAM,2BAA4ByJ,EAAI,SAE9DA,GAEH,OAAOhN,KAAKoK,MAAK,SAAA9F,GAEb,OADA4I,aAAaH,GACNzI,MAEdqH,EAGDwB,UAAA,WAEI,GAAuB,oBAAZjD,QACP,MAAM,IAAIkD,UAAU,0BAGxB,OAAOlD,QAAQS,QAAQ3K,OAC1B2L,EAED0B,KAAA,WAEI,OADArN,KAAKmL,cAAe,EACbnL,MACV8K,EAEMH,QAAP,SAAqBtJ,GAEjB,OAAIA,aAAiByJ,EAEoBzJ,EAIrC4I,EAAU5I,GAEH,IAAIyJ,GAAa,SAACH,EAASe,GAAM,OAAKrK,EAAM+I,KAAKO,EAASe,OAG9D,IAAIZ,GAAeH,QAAQtJ,IACrCyJ,EAEMY,OAAP,SAAcN,GACV,OAAO,IAAIN,GAAeY,OAAON,IACpCN,EAEMoB,YAAP,SAAmBd,GACf,OAAO,IAAIN,GAAeoB,YAAYd,IACzCN,EAEMwC,IAAP,SAAsCC,GAElC,IAAM7C,EAAU,IAAII,EAChB0C,EAAQD,EAAS3I,OAEf6I,EAAW,GAAkDzE,QAEnE,IAAKwE,EAED,OADA9C,EAAQC,QAAQ8C,GACT/C,EAeX,IAZA,IAAMyB,EAAQ,SAAI/L,EAAYgM,EAAgCC,GAC1D,OAAOD,EAAahC,MAAK,SAAAqB,GACrBgC,EAAQrN,GAAKqL,EAEC,IADd+B,GAAS,IAEL9C,EAAQC,QAAQ8C,MAErB,SAAAvK,GACCmJ,EAAcX,OAAOxI,OAIpB9C,EAAI,EAAGA,EAAImN,EAAS3I,OAAQxE,IAAK,CACtC,IAAMsN,EAAOH,EAASnN,GAEtB,GAAIsN,aAAgB5C,GAChB,GAAI4C,EAAKzC,SAAU,CACfwC,EAAQrN,GAAKsN,EAAKrM,MAClBmM,GAAS,EACT,eAED,IAAKvD,EAAUyD,GAAO,CACzBD,EAAQrN,GAAKsN,EACbF,GAAS,EACT,SAGJrB,EAAM/L,EAAG0K,EAAaH,QAAQ+C,GAAOhD,GAOzC,OAJc,IAAV8C,GACA9C,EAAQC,QAAQ8C,GAGb/C,GACVI,EAEM6C,KAAP,SAAwBJ,GACpB,IAAMjJ,EAAS,GACTsJ,EAAgB,GAAGC,EAAA,SAAAlM,GAGrB,GAAI4L,EAASvL,eAAeL,GAAM,CAC9B,IAAMN,EAAQkM,EAAS5L,GAEnBsI,EAAU5I,GACVuM,EAAcrJ,KAAKlD,EAAM+I,MAAK,SAAAqB,GAC1BnH,EAAO3C,GAAO8J,MAGlBnH,EAAO3C,GAAON,IAT1B,IAAK,IAAMM,KAAO4L,EAAQM,EAAAlM,GAc1B,OAAOmJ,EAAawC,IAAIM,GAAexD,MAAK,kBAAM9F,MACrDwG,EAEMgD,IAAP,SAAiBC,EAA2BC,GAExC,OAAOlD,EAAawC,IAAIS,EAAMD,IAAIE,KACrClD,EAEMmD,6BAAP,SAAoClD,GAChC,OFjYD,SAAsCA,GAGzC,OAFAR,EAAiChG,KAAKwG,GAE/B,CACHmD,OAAM,WACF3D,EAAiC4D,OAAO5D,EAAiC3G,QAAQmH,GAAU,KE4XxFkD,CAA6BlD,IACvCD,EAEMgC,IAAP,SAAuDkB,EAAqEI,EAAcC,GAEtI,GAAIL,GAA4B,mBAAXA,IAA0BA,EAAOzN,KAClD,MAAM,IAAIgD,MAAM,mCAGpB,IAAIe,EAEJsG,IAEA,IACItG,EAAS0J,EAAOM,MAAMF,EAASC,GAAQ,IACzC,MAAOnL,GAEL,OADA2H,IACOC,EAAaY,OAAOxI,GAQ/B,OALA2H,IAGsBC,EAAaH,QAAQrG,IAG9CwG,EAEMyD,MAAP,SAAaA,GACT,OAAO,IAAIzD,GAAa,SAAAH,GACpBoB,WAAWpB,EAAS4D,OAE3BzD,EAEMb,UAAP,SAAiB5I,GAEb,SAAIA,GAASA,aAAiByJ,IAIvBb,EAAU5I,IACpByJ,EAEM0D,MAAP,WACI,ODlbE9D,EAAUL,EAAeA,GAAgB,ICkbxBS,EDjbvBL,IACOC,EAHJ,IACGA,GCmbLI,EArcoB,GCPV,SAAS2D,EAAgB5N,EAAGoB,GAMzC,OALAwM,EAAkB3N,OAAO4N,gBAAkB,SAAyB7N,EAAGoB,GAErE,OADApB,EAAE8N,UAAY1M,EACPpB,IAGcA,EAAGoB,GCLb,SAAS2M,EAAeC,EAAUC,GAC/CD,EAASjD,UAAY9K,OAAOY,OAAOoN,EAAWlD,WAC9CiD,EAASjD,UAAUzB,YAAc0E,EACjCH,EAAeG,EAAUC,GCFpB,SAAS5I,EAAeD,EAAgC7D,GAC3D,IAAK,IAAIhC,EAAI,EAAGA,EAAI6F,EAAWrB,OAAQxE,IAEnC,IACI,GAAI6F,EAAW7F,KAAOgC,EAClB,OAAOhC,EAEb,MAAO8C,IAKb,OAAQ,ECPL,ICgHH6L,EDhHSC,EAAsB,WAS/B,SAAAA,IAII,GAJU,KAPdrO,UAAI,OACJsO,aAAO,OAEPC,UAAI,OAEJC,YAAM,EAIFnP,KAAKW,KAAO,cAA8B,IAAhByO,KAAKC,WAAmB,GAAC,KEhBpD,WAEH,GAAuB,oBAAZC,QACP,OAAO,EAGX,QAA6B,IAAlBxO,OAAOyO,OACd,OAAO,EAGX,IAEI,IAAMC,EAAc,IAAIF,QAClBG,EAAU,GAOhB,OAJA3O,OAAOyO,OAAOE,GAEdD,EAAYE,IAAID,EAJE,mCAMdD,EAAYvO,IAAIwO,GAMtB,MAAOvM,GAEL,OAAO,GFVHyM,GACA,IACI3P,KAAKiP,QAAU,IAAIK,QACrB,MAAOpM,IAKblD,KAAKkP,KAAQ,GACblP,KAAKmP,OAAS,GACjB,IAAAxD,EAAAqD,EAAApD,UAkOA,OAlOAD,EAEDiE,sBAAA,WAKI,IAHA,IAAMX,EAAUjP,KAAKiP,QACfC,EAAOlP,KAAKkP,KAET9O,EAAI,EAAGA,EAAI8O,EAAKtK,OAAQxE,IAAK,CAClC,IAAMiB,EAAQ6N,EAAK9O,GAEnB,GAAI8I,EAAS7H,IAAUsE,EAAetE,GAAQ,CAE1C,GAAI4N,EACA,IACIA,EAAQY,OAAOxO,GACjB,MAAO6B,IAKbgM,EAAKf,OAAO/N,EAAG,GACfJ,KAAKmP,OAAOhB,OAAO/N,EAAG,GAEtBA,GAAK,KAGhBuL,EAEDmE,kBAAA,SAAkBnO,GAEd,OAAIuH,EAASvH,IAYhBgK,EAED+D,IAAA,SAAI/N,EAASN,GAET,IAAKM,EACD,MAAM,IAAI4B,MAAM,wBAGpB,IAAM0L,EAAUjP,KAAKiP,QAErB,GAAIA,EACA,IACIA,EAAQS,IAAI/N,EAAKN,GACnB,MAAO6B,UACElD,KAAKiP,QAIpB,GAAIjP,KAAK8P,kBAAkBnO,GACvB,IACI,IAAMhB,EAAOX,KAAKW,KACZoP,EAAQpO,EAAIhB,GAWlB,YATIoP,GAASA,EAAM,KAAOpO,EACtBoO,EAAM,GAAK1O,EAEXP,OAAOC,eAAeY,EAAKhB,EAAM,CAC7BU,MAAU,CAAEM,EAAKN,GACjB2O,UAAU,KAMpB,MAAO9M,IAKblD,KAAK4P,wBAEL,IAAMV,EAAOlP,KAAKkP,KACZC,EAASnP,KAAKmP,OACdc,EAAQ/J,EAAYgJ,EAAMvN,IAEjB,IAAXsO,GACAf,EAAK3K,KAAK5C,GACVwN,EAAO5K,KAAKlD,IAEZ8N,EAAOc,GAAS5O,GAEvBsK,EAED1K,IAAA,SAAIU,GAEA,IAAKA,EACD,MAAM,IAAI4B,MAAM,wBAGpB,IAAM0L,EAAUjP,KAAKiP,QAErB,GAAIA,EACA,IACI,GAAIA,EAAQiB,IAAIvO,GACZ,OAAOsN,EAAQhO,IAAIU,GAGzB,MAAOuB,UACElD,KAAKiP,QAIpB,GAAIjP,KAAK8P,kBAAkBnO,GACvB,IACI,IAAMoO,EAAQpO,EAAI3B,KAAKW,MAEvB,OAAIoP,GAASA,EAAM,KAAOpO,EACfoO,EAAM,QAGjB,EACF,MAAO7M,IAKblD,KAAK4P,wBAEL,IACMK,EAAQ/J,EADDlG,KAAKkP,KACcvN,GAEhC,IAAe,IAAXsO,EAIJ,OAAOjQ,KAAKmP,OAAOc,IACtBtE,EAEDkE,OAAA,SAAOlO,GAEH,IAAKA,EACD,MAAM,IAAI4B,MAAM,wBAGpB,IAAM0L,EAAUjP,KAAKiP,QAErB,GAAIA,EACA,IACIA,EAAQY,OAAOlO,GACjB,MAAOuB,UACElD,KAAKiP,QAIpB,GAAIjP,KAAK8P,kBAAkBnO,GACvB,IACI,IAAMoO,EAAQpO,EAAI3B,KAAKW,MAEnBoP,GAASA,EAAM,KAAOpO,IACtBoO,EAAM,GAAKA,EAAM,QAAKpD,GAE5B,MAAOzJ,IAKblD,KAAK4P,wBAEL,IAAMV,EAAOlP,KAAKkP,KACZe,EAAQ/J,EAAYgJ,EAAMvN,IAEjB,IAAXsO,IACAf,EAAKf,OAAO8B,EAAO,GACnBjQ,KAAKmP,OAAOhB,OAAO8B,EAAO,KAEjCtE,EAEDuE,IAAA,SAAIvO,GAEA,IAAKA,EACD,MAAM,IAAI4B,MAAM,wBAGpB,IAAM0L,EAAUjP,KAAKiP,QAErB,GAAIA,EACA,IACI,GAAIA,EAAQiB,IAAIvO,GACZ,OAAO,EAEb,MAAOuB,UACElD,KAAKiP,QAIpB,GAAIjP,KAAK8P,kBAAkBnO,GACvB,IACI,IAAMoO,EAAQpO,EAAI3B,KAAKW,MAEvB,SAAIoP,GAASA,EAAM,KAAOpO,GAK5B,MAAOuB,IAQb,OAHAlD,KAAK4P,yBAGa,IADJ1J,EAAYlG,KAAKkP,KAAMvN,IAExCgK,EAEDwE,SAAA,SAASxO,EAASf,GACd,GAAIZ,KAAKkQ,IAAIvO,GAET,OAAO3B,KAAKiB,IAAIU,GAGpB,IAAMN,EAAQT,IAEd,OADAZ,KAAK0P,IAAI/N,EAAKN,GACPA,GACV2N,EAzP8B,GGPpB,SAASoB,EAAgBvP,GAItC,OAHAuP,EAAkBtP,OAAO4N,eAAiB5N,OAAOuP,eAAiB,SAAyBxP,GACzF,OAAOA,EAAE8N,WAAa7N,OAAOuP,eAAexP,KAEvBA,GCJV,SAASyP,IACtB,GAAuB,oBAAZC,UAA4BA,QAAQC,UAAW,OAAO,EACjE,GAAID,QAAQC,UAAUC,KAAM,OAAO,EACnC,GAAqB,mBAAVC,MAAsB,OAAO,EAExC,IAEE,OADAC,KAAK/E,UAAUvJ,SAAS9B,KAAKgQ,QAAQC,UAAUG,KAAM,IAAI,iBAClD,EACP,MAAOC,GACP,OAAO,GCPI,SAASC,EAAWC,EAAQzC,EAAM0C,GAc/C,OAZEF,EADEG,IACWT,QAAQC,UAER,SAAoBM,EAAQzC,EAAM0C,GAC7C,IAAIE,EAAI,CAAC,MACTA,EAAE1M,KAAK+J,MAAM2C,EAAG5C,GAChB,IACI6C,EAAW,IADGC,SAASvP,KAAK0M,MAAMwC,EAAQG,IAG9C,OADIF,GAAOrC,EAAewC,EAAUH,EAAMnF,WACnCsF,IAIO5C,MAAM,KAAM8C,WCZjB,SAASC,EAAiBN,GACvC,IAAIO,EAAwB,mBAARC,IAAqB,IAAIA,SAAQ5E,EA8BrD,OA5BA0E,EAAmB,SAA0BN,GAC3C,GAAc,OAAVA,ICP0D,IAAzDI,SAAS9O,SAAS9B,KDOiBwQ,GCPRnN,QAAQ,iBDOQ,OAAOmN,EAEvD,GAAqB,mBAAVA,EACT,MAAM,IAAI3D,UAAU,sDAGtB,QAAsB,IAAXkE,EAAwB,CACjC,GAAIA,EAAOpB,IAAIa,GAAQ,OAAOO,EAAOrQ,IAAI8P,GAEzCO,EAAO5B,IAAIqB,EAAOS,GAGpB,SAASA,IACP,OAAOhB,EAAUO,EAAOK,UAAWf,EAAerQ,MAAMmK,aAW1D,OARAqH,EAAQ5F,UAAY9K,OAAOY,OAAOqP,EAAMnF,UAAW,CACjDzB,YAAa,CACX9I,MAAOmQ,EACPxQ,YAAY,EACZgP,UAAU,EACVyB,cAAc,KAGX/C,EAAe8C,EAAST,KAGTA,GLGnB,SAASW,EAA6BC,GAC3C,OAAOA,EAAGhR,MAAQgR,EAAGC,UAAYD,EAAGE,aAAe,YAG9C,SAASC,EAA6BH,EAAOhR,GAClD,WACSgR,EAAGhR,KACVgR,EAAGhR,KAAOA,EACV,MAAOuC,IAKT,OADAyO,EAAGC,SAAWD,EAAGE,YAAclR,EACxBgR,EAuCF,SAASI,KACd,IAAMC,EAAQ,mBAYd,MAAO,OAVU,aAAaC,QAAQ,MAAM,WAC1C,OAAOD,EAAME,OAAO9C,KAAK+C,MAAM/C,KAAKC,SAAW2C,EAAMpN,YASjC,IAjDjB,SAAsBwN,GAC3B,GAAoB,mBAATC,KACT,OAAOA,KACLC,mBAAmBF,GAAKH,QAAQ,mBAAmB,SAACzR,EAAG+R,GACrD,OAAOC,OAAOC,aAAaC,SAASH,EAAI,SAE1CN,QAAQ,OAAQ,IAGpB,GAAsB,oBAAXU,OACT,OAAOA,OAAOC,KAAKR,EAAK,QAAQ/P,SAAS,UAAU4P,QAAQ,OAAQ,IAGrE,MAAM,IAAI1O,MAAM,sCA8BDsP,EACb,IAAIlC,MAAOmC,cAAc9J,MAAM,GAAI,IAAIiJ,QAAQ,IAAK,MAEnDA,QAAQ,gBAAiB,IACzBc,cAyCL,SAASC,GAAiB3E,GACxB,IAEE,OAAO3F,KAAKC,UAAUL,GAAgBU,MAAMzI,KAAK8N,IAAO,SAAC4E,EAAQC,GAI/D,MAAmB,mBAARA,EACF,WA7BR,SAAqB/J,GAG1B,GAFA4F,EAAYA,GAAa,IAAIO,EAG3BnG,SAEgB,iBAARA,GAAmC,mBAARA,EAEnC,MAAM,IAAI5F,MAAM,kBAGlB,IAAI4P,EAAMpE,EAAU9N,IAAIkI,GAOxB,OALKgK,IACHA,SAAgBhK,EAAG,IAAI4I,KACvBhD,EAAUW,IAAIvG,EAAKgK,IAGdA,EAWiBC,CAAYF,GAAI,IAtInC,SAAmBG,GACxB,IAAIC,GAAS,EAEb,KACMD,aAAmB5Q,OAAO8Q,SAGhB,OAAZF,GACmB,iBAAZA,GACc,IAArBA,EAAQG,UACiB,iBAAlBH,EAAQI,OACkB,iBAA1BJ,EAAQ/M,iBANfgN,GAAS,GAUX,MAAOI,IAIT,OAAOJ,EAwHCK,CAAUT,GACL,GAGFA,KAET,MAAOhQ,GACP,MAAM,IAAIK,MAAM,6DAIb,SAASqQ,KAEd,MAAO,GAST,IAOIC,GAAqB,EACrBC,GAA8B,EAE3B,SAASC,GACd/F,EACAgG,QAAwB,IAAxBA,MAVO,IAYP,IAEIC,EACAC,EAHsDC,EAAPH,EAA3CI,qBAAa,IAAAD,GAAQA,EAAQE,EAAcL,EAApBhH,KAK3BsH,EAAeT,GACnBA,IAAsB,EAEtB,IAAMU,EAAmB,WAA0C,QAAAC,EAAApD,UAAAxM,OAAbyJ,EAAI,IAAA/F,MAAAkM,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAAJpG,EAAIoG,GAAArD,UAAAqD,GAQxD,IAAIC,EASAC,EAhBAL,EAAeR,KACjBG,EAAc,KACdC,EAAY,KACZI,EAAeT,GACfA,IAAsB,GAOtBa,EAFEN,GACFF,EAAYA,GAAa,IAAI5E,GACXa,SAASnQ,KAAM4T,IAEzBK,EAAcA,GAAe,GAKvC,IACEU,EAAW3B,GAAc3E,GACzB,MAAAuG,GACA,OAAO5G,EAAOM,MAAMtO,KAAMoR,WAG5B,IAAIyD,EAAcH,EAAMC,GAOxB,GALIE,GAAeR,GAAa1D,KAAKmE,MAAQD,EAAY7H,KAAOqH,WACvDK,EAAMC,GACbE,EAAc,MAGZA,EACF,OAAOA,EAAYxT,MAGrB,IAAM2L,EAAO2D,KAAKmE,MACZzT,EAAQ2M,EAAOM,MAAMtO,KAAMoR,WAIjC,OAFAsD,EAAMC,GAAY,CAAE3H,OAAM3L,SAEnBA,GAWT,OARAkT,EAAiBQ,MAAQ,WACvBd,EAAc,KACdC,EAAY,MAMPpC,EAFWyC,GAIbP,EAAQrT,MAAQ+Q,EAAgB1D,IAAO,cAevC,SAASgH,GAEdhH,GAGA,IAAI0G,EAAQ,GAEZ,SAASO,IAGU,QAAAC,EAAA9D,UAAApG,EAAA,KAAAmK,EAAA/D,UAAAxM,OADdyJ,EAAI,IAAA/F,MAAA6M,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAAJ/G,EAAI+G,GAAAhE,UAAAgE,GAEP,IAAMzT,EAAcqR,GAAc3E,GAElC,OAAIqG,EAAM1S,eAAeL,KAIzB+S,EAAM/S,GAAOmJ,EAAagC,KAAI,kBAAMkB,EAAOM,MAAMtD,EAAMoG,MAAYxE,SACjE,kBACS8H,EAAM/S,OALR+S,EAAM/S,GAgBjB,OAJAsT,EAAwBF,MAAQ,WAC9BL,EAAQ,IAGH5C,EACLmD,EACGvD,EAAgB1D,GAAO,qBAyDvB,SAASqH,MA4ET,SAASC,GAAepS,EAAYqS,GACzC,QADsD,IAAbA,MAAgB,GACrDA,GAAS,EACX,MAAO,gCAGT,IACE,IAAKrS,EAEH,MAAO,mBAAmBpC,GAAiBuB,SAAS9B,KAAK2C,GAAI,IAG/D,GAAmB,iBAARA,EACT,OAAOA,EAGT,GAAIA,aAAeK,MAAO,CACxB,IAAMgI,EAAQrI,GAAOA,EAAIqI,MACnBzF,EAAU5C,GAAOA,EAAI4C,QAE3B,GAAIyF,GAASzF,EACX,OAAgC,IAA5ByF,EAAM3H,QAAQkC,GACTyF,EAEGzF,EAAO,KAAKyF,EAEnB,GAAIA,EACT,OAAOA,EACF,GAAIzF,EACT,OAAOA,EAIX,OAAI5C,GAAOA,EAAIb,UAAoC,mBAAjBa,EAAIb,SAE7Ba,EAAIb,WAINvB,GAAiBuB,SAAS9B,KAAK2C,GACtC,MAAOsS,GACP,MAAO,mCAAmCF,GACxCE,EACAD,EAAQ,IA0BP,SAAS5M,GAAUvG,GACxB,MAAoB,iBAATA,EACFA,EAGLA,GAAQA,EAAKC,UAAqC,mBAAlBD,EAAKC,SAEhCD,EAAKC,WAIPvB,GAAiBuB,SAAS9B,KAAK6B,GAiqBjC,SAASD,GAAQC,GAEtB,MAAgD,oBAAzCtB,GAAiBuB,SAAS9B,KAAK6B,GAwCjC,SAAS+N,GACdhH,EACAxH,EACAf,GAEA,GAAIuI,EAAInH,eAAeL,GACrB,OAAOwH,EAAIxH,GAGb,IAAMuR,EAAMtS,IAEZ,OADAuI,EAAIxH,GAAOuR,EACJA,EAr9BTa,GAAQ0B,MAAQ,WACd3B,GAA8BD,IA2T9BE,IApBK,SAAmB5K,GACxB,GAAIrI,OAAOqO,OAET,OAAOrO,OAAOqO,OAAOhG,GAGvB,IAAM7E,EAAmB,GACzB,IAAK,IAAM3C,KAAOwH,EACZA,EAAInH,eAAeL,IAErB2C,EAAOC,KAAK4E,EAAIxH,IAKpB,OAAO2C,KAgyBF,IOr3BoBoR,GPq3BdC,GAAe,SAAAC,GAC1B,SAAAD,EAAY7P,GAAiB,IAAA+P,EAQ1B,OAPDA,EAAAD,EAAArV,KAAA,KAAMuF,IAAQ,MAETnF,KAAOkV,EAAK1L,YAAYxJ,KACU,mBAA5B4C,MAAMuS,kBACfvS,MAAMuS,kBAAiBD,EAAOA,EAAK1L,aAEnC0L,EAAKtK,MAAQ,IAAIhI,MAAMuC,GAASyF,MACjCsK,EACF,OAAAjH,EAAA+G,EAAAC,GAAAD,EAVyB,CAUzBtE,EAVkC9N,QOvzC9B,SAASwS,KAEd,IAAMC,EAAOtM,SAASsM,KAEtB,IAAKA,EACH,MAAM,IAAIzS,MAAM,0BAGlB,OAAOyS,EAGF,SAASC,KAEd,OAAOzN,QAAQkB,SAASsM,OAAiC,aAAxBtM,SAASwM,WAGrC,SAASC,KAEd,OAAO3N,QAAQkB,SAASsM,OAAiC,gBAAxBtM,SAASwM,WAqBcnC,IAAQ,WAChE,OAAO,IAAIjJ,GAAa,SAACH,GACvB,GAAIsL,MAAqBE,KACvB,OAAOxL,IAGT,IAAMyL,EAAWC,aAAY,WAC3B,GAAIJ,MAAqBE,KAEvB,OADAG,cAAcF,GACPzL,MAER,UAgZoBiE,GAAA,kBAAA8G,GAAApH,MAAA,KAAA8C,YAAA,OAAAsE,GAASC,IA40BpC,IAAIY,GAEkB,oBAAb7M,SAA2BA,SAAS6M,cAAgB,KAIhDC,GAAqCzC,IAAQ,WACxD,GAAIwC,GACF,OAAOA,GAKT,GAFAA,GAlCF,WACE,IACE,IAAMhL,EAVH,WACL,IACE,MAAM,IAAIhI,MAAM,KAChB,MAAOL,GACP,OAAOA,EAAIqI,OAAS,IAMNkL,GACRC,EAAe,kCAAkCC,KAAKpL,GACtDqL,EAAiBF,GAAgBA,EAAa,GAEpD,IAAKE,EACH,OACD,QAAAC,EAAA,EAAAC,EAGoBxO,GAAgBU,MAClCzI,KAAKmJ,SAASqN,qBAAqB,WACnCC,UAASH,EAAAC,EAAAlS,OAAAiS,IAAE,CAFT,IAAMI,EAAMH,EAAAD,GAGf,GAAII,EAAOC,KAAOD,EAAOC,MAAQN,EAC/B,OAAOK,GAGX,MAAO/T,KAgBOiU,GAGd,OAAOZ,GAGT,MAAM,IAAIhT,MAAM,uCAGZ6T,GAAarF,KClzCZ,SAASsF,GAAU7U,QAAyB,IAAzBA,MAA4BC,QACpD,IAAM6U,EALGC,yBAOT,OAAI/U,IAAQC,OACHD,EAAI8U,GAEW9U,EAAI8U,GAAa9U,EAAI8U,IAAc,GDgzCLvD,IAAQ,WAC9D,IAAIkD,EAEJ,IACEA,EAAST,KACT,MAAOtT,GACP,OAAOkU,GAGT,IAAIjE,EAAM8D,EAAOO,aEx0CZ,YF00CL,GAAIrE,GAAsB,iBAARA,EAChB,OAAOA,EAKT,IAFAA,EAAM8D,EAAOO,aAAgBC,mBAEH,iBAARtE,EAChB,OAAOA,EAGT,GAAI8D,EAAOC,IAAK,CACd,IAEMQ,EPj+BH,SAAoBtF,GAGzB,IAFA,IAAIzE,EAAO,GAEFvN,EAAI,EAAGA,EAAIgS,EAAIxN,OAAQxE,IAAK,CACnC,IAAIuX,EAAQvF,EAAIhS,GAAGwX,WAAW,GAAKxX,EAE/BgS,EAAIhS,EAAI,KACVuX,GAASvF,EAAIhS,EAAI,GAAGwX,WAAW,IAAMxX,EAAI,IAG3CuN,GAAQ6E,OAAOC,aAAa,GAAMrD,KAAKyI,IAAIF,GAAS,IAGtD,OAAOhK,EOo9BgBmK,CADApP,KAAKC,UAAU,CAAEuO,IADbD,EAAjBC,IACmCa,QADlBd,EAAZc,WAOb5E,EAAM,OAJauE,EAAa1O,MAC9B0O,EAAa9S,OEt1CY,SF21C3BuO,EAAMpB,KAKR,OAFAkF,EAAOe,aAAgBP,gBAAuBtE,GAEvCA,KC10CT,IAAM8E,GAAuB,WAAH,MAAU,IAc7B,SAASC,GACdvW,EACAwW,GAEA,YAHY,IAAZxW,MAAe,cACQ,IAAvBwW,MAA0BF,IAEnB9H,GAASkH,KAAa1V,GAAK,WAChC,IAAIyW,EAAQD,IAEZ,MAAO,CACLjI,IAAK,SAACmI,GACJ,OAAOD,EAAMpW,eAAeqW,IAE9BpX,IAAK,SAACoX,EAAUC,GAEd,OAAOF,EAAMpW,eAAeqW,GAAYD,EAAMC,GAAYC,GAE5D5I,IAAK,SAAC2I,EAAUnF,GAEd,OADAkF,EAAMC,GAAYnF,EACXA,GAETqF,IAAK,SAACF,UACGD,EAAMC,IAEflI,SAAU,SAACkI,EAAUzX,GAEnB,OAAOuP,GAASiI,EAAOC,EAAUzX,IAEnCmU,MAAO,WACLqD,EAAQD,KAEVjJ,KAAM,WACJ,OAAOpO,OAAOoO,KAAKkJ,QAMpB,I,GAAMI,GAAQ,aAEd,SAASC,KACd,IAAMC,EAASrB,KAEf,OADAqB,EAAOC,gBAAkBD,EAAOC,iBAAmB,IAAIH,GAChDE,EAAOC,gBAYT,SAASC,GACdjX,EACAwW,GAEA,YAHY,IAAZxW,MAAe,cACQ,IAAvBwW,MAA0BF,IAEnBC,GAAY,eAAe/H,SAASxO,GAAK,WAC9C,IAAMkX,EAAW,IAAIvJ,EAEfwJ,EAAW,SAACtW,GAChB,OAAOqW,EAAS1I,SAAS3N,EAAK2V,IAGhC,MAAO,CACLjI,IAAK,SAAC1N,GAEJ,OADcsW,EAAStW,GACVR,eAAeL,IAE9BV,IAAK,SAACuB,EAAK8V,GACT,IAAMF,EAAQU,EAAStW,GAEvB,OAAO4V,EAAMpW,eAAeL,GAAOyW,EAAMzW,GAAO2W,GAElD5I,IAAK,SAAClN,EAAK0Q,GAGT,OAFc4F,EAAStW,GACjBb,GAAOuR,EACNA,GAETqF,IAAK,SAAC/V,UACUsW,EAAStW,GACVb,IAEfwO,SAAU,SAAC3N,EAAK5B,GAEd,OAAOuP,GADO2I,EAAStW,GACAb,EAAKf,QEvHpC,SAASmY,KACP,OAAOb,GAAY,YAAY/H,SAAS,aAAc4B,IAUxD,SAASiH,GACPxW,EAA0ByW,GAEU,IADlCtV,EAAMsV,EAANtV,OAEIuV,EAAgBN,GAAY,iBAC5BO,EAAkBD,EAAcjY,IAAIuB,GACtC2W,GACFA,EAAgBxO,QAAQ,CAAEhH,WAE5B,IAAMyV,EAAatO,EAAaH,QAAQ,CAAEhH,WAE1C,OADAuV,EAAcxJ,IAAIlN,EAAK4W,GAChBA,EAUF,SAASC,GACd7W,EAA0B8W,GAO1B,OAAOC,EANDD,EAAJC,MAOA/W,ECvCM,kBDyCN,CAAEgX,WAAYT,MACd,CAAEpV,OC7BkB,ID6BAoJ,SAAU,IAC9B3C,MAAK,SAAAqP,GAAsC,IAAnCpR,EAAMoR,EAANpR,OAAgBmR,EAAUC,EAAlBC,KAAQF,WAExB,OADAR,GAAoBxW,EAAK,CAAEmB,OAAQ0E,IAC5B,CAAE7F,MAAKmB,OAAQ0E,EAAQmR,iBAI3B,SAASG,GACdnX,EAA0BoX,GAEJ,IADpBL,EAAIK,EAAJL,KAEF,OAAOX,GAAY,4BAA4BzI,SAAS3N,GAAK,WAC3D,OAAO6W,GAAS7W,EAAK,CAAE+W,SAAQnP,MAAK,SAAAyP,GAAa,OAAAA,EAAVL,iBA4BpC,SAASM,GACdtX,EACAuK,EACApM,QADe,IAAfoM,MAAkB,UACN,IAAZpM,MAAe,UAEf,IAAI+J,EArFN,SACElI,GAGA,OADsBoW,GAAY,iBACbzI,SAAS3N,GAAK,kBAAM,IAAIsI,KAiF/BiP,CAAgBvX,GAS9B,OAPiB,IAAbuK,IACFrC,EAAUA,EAAQqC,QAChBA,EACA,IAAIxJ,MAAS5C,EAAI,uBAAuBoM,EAAO,QAI5CrC,EEzGF,SAASsP,GAAgBxX,GACToW,GAAY,gBACpBlJ,IAAIlN,GAAK,GCHjB,SAASyX,GAAiB7X,GAC7B,MAAwB,iBAATA,GAA8B,OAATA,GAA0C,iBAAlBA,EAAK8X,SAG9D,SAASC,GAAcjH,GAC1B,YAAmB,IAARA,ECIC,YDAA,OAARA,ECDQ,ODKR5K,MAAMC,QAAQ2K,GCVN,QDcO,mBAARA,ECnBC,WDuBO,iBAARA,EAEHA,aAAe3P,MCxBX,QD4BgB,mBAAb2P,EAAI9I,KC3BP,UDgCoC,oBAAxCtJ,GAAiBuB,SAAS9B,KAAK2S,GC/B3B,QDoCoC,kBAAxCpS,GAAiBuB,SAAS9B,KAAK2S,GCnC3B,OAEA,SDwCO,iBAARA,ECvCC,SD2CO,iBAARA,EC1CC,SD8CO,kBAARA,EC7CC,eD6CZ,EAKG,SAASkH,GAAqCC,EAAUnH,GAC3D,MAAO,CACHgH,SAAUG,EACVC,QAAUpH,GExBlB,I,GAAMqH,KAAwBC,GAAG,IACd,SCtCZ,aDsCkCA,GACzB,ME3BT,SAAuBvB,GAC1B,OAAOmB,GHbK,QGaqB,CAAEtU,QADCmT,EAAPnT,QACeyF,MADD0N,EAAL1N,MACakP,KADFxB,EAAJwB,KACYf,KADFT,EAAJS,QF2BjBc,GACpB,QGtCX,aHsCiCA,GACxB,MIrCT,SAAwBtH,GAC3B,OAAOkH,GLHK,QKGqBlH,EAAIwH,SJoCHF,GACvB,KKtCR,SAAuBtH,GAC1B,OAAOkH,GNFK,OMEoBlH,EAAIyH,WLqCHH,GACrB,MM3CT,SAAmCtH,GACtC,OAAOA,GN0C2BsH,GACrB,OO5CV,SAAyBtH,GAC5B,OAAOA,GP2C4BsH,GACtB,OQ7CV,SAAyBtH,GAC5B,OAAOA,GR4C4BsH,GACtB,OS9CV,SAAyBtH,GAC5B,OAAOA,GT6C4BsH,GACrB,QU/CX,SAA0BtH,GAC7B,OAAOA,GV8C6BsH,GACzB,KWhDR,SAAuBtH,GAC1B,OAAOA,GX+C0BsH,QDtCrB,GaNT,SAA4BtH,GAC/B,OAAOkH,GbKK,YaLyBlH,IZ4CCsH,IAIpCI,GAAmC,GajBnCC,KAA4BC,GAAG,IAClB,SZjCZ,WACH,MAAM,IAAIvX,MAAM,sEYgCuBuX,GAC3B,MXtBT,SAAyBC,GAA2D,IAA/CxP,EAAKwP,EAALxP,MAAOkP,EAAIM,EAAJN,KAAMf,EAAIqB,EAAJrB,KAC/CtO,EAAQ,IAAI7H,MADoBwX,EAAPjV,SAW/B,OARAsF,EAAMqP,KAAOA,EAETf,IAEAtO,EAAMsO,KAAuBA,GAGjCtO,EAAMG,MAAYA,EAAK,OAASH,EAAMG,MAC/BH,GWW6B0P,GACtB,QVjCX,WACH,MAAM,IAAIvX,MAAM,qEUgCsBuX,GAC1B,MThCT,SAA0B5H,GAE7B,OAAO,IAAI8H,OAAO9H,IS8BkB4H,GACzB,KRjCR,SAAyB5H,GAC5B,OAAO,IAAIvC,KAAKuC,IQgCmB4H,GACvB,MPtCT,SAAqC5H,GACxC,OAAOA,GOqC6B4H,GACvB,ONvCV,SAA2B5H,GAC9B,OAAOA,GMsC8B4H,GACxB,OLxCV,SAA2B5H,GAC9B,OAAOA,GKuC8B4H,GACxB,OJzCV,SAA2B5H,GAC9B,OAAOA,GIwC8B4H,GACvB,QH1CX,SAA4B5H,GAC/B,OAAOA,GGyC+B4H,GAC3B,KF3CR,SAAyB5H,GAC5B,OAAOA,GE0C4B4H,QdrCvB,GaFT,aCwCqCA,IAItCG,GAAuC,GCtCtC,SAASC,KACd,QAAIxU,EAAajE,QAAQgG,MAAM,mCAO1B,SAAS0S,GAAkB3Y,GAChC,OAAKkF,EAAgBjF,OAAQD,GAOxB,SAAS4Y,GACdzX,EACAnB,GAEA,GAAImB,GACF,GAAID,MAAgBoF,EAAiBnF,GACnC,OAAO,OAEJ,GAAInB,IACJqB,EAAarB,GAChB,OAAO,EAIX,OAAO,EAGF,SAAS6Y,GAAWpC,GAMd,IALXzW,EAAGyW,EAAHzW,IACAmB,EAAMsV,EAANtV,OAKA,SAAKuX,MAIDvX,IAAWyX,GAAqBzX,EAAQnB,IAIxCA,IAAQ2Y,GAAkB3Y,IAOzB,SAAS8Y,GAAc3X,GAO5B,MAFc4X,yBAJd5X,EAASA,GAAUmF,EAAiBnF,IAELsO,QAAQ,iBAAkB,KAOpD,SAASuJ,KACd,OAAOhT,QAAQ/F,OAAO9B,MAAQ8B,OAAO9B,OAAS2a,GAAc5X,MAGvD,IAAM+X,GACX,IAAI3Q,GAAa,SAACH,GAChB,GAAIlI,OAAOiH,UAAYjH,OAAOiH,SAASsM,KACrC,OAAOrL,EAAQlI,OAAOiH,SAASsM,MAGjC,IAAMI,EAAWC,aAAY,WAC3B,GAAI5T,OAAOiH,UAAYjH,OAAOiH,SAASsM,KAErC,OADAM,cAAcF,GACPzL,EAAQlI,OAAOiH,SAASsM,QAEhC,OAGA,SAAS0F,GAAqBlZ,GACNoW,GAAY,wBACpBzI,SAAS3N,GAAK,kBAAM,IAAIsI,KAGxC,SAAS6Q,GACdnZ,GAQA,IACMoZ,EADuBhD,GAAY,wBACK3X,IAAIuB,GAElD,IAAKoZ,EACH,MAAM,IAAIrY,MAAM,mCAGlB,OAAOqY,EAQF,SAASC,GACdrZ,EACAmB,EACAmY,GAoBAH,GAAiBnZ,GAAKmI,SAlBK,SACzBoR,EACAC,EACAlW,GAEA,GAAIiW,IAAcvZ,EAChB,MAAM,IAAIe,MAAM,uCAGlB,IAAK4E,EAAY6T,EAAcrY,GAC7B,MAAM,IAAIJ,MAAM,iBACGyY,EAAY,0BAA0BrY,GAI3DmY,EAAYG,cAAcnW,MAMvB,SAASoW,GACd1Z,EACAU,GAEAyY,GAAiBnZ,GAAKkJ,OAAOxI,GAAKwJ,MAAM2I,IC+CnC,SAAS8G,GAAUC,GAEmC,IAFa,IAA7C5Z,EAAG4Z,EAAH5Z,IAAK7B,EAAIyb,EAAJzb,KAAMgD,EAAMyY,EAANzY,OAChC0Y,EAAqBnE,GAAY,sBACjCoE,EAAoB1D,GAAY,qBAAqB2D,EAAA,EAAAC,EAErCH,EAAmBnN,OAAMqN,EAAAC,EAAA5X,OAAA2X,IAAE,CAA5C,IAAME,EAAOD,EAAAD,GACVG,EAAUL,EAAmBpb,IAAIwb,GAClCC,IAAW/W,EAAe+W,EAAQla,MACrC6Z,EAAmB9D,IAAIkE,GAI3B,GAAI9W,EAAenD,GACjB,MAAO,CAAEA,MAAK7B,OAAMgD,UAGtB,IAAM+Y,EAAUJ,EAAkBnM,SAAS3N,GAAK,WAC9C,OAAK7B,EAKE0b,EAAmBlM,SAASxP,GAAM,WACvC,MAAO,CAAE6B,MAAK7B,WALP,CAAE6B,UASb,GAAIka,EAAQla,KAAOka,EAAQla,MAAQA,EACjC,MAAM,IAAIe,MAAM,gDACiC5C,GAAQ,cAgB3D,OAZIA,IACF+b,EAAQ/b,KAAOA,EACf0b,EAAmB3M,IAAI/O,EAAM+b,IAG3B/Y,IACF+Y,EAAQ/Y,OAASA,EACjB+X,GAAqBlZ,IAGvB8Z,EAAkB5M,IAAIlN,EAAKka,GAEpBA,ECnPF,SAASC,GAAW1D,GAQvB,IDmPI2D,EC1PNC,EAAE5D,EAAF4D,GACAtD,EAAIN,EAAJM,KACAuD,EAAc7D,EAAd6D,eDwPMF,EAAana,OAAOsa,KAE1Bta,OAAOsa,KAAO,SACZhU,EACApI,EACAqT,EACAgJ,GAEA,IAAMxa,EAAMoa,EAAWrc,KACrBP,KvCi0BC,SAA0B+I,GAC/B,GAJyC,IAIvBD,EAAiBC,GAJrBnF,QDvkCP,SC4kCL,OAAOmF,EAIP,MAAM,IAAIxF,MAAM,4CuCt0Bd0Z,CAAiBlU,GACjBpI,EACAqT,EACAgJ,GAGF,OAAKxa,GAIL2Z,GAAW,CAAE3Z,MAAK7B,OAAMgD,OAAQoF,EAAMD,EAAiBC,GAAO,OAEvDvG,GALEA,GAtPN,SAA4ByW,GAQ/B,IAPF4D,EAAE5D,EAAF4D,GACAtD,EAAIN,EAAJM,KACAuD,EAAc7D,EAAd6D,eAMMT,EAAqBnE,GAAY,sBAEvC2E,EnBzBc,yBmByBe,SAAA9B,GAA8B,IAA3BL,EAAMK,EAANL,OAAQrS,EAAM0S,EAAN1S,OAAQqR,EAAIqB,EAAJrB,KACxCwD,EAAgBhF,GAAY,WAAWjX,IAAIoH,GAEjD,IAAK6U,EACH,MAAM,IAAI3Z,MAAM,0CAA0C8E,GAG5D,OAAO6U,EAAc9S,MAAK,SAAC+S,GACzB,GAAIzC,IAAWyC,EACb,MAAM,IAAI5Z,MAAM,gEACkD8E,GAIpE,IAAKqR,EAAK/Y,KACR,MAAM,IAAI4C,MAAM,qDAGlB,IAAKmW,EAAKoC,YACR,MAAM,IAAIvY,MAAM,4DAKlB,IAAK8Y,EAAmBnM,IAAIwJ,EAAK/Y,MAC/B,MAAM,IAAI4C,MAAM,oBACMmW,EAAK/Y,KAAI,qDAIjC,IAAMyc,EAAmB,WAGvB,OAFmBf,EAAmBpb,IAAIyY,EAAK/Y,OAKjD,IAAKyc,IAAmBzZ,OACtB,MAAM,IAAIJ,MAAM,iDACmCmW,EAAK/Y,MAI1D,GAAIyc,IAAmBzZ,SAAW0E,EAChC,MAAM,IAAI9E,MAAM,kBACI8E,EAAM,+CACtB+U,IAAmBzZ,QAAU,YAWnC,OANAkY,GACEuB,IAAmB5a,IACnB6F,EACAqR,EAAKoC,aAGA,CACLA,YAAW,SAAChW,GACV,GAAKrD,SAAUA,OAAOoD,QAIjBuX,IAAL,CAIA,IAAMzZ,EAASyZ,IAAmBzZ,OAElC,GAAKA,EAIL,IACEmZ,EACE,CACEpD,KAAM5T,EACNuC,OAAQ1E,EACR+W,OAAQ0C,IAAmB5a,KAE7B,CAAEqa,KAAItD,SAER,MAAOrW,GACP4H,EAAaY,OAAOxI,aCzG9Bma,CAAoB,CAAER,KAAItD,OAAMuD,mBCmC3B,SAAgC/B,GAAiC,IAA9BxB,EAAIwB,EAAJxB,KACxClC,GAAU5U,QAAQ6a,mBAAqB,SAA2BlB,GAKL,IAJ3Dzb,EAAIyb,EAAJzb,KACA+Z,EAAM0B,EAAN1B,OACA6C,EAAMnB,EAANmB,OACAzB,EAAWM,EAAXN,YAEM0B,EAAgBtF,GAAY,iBAC5BuF,EAAeza,EAAUP,QAE/B,IAAKgb,EACH,MAAM,IAAIla,MAAM,4CAGlB,IAAMma,EA3BV,SAAwBzE,GAKS,IAJ/BtY,EAAIsY,EAAJtY,KACA+Z,EAAMzB,EAANyB,OACA6C,EAAMtE,EAANsE,OACAzB,EAAW7C,EAAX6C,aA9BF,WACqD,IAAnD,IAAM0B,EAAgBtF,GAAY,iBAAiBqE,EAAA,EAAAoB,EAEjCH,EAActO,OAAMqN,EAAAoB,EAAA/Y,OAAA2X,IAAE,CAAnC,IAAM5a,EAAGgc,EAAApB,GAUR5W,EATiB6X,EAAc7b,GASH+Y,SAC9B8C,EAAcjF,IAAI5W,IAkBtBic,GACA,IAAMF,EAAK3L,KAGX,OAFsBmG,GAAY,iBACpBxI,IAAIgO,EAAI,CAAE/c,OAAM+Z,SAAQ6C,SAAQzB,gBACvC4B,EAiBMG,CAAgB,CAAEld,OAAM+Z,SAAQ6C,SAAQzB,gBAEnD,OAAOvC,EACLkE,ErBtDU,wBqBwDV,CACE9c,OAEAmb,YAAW,WACT,IAAMgC,EAAeN,EAAcvc,IAAIyc,GAUvC,GACGI,GACAA,EAAapD,SACd/U,EAAemY,EAAapD,QAH9B,CAQA,IACEoD,EAAaP,SACb,MAAOra,GACP,OAIF4a,EAAahC,YAAYxN,MAAMtO,KAAMoR,cAGzC,CAAEzN,OrB5EgB,OoBTtBoa,CAAwB,CAAExE,SE+CrB,SAA2BN,GAQV,IAPtB4D,EAAE5D,EAAF4D,GACAtD,EAAIN,EAAJM,KACAuD,EAAc7D,EAAd6D,eAMOhS,EAAagC,KAAI,WACtB,IAnDFtK,EAmDQY,EAASD,EAAUV,QAEzB,GAAKW,GAAWiY,GAAY,CAAE7Y,IAAKY,IAMnC,OAFAsY,GAAqBtY,IAzDvBZ,EA2DoCY,EAzD7BwV,GAAY,wBAAwBzI,SAAS3N,GAAK,WACvD,OAAOsI,EAAagC,KAAI,WACtB,IAAMjI,EAAQiC,EAAetE,EAAK8Y,GAAc5X,MAEhD,GAAKmB,EAIL,OAAIhB,EAAagB,IAAUwS,GAAUnT,EAAiBW,IAC7CA,EAGF,IAAIiG,GAAa,SAACH,GACvB,IAAIyL,EAEArJ,EAGJqJ,EAAWC,aAAY,WACrB,GACExR,GACAhB,EAAagB,IACbwS,GAAUnT,EAAiBW,IAI3B,OAFAyR,cAAcF,GACdlJ,aAAaH,GACNpC,EAAQ9F,KAEhB,KAEHkI,EAAUhB,YAAW,WAEnB,OADAuK,cAAcF,GACPzL,MACN,eAwBmCP,MAAK,SAAC+S,GAC9C,OAAKA,EAOA1a,OAAO9B,KAOL0W,GAAUnT,EAAiBiZ,IAC/BG,mBAAmB,CAClB3c,KAAM8B,OAAO9B,KAEb+Z,OAAQjY,OAER8a,OAAM,aAINzB,YAAW,SAAChW,GACV,IACOrD,OACL,MAAOS,GACP,OAGF,GAAKT,SAAUA,OAAOoD,OAItB,IACEiX,EACE,CACEpD,KAAM5T,EAENuC,OAAQrI,KAAKqI,OAEbqS,OAAQ1a,KAAK0a,QAEf,CAAEmC,KAAItD,SAER,MAAOrW,GACP4H,EAAaY,OAAOxI,OAIzBkH,MAAK,SAAA2Q,GAA8B,IAA3BL,EAAMK,EAANL,OAAQrS,EAAM0S,EAAN1S,OAAQqR,EAAIqB,EAAJrB,KACvB,GAAIgB,IAAWtX,EACb,MAAM,IAAIG,MAAM,gCAGlBsY,GAA0BnB,EAAQrS,EAAQqR,EAAKoC,gBAEhDpP,OAAM,SAACxJ,GAEN,MADAgZ,GAAwB9Y,EAAQF,GAC1BA,KApDDgZ,GACL9Y,EACA,IAAIG,MAAM,8DATL2Y,GACL9Y,EACA,IAAIG,MAAM,kEFpElBya,CAAmB,CAAEnB,KAAItD,OAAMuD,mBGajC,SAASmB,KACgD,IAAvD,IAAMC,EAAkBhG,GAAY,mBAAmBqE,EAAA,EAAA4B,EACtCD,EAAgBhP,OAAMqN,EAAA4B,EAAAvZ,OAAA2X,IAAE,CAApC,IAAMmB,EAAES,EAAA5B,GAEP2B,EAAgBjd,IAAIyc,GAAIU,eAC1BF,EAAgB3F,IAAImF,IAwB1B,SAASW,GACPC,EAA+CrF,GAEzB,IADpBM,EAAIN,EAAJM,KAAIgF,EAAAtF,EAAEyE,UAAE,IAAAa,EAAGxM,KAAUwM,EAEnBC,EAAoBF,EAAWlU,MAAK,SAAC5H,GACvC,GAAIqB,EAAarB,GACf,OAAO0B,EAAiB1B,GAAK7B,QAI3B8d,EAAoBH,EAAWlU,MAAK,SAAC3H,GACzC,GAAKkD,EAAelD,GAGlB,MAAM,IAAIc,MAAM,4CAFhB,OAAOJ,EAAUV,G5C9Db,QADC,Y4CqET+b,EAAkB9R,MAAM2I,IACxBoJ,EAAkB/R,MAAM2I,IAExB,IAAMqJ,EAAU,WAAH,OACXJ,EAAWlU,MAAK,SAAC5H,GACf,IAAImD,EAAenD,GAInB,OAAIqB,EAAarB,GACR0B,EAAiB1B,GAAK7B,KAGxB6d,MA0DX,MAAO,CACLd,KACAiB,QAAS,WACP,OAAOF,GAET1F,cAAe/D,IAAe,kBAC5BsJ,EAAWlU,MAAK,SAAC5H,GAAG,OAAKmX,GAAoBnX,EAAK,CAAE+W,eAEtDvP,MAAO,kBAAMsU,EAAWlU,KAAKR,IAC7B8U,UACAE,MAAO,kBACLN,EAAWlU,MAAK,SAAC5H,GACfA,EAAIoc,YAERC,SAAU,kBACRP,EAAWlU,MAAK,SAAC5H,GACf,OAAOmD,EAAenD,OAE1Bsc,YApEkB,SAClBC,EACAC,GAA0D,YAAjC,IAAzBA,MALO,IAOPV,EAAWlU,MAAK,SAAC5H,GACf,IAAMmB,EAAYlB,OAAOC,SAASC,SAAQ,KAAKF,OAAOC,SAASe,KACrBwb,EAAJD,EAA9BhR,cAAM,IAAAiR,EvBrEZ,MuBqEyBA,EAAEjJ,EAASgJ,EAAThJ,KAE7B,GAA0B,IAAtB+I,EAAKnb,QAAQ,KACfmb,EAAO,GAAGpb,EAASob,OACd,IAAKA,EAAKtW,MAAM,iBAA4C,IAAzBsW,EAAKnb,QAAQD,GACrD,MAAM,IAAIJ,MAAM,+DACiDmF,KAAKC,UAClEoW,IAKN,GvBhFG,SuBgFC/Q,EACF,OAAO0Q,IAAUtU,MAAK,SAACzJ,GACrB,IAAKA,EACH,MAAM,IAAI4C,MAAM,+C3B2vCrB,SAAmB6Y,GAKJ,IAJpBrT,EAAGqT,EAAHrT,IACAmW,EAAM9C,EAAN8C,OACAlJ,EAAIoG,EAAJpG,KAAImJ,EAAA/C,EACJpO,cAAM,IAAAmR,EAAG,OAAMA,EAETC,EAAO1V,SAAS2V,cAAc,QAMpC,GALAD,EAAKpH,aAAa,SAAUkH,GAC5BE,EAAKpH,aAAa,SAAUhK,GAC5BoR,EAAKpH,aAAa,SAAUjP,GAC5BqW,EAAK3L,MAAM6L,QAAU,OAEjBtJ,EAAM,QAAAuJ,EAAA,EAAAC,EACU1e,OAAOoO,KAAK8G,GAAKuJ,EAAAC,EAAA5a,OAAA2a,IAAE,KAAAE,EAA1B9d,EAAG6d,EAAAD,GACNG,EAAQhW,SAAS2V,cAAc,SACrCK,EAAM1H,aAAa,OAAQrW,GAC3B+d,EAAM1H,aAAa,QAAkB,OAAXyH,EAAEzJ,EAAKrU,SAAI,EAAT8d,EAAWpd,YACvC+c,EAAKO,YAAYD,GAIrB3J,KAAU4J,YAAYP,GACtBA,EAAKQ,SACL7J,KAAUhM,YAAYqV,G2B/wCdS,CAAW,CACT9W,IAAKgW,EACLG,OAAQve,EACRqN,SACAgI,YAGC,GvB9FL,QuB8FShI,EAeT,MAAM,IAAIzK,MAAM,uBAAuByK,GAdvC,GAAInK,EAAarB,GACf,IACE,GAAIA,EAAIE,UAA4C,mBAAzBF,EAAIE,SAASuP,QAGtC,YADAzP,EAAIE,SAASuP,QAAQ8M,GAGvB,MAAO7b,IAKXV,EAAIE,SAAWqc,MAyBnBe,QAAS,SAACnf,GAAI,OACZ2d,EAAWlU,MAAK,SAAC5H,GAEb2Z,GAAW,CAAE3Z,MAAK7B,SAGpB,IAAMof,EAAalc,EAAarB,GAC1BqC,EAAQyE,EAAkB9G,GAEhC,IAAKud,EACH,MAAM,IAAIxc,MAAM,6CAA6C5C,GAG/DuD,EAAiB1B,GAAK7B,KAAOA,EACzBkE,GACFA,EAAMmT,aAAa,OAAQrX,GAG7B6d,EAAoB1T,EAAaH,QAAQhK,QAK1C,IAAMqf,GAAW,WAStB,SAAAA,EAAAjF,GAQI,IAPFxB,EAAIwB,EAAJxB,KACA/W,EAAGuY,EAAHvY,IACAyd,EAAgBlF,EAAhBkF,iBAAgB,KAXlBvC,QAAE,OACFwC,eAAsB,EAAI,KAC1BD,sBAAgB,OAChBE,kBAAY,OACZC,yBAAmB,OACnB7G,UAAI,OACJ5Y,UAAI,EAWFX,KAAKogB,oBAAsB,IAAItV,EAC/B9K,KAAKigB,iBACHA,GACA5B,GAAoBre,KAAKogB,oBAAqB,CAAE7G,SAElDrB,GAAY,mBAAmBxI,IAAI1P,KAAKqgB,QAASrgB,MAC7CwC,GACFxC,KAAKsgB,UAAU9d,EAAK,CAAE+W,SAEzB,IAAA5N,EAAAqU,EAAApU,UAqKA,OArKAD,EAED0U,MAAA,WACE,OAAOrgB,KAAKigB,iBAAiBvC,IAC9B/R,EAEDgT,QAAA,WACE,OAAO3e,KAAKigB,iBAAiBtB,WAC9BhT,EAED4U,QAAA,WACE,OAAOvgB,KAAK2e,UAAUvU,MAAK,SAACiQ,GAC1B,M5C5NI,U4C4NGA,MAEV1O,EAEDmT,YAAA,SACEC,EACAC,GAC2B,IAAAhU,EAAA,KAC3B,OAAOhL,KAAKigB,iBAAiBnB,YAAYC,EAAMC,GAAM5U,MAAK,kBAAMY,MACjEW,EAED+S,QAAA,WACE,OAAO1e,KAAKigB,iBAAiBvB,WAC9B/S,EAEDmU,QAAA,SAAQnf,GAAyC,IAAAmL,EAAA,KAC/C,OAAO9L,KAAKigB,iBAAiBH,QAAQnf,GAAMyJ,MAAK,kBAAM0B,MACvDH,EAED3B,MAAA,WAAmC,IAAAiD,EAAA,KACjC,OAAOjN,KAAKigB,iBAAiBjW,QAAQI,MAAK,kBAAM6C,MACjDtB,EAEDiT,MAAA,WAAmC,IAAA4B,EAAA,KAC3BC,EAAiBzgB,KAAKugB,UACtBG,EAAiB1gB,KAAK0e,UAEtBiC,EAAgB7V,EAAa6C,KAAK,CACtC4S,QAASE,EACT9f,KAAM+f,IACLtW,MAAK,SAAAgS,GAAuB,IAAXzb,EAAIyb,EAAJzb,KAAFyb,EAAPmE,SACM5f,GACb8B,OAAOsa,KAAK,GAAIpc,EAAM,eAGpBigB,EAAe5gB,KAAKigB,iBAAiBrB,QAE3C,OAAO9T,EAAawC,IAAI,CAACqT,EAAeC,IAAexW,MAAK,kBAAMoW,MACnE7U,EAEDkT,SAAA,WACE,OAAO7e,KAAKigB,iBAAiBpB,YAC9BlT,EAEDkV,UAAA,WACE,OAAO7gB,KAAKmgB,cACbxU,EAED2U,UAAA,SAAU9d,EAA0B8W,GAAkC,IAA9BC,EAAID,EAAJC,KACtCvZ,KAAKmgB,aAAe3d,EACpBxC,KAAKogB,oBAAoBzV,QAAQ3K,KAAKmgB,cACtCngB,KAAKigB,iBAAmB5B,GAAoBre,KAAKogB,oBAAqB,CACpE7G,OACAmE,GAAI1d,KAAKqgB,UAEXzH,GAAY,oBAAoBlJ,IAAIlN,EAAKxC,OAC1C2L,EAEDmV,YAAA,WACE,OAAO9gB,KAAKogB,qBACbzU,EAEDoV,YAAA,SACEve,EAA0BiX,GAEH,IAAAuH,EAAA,KADrBzH,EAAIE,EAAJF,KAEF,OAAOzO,EAAagC,KAAI,WACtB,OAAIkU,EAAKb,aACA3d,IAAQwe,EAAKb,aAGfrV,EAAa6C,KAAK,CACvBsT,gBAAiBD,EAAKjI,gBACtBmI,sBAAuBvH,GAAoBnX,EAAK,CAAE+W,WACjDnP,MAAK,SAAAwP,GAAgD,IAChDnR,EADkBmR,EAAfqH,kBAAsCrH,EAArBsH,sBAO1B,OAJIzY,GACFuY,EAAKV,UAAU9d,EAAK,CAAE+W,SAGjB9Q,SAGZkD,EAEDwV,OAAA,WACE,OAAOnhB,KAAKmgB,cAAgBngB,MAC7B2L,EAEDoN,cAAA,WACE,OAAO/Y,KAAKigB,iBAAiBlH,iBAC9BpN,EAEDyS,YAAA,WACE,OAAO5V,QAAQxI,KAAKmgB,cAAgBxa,EAAe3F,KAAKmgB,gBACzDxU,EAEDyV,UAAA,WACE,OAAOphB,KAAKigB,kBACbD,EAEMmB,OAAP,SACE3e,GAEA,OAAOwd,EAAYE,cAAc1d,GAE7BA,EAAI2e,SACJ3e,GACLwd,EAEMoB,UAAP,SACE5e,EAAwCqX,GAElB,IADpBN,EAAIM,EAAJN,KAGF,OADA0E,KACO+B,EAAYqB,cAAc7e,EAAK,CAAE+W,SAAQ6H,aACjDpB,EAEMsB,YAAP,SACErB,EAAsCsB,GAEzB,IADXhI,EAAIgI,EAAJhI,KAGF,OADA0E,KAEE/F,GAAY,mBAAmBjX,IAAIgf,EAAiBvC,KACpD,IAAIsC,EAAY,CAAEC,mBAAkB1G,UAEvCyG,EAEME,cAAP,SAAqB/W,GAEnB,OAAOX,QAAQW,IAAQD,EAASC,IAAQA,EAAI+W,gBAC7CF,EAEMqB,cAAP,SACE7e,EAAwCgf,GAE3B,IADXjI,EAAIiI,EAAJjI,KAIF,GAFA0E,KAEI+B,EAAYE,cAAc1d,GAE5B,OAAOA,EAIT,IAAM2d,EAAsC3d,EAE5C,OACEoW,GAAY,oBAAoB3X,IAAIkf,IACpC,IAAIH,EAAY,CAAExd,IAAK2d,EAAc5G,UAExCyG,EAhMqB,GCrKxB,SAASyB,GACP/D,EACAxK,EACAvS,EACA+Z,EACA/W,GAEA,IAAM+d,EAAc9I,GAAY,eAC1B+I,EAAqBzJ,GAAY,sBAEnC8H,GAAYE,cAAcxF,GAC5BiH,EAAmBjS,IAAIgO,EAAI,CAAExK,MAAKvS,OAAMgD,SAAQ+W,YAEhDiH,EAAmBpJ,IAAImF,GAEPgE,EAAYvR,SAASuK,GAAQ,iBAAO,MAC5CgD,GAAM,CAAE/Z,SAAQhD,OAAMuS,MAAKwH,WAIvC,SAASkH,GACPlH,EACAgD,GAEA,IAAMgE,EAAc9I,GAAY,eAC1B+I,EAAqBzJ,GAAY,sBAEvC,OADgBwJ,EAAYvR,SAASuK,GAAQ,iBAAO,MACrCgD,IAAOiE,EAAmB1gB,IAAIyc,GAyIxC,SAASmE,GACdC,EACAne,EACAuP,EACAvR,EAAWya,GA7Gb,IAA+BnD,EAC7B4D,EACAtD,EADAsD,GAD6B5D,EAgHN,CAAE4D,GAFrBT,EAAFS,GAE2BtD,KAFnB6C,EAAJ7C,OA7GNsD,GACAtD,EAAIN,EAAJM,KAKOrB,GAAY,oBAAoB/H,SAAS,iBAAiB,WAC/D,OAAO0M,ExBjFA,mBwBmFL,CAAElZ,OxBrEgB,MwBsElB,SAAAoX,GAQO,IAPLL,EAAMK,EAANL,OACArS,EAAM0S,EAAN1S,OACAqR,EAAIqB,EAAJrB,KAMQgE,EAAahE,EAAbgE,GAAI/c,EAAS+Y,EAAT/Y,KAENohB,EAAOH,GAAalH,EAAQgD,GAElC,IAAKqE,EACH,MAAM,IAAIxe,MAAM,0BACY5C,EAAI,cAAc+Y,EAAKgE,GAAE,OAAOha,EACxDjB,SAKN,IAAgBuf,EAA8BD,EAAtCrH,OAAsB/W,EAAgBoe,EAAhBpe,OAAQuP,EAAQ6O,EAAR7O,IAEtC,OAAOpI,EAAagC,KAAI,WACtB,IAAK3E,EAAYxE,EAAQ0E,GACvB,MAAM,IAAI9E,MAAM,WACHmW,EAAK/Y,KAAI,YAAY+H,KAAKC,UAEnCxG,GAAQ4f,EAAKpe,QAAUoe,EAAKpe,OAAO+W,OAASqH,EAAKpe,QAClD,0BAA0B0E,EAAM,OAAO3E,EAAUjB,SAItD,GAAIud,GAAYE,cAAc8B,GAE5B,OAAOA,EAAajB,YAAYrG,EAAQ,CAAEnB,SAAQnP,MAAK,SAAC3B,GACtD,IAAKA,EACH,MAAM,IAAIlF,MAAM,gBAEZmW,EAAK/Y,KAAI,oDACyC+C,EAClDjB,eAOT2H,MACC,WACE,OAAO8I,EAAI5E,MAAM,CAAEoM,SAAQrS,UAAUqR,EAAKrL,SAE5C,SAACnL,GACC,OAAO4H,EAAagC,KAAI,WACtB,GAAIoG,EAAI1G,QACN,OAAO0G,EAAI1G,QAAQtJ,MAEpBkH,MAAK,WAjGtB,IAA4BiE,EnCm5BCjM,EmCxyBb,MARIc,EAAIqI,QAENrI,EAAIqI,MAAQ,kBAAkB5K,EAAI,UArGG,KAA3B0N,EAsGRqL,EAAKrL,QAtGGA,EAA8B,KnCm5B7BjM,EmCl5BViM,EnCo5BV/F,GAAgBU,MAAMzI,KAAK6B,ImCn5B/B0L,KAAI,SAACmU,GACJ,MAAmB,iBAARA,EACF,IAAIA,EAAG,SAEJtV,IAARsV,EACK,YAEG,OAARA,EACK,OAEU,kBAARA,EACFA,EAAI5f,WAETiG,MAAMC,QAAQ0Z,GACT,UAEU,iBAARA,EACF,UAEU,mBAARA,EACF,gBAEF,WAAWA,EAAG,OAEtBhZ,KAAK,MA8ES,gBAAe/F,EAAIqI,OAGhBrI,QAIXkH,MAAK,SAAC9F,GACL,MAAO,CAAEA,SAAQoZ,KAAI/c,iBA+B/B,IAAM+c,EAAKxK,EAAIgP,QAAUnQ,KACzB+P,EAAc9B,GAAYmB,OAAOW,GACjC,IAAInhB,EAAOuS,EAAItB,UAAYsB,EAAIvS,MAAQgB,EAqBvC,MAlBkB,iBAAThB,GACiB,mBAAjBA,EAAKiD,SACoB,IAAhCjD,EAAKiD,QAAQ,iBAEbjD,EAAOA,EAAKsR,QAAQ,cAAkBtQ,EAAG,OAGvCqe,GAAYE,cAAc4B,IAC5BL,GAAU/D,EAAIxK,EAAKvS,EAAMmhB,EAAane,GAGtCme,EAAYhB,cAAc1W,MAAK,SAAC5H,GAC9Bif,GAAU/D,EAAIxK,EAAKvS,EAAM6B,EAAKmB,OAGhC8d,GAAU/D,EAAIxK,EAAKvS,EAAMmhB,EAAane,GAGjCyW,GxB/LiB,wBwB+LuC,CAAEsD,KAAI/c,SC9LhE,SAASwhB,GACdL,EACAne,EACAwF,EAAM8P,GAEE,IAAAmJ,EADNvF,EAAE5D,EAAF4D,GAAItD,EAAIN,EAAJM,KAEN,OrBmBK,SAA8BpQ,EAASkZ,QAAyB,IAAzBA,MAA4BzH,IAyBtE,IAAMtW,EAASoE,KAAKC,UAAUQ,GAvB9B,SAAkBxH,GACd,IAAMuR,EAAMlT,KAAK2B,GAEjB,GAAIsY,GAAiBja,MACjB,OAAOkT,EAGX,IAAMmH,EAAOF,GAAcjH,GAE3B,IAAKmH,EACD,OAAOnH,EAIX,IAAMoP,EAAaD,EAAYhI,IAASE,GAAWF,GAEnD,OAAKiI,EAIEA,EAAWpP,EAAKvR,GAHZuR,KAQf,YAAsB,IAAX5O,EDxEC,YC4ELA,EqBlDF8c,CAAUjY,IAAGiZ,EAAA,IACL,QAAG,SAAClP,EAAevR,GAAW,OCfxC,SACLmgB,EACAne,EACAuP,EACAvR,EAAWsX,GAGX,OAAOmB,G1BDJ,6B0BCiE,CAClEhQ,KAAMyX,GACJC,EACAne,GACA,SAACgH,EAASe,GAAM,OAAKwH,EAAI9I,KAAKO,EAASe,KACvC/J,EACA,CAAEkb,GARF5D,EAAF4D,GAQQtD,KARAN,EAAJM,SDWFgJ,CAAiBT,EAAane,EAAQuP,EAAKvR,EAAK,CAAEkb,KAAItD,UAAO6I,EACjD,SAAG,SAAClP,EAAevR,GAAW,OAC1CkgB,GAAkBC,EAAane,EAAQuP,EAAKvR,EAAK,CAAEkb,KAAItD,UAAO6I,EACpD,OAAG,SAAClP,GACd,OAAOhK,EAASgK,IAAQ8M,GAAYE,cAAchN,GFiW/CkH,GvB7We,sBuB+WpB4F,GAAYoB,UElW+BlO,EFkWhB,CAAEqG,KElWqBA,KAC5CrG,GACLkP,IAIE,SAASI,GACd9H,EACArS,EACAvC,EAAeiV,GAEZ,IAAA0H,EADDlJ,EAAIwB,EAAJxB,KAEF,ORDK,SAA8CnH,EAAcsQ,GAC/D,QAD4F,IAA7BA,MAAgCzH,Id5CnF,cc6CR7I,EAmCJ,OAAO1J,KAAKia,MAAMvQ,GA9BlB,SAAkBzQ,EAAKuR,GACnB,GAAI+G,GAAiBja,MACjB,OAAOkT,EAGX,IAAImH,EACAhZ,EAUJ,GARI4Y,GAAiB/G,IACjBmH,EAAOnH,EAAIgH,SACX7Y,EAAQ6R,EAAIoH,UAEZD,EAAOF,GAAcjH,GACrB7R,EAAQ6R,IAGPmH,EACD,OAAOhZ,EAIX,IAAMuhB,EAAeF,EAAcrI,IAASQ,GAAaR,GAEzD,OAAKuI,EAIEA,EAAavhB,EAAOM,GAHhBN,KQ7BVigB,CAAYxb,IAAO2c,EAAA,IACsB,2BAAG,SAACI,GAAiB,OChBhE,SACLnI,EACArS,EAAc0S,GAGd,OAAO,IAAIjQ,EAFLiQ,EAAJ3Q,MDcE0Y,CAAmBpI,EAAQrS,EAAQwa,IAAkBJ,EACd,sBAAG,SAACM,GAAkB,ODqK5D,SACLrI,EACArS,EAAciR,EAAAG,GAGuC,IAFnDiE,EAAEpE,EAAFoE,GAAI/c,EAAI2Y,EAAJ3Y,KACJ4Y,EAAIE,EAAJF,KAEIyJ,EAA0B,SAAChE,GAC/B,SAASiE,IAAwD,IAAA/N,EAAA9D,UAO/D,OAAO4O,GAAYqB,cAAc3G,EAAQ,CAAEnB,SACxCuH,cACA1W,MAAK,SAAC5H,GACL,IAAMuf,EAAOH,GAAapf,EAAKkb,GAE/B,GAAIqE,GAAQA,EAAK7O,MAAQ+P,EACvB,OAAOlB,EAAK7O,IAAI5E,MACd,CAAEoM,OAAQjY,OAAQ4F,OAAQ3E,KAC1B0N,GAIF,IAAM/C,EAAO/F,GAAgBU,MAAMzI,KAAK6Q,GAExC,OAAI4N,EAAK/C,cACA1C,EACL/W,ExBnPL,mBwBqPK,CAAEkb,KAAI/c,OAAM0N,QACZ,CAAE1K,OAAQ0E,EAAQ4T,eAAe,IAG5B1C,EACL/W,ExB1PL,mBwB4PK,CAAEkb,KAAI/c,OAAM0N,QACZ,CAAE1K,OAAQ0E,EAAQ4T,eAAe,IACjC7R,MAAK,SAACqB,GAAG,OAAKA,EAAIiO,KAAKpV,aAI9BoI,OAAM,SAACxJ,GASN,MAAMA,KAWZ,YA3D4C,IAAb8b,MAAgB,IAoD/CiE,EAA2BrR,SAAWjR,EACtCsiB,EAA2BC,WAAa7a,EACxC4a,EAA2BE,WAAazI,EACxCuI,EAA2Bf,OAASxE,EAEpCuF,EAA2B5a,OAASA,EAE7B4a,GAGHA,EAA6BD,IAKnC,OAJAC,EAA2BhH,cAAgB+G,EAAwB,CACjE/G,eAAe,IAGVgH,EC7OHG,CAAoB1I,EAAQrS,EAAQ0a,EAAoB,CAAExJ,UAAOkJ,EAC5B,oBAAG,SAACxC,GAAgB,OF2VtDD,GAAYsB,YE1VmBrB,EF0VF,CAAE1G,KE1VoBA,KAAOkJ,IEpC5D,IAAMY,GAA0C,GCPhD,SAASvH,GACdtZ,EACAmB,EACAmC,EAAgBiV,GAEI,IADlB8B,EAAE9B,EAAF8B,GAAItD,EAAIwB,EAAJxB,KAEN,OAAOzO,EAAagC,KAAI,WACtB,IAEMwW,EAFgB1K,KAEazI,SAAS3N,GAAK,iBAAO,MA4CxD,OA1CA8gB,EAAaC,OAASD,EAAaC,QAAU,GAC7CD,EAAaC,OAAOhf,KAAKuB,GAEzBwd,EAAa9U,MACX8U,EAAa9U,OACb1D,EAAa0D,QAAQpE,MAAK,WACxB,GAAIzE,EAAenD,GACjB,MAAM,IAAIe,MAAM,oBAGlB,IA3BiE0V,EA2B3DuK,EAAoBrB,GACxB3f,EACAmB,IA5BRsV,EAAA,IACiB,uBA4BIqK,EAAaC,QAAU,GA5BhBtK,GA6BpB,CAAE4D,KAAItD,gBAED+J,EAAaC,OAGF,IADlB,IAAME,EAAa3iB,OAAOoO,KAAKmU,IACzBK,EAAS,GAAGnH,EAAA,EAAAA,EAESkH,EAAU7e,OAAA2X,IAAE,CAAlC,IAAMoH,EAAgBF,EAAUlH,GACnC,IACE8G,GAAwBM,GACtBnhB,EACAghB,EACA7f,GAEF,MAAOT,GACPwgB,EAAOnf,KAAKrB,IAIhB,GAAIwgB,EAAO9e,SAAW6e,EAAW7e,OAC/B,MAAM,IAAIrB,MAAM,kDACoCmgB,EAC/C5V,KAAI,SAAC5K,EAAK9C,GAAC,OAAQA,EAAC,KAAKkV,GAAepS,MACxC+F,KAAK,YAKTqa,EAAa9U,MAAMpE,MAAK,kBACtBkZ,EAAa9U,YAErBpE,KAAKiL,ICxBH,SAASuO,GAAoBjW,GAElC,OAD0BuK,GAAY,qBACbjX,IAAI0M,GAGxB,SAASkW,GAAuBlW,GACXuK,GAAY,qBACpBK,IAAI5K,GAmBjB,SAASmW,GAA0BnW,GAExC,OADiCuK,GAAY,4BACbhI,IAAIvC,GAG/B,SAASoW,GAAkB9K,GAQR,IAPxBtY,EAAIsY,EAAJtY,KACA6B,EAAGyW,EAAHzW,IACAmB,EAAMsV,EAANtV,OAMMqgB,EAAmBpL,GAAY,oBAUrC,G7B5EsB,M6BoElBpW,IACFA,EAAM,M7BrEc,M6BwElBmB,IACFA,EAAS,OAGNhD,EACH,MAAM,IAAI4C,MAAM,yCACjB,QAAA0gB,EAAA,EAAA7H,EAE0B,CAAC5Z,EAAKiW,MAAcwL,EAAA7H,EAAAxX,OAAAqf,IAAE,CAA5C,IAAMC,EAAY9H,EAAA6H,GACrB,GAAKC,EAAL,CAIA,IAAMC,EAAgBH,EAAiB/iB,IAAIijB,GAE3C,GAAKC,EAAL,CAIA,IAAMC,EAAkBD,EAAcxjB,GAEtC,GAAKyjB,EAAL,CAIA,GAAIzgB,GAA4B,iBAAXA,EAAqB,CACxC,GAAIygB,EAAgBzgB,GAClB,OAAOygB,EAAgBzgB,GAGzB,GAAIygB,EAAgC,iBAAG,QAAAC,EAAA,EAAAC,EACHF,EAAgC,iBAACC,EAAAC,EAAA1f,OAAAyf,IAAE,CAAhE,IAAAE,EAAAD,EAAAD,GAAeG,EAAQD,EAARC,SAClB,GAAIrc,EADYoc,EAALE,MACY9gB,GACrB,OAAO6gB,GAMf,GAAIJ,E7B/GgB,K6BgHlB,OAAOA,E7BhHW,S8B6BjB,SAAStH,GACd4H,EAAmB3J,GAEnB,IADE8B,EAAE9B,EAAF8B,GAAItD,EAAIwB,EAAJxB,KAEAoL,EAAmBzM,GAAY,oBAErC,IACE,IAAKzV,QAAUA,OAAOoD,SAAW6e,EAAMhK,OACrC,OAEF,MAAOxX,GACP,OAGF,IAAMwX,EAAyBgK,EAAzBhK,OAAQrS,EAAiBqc,EAAjBrc,OAWRuc,EAxDR,SACE9e,EACA4U,EACArS,EAAc4Q,GAEY,IACtB4L,EAFFhI,EAAE5D,EAAF4D,GAAItD,EAAIN,EAAJM,KAIN,IACEsL,EAAgBrC,GAAmB9H,EAAQrS,EAAQvC,EAAS,CAAE+W,KAAItD,SAClE,MAAOrW,GACP,OAGF,GAAK2hB,GAIwB,iBAAlBA,GAAgD,OAAlBA,EAAzC,CAIA,IAAMC,EAAgBD,EAA4B,uBAElD,GAAKvc,MAAMC,QAAQuc,GAInB,OAAOA,GA4BUC,CAXcL,EAAThL,KAWqBgB,EAAQrS,EAAQ,CAAEwU,KAAItD,SAEjE,GAAKqL,EAAL,CAIA5K,GAAgBU,GA8Bf,IA9BuB,IA8BvBsK,EA9BuBnX,EAAA,WAEnB,IAAM/H,EAAW8e,EAAQrI,GAC5B,GAAIoI,EAAiBzU,IAAIpK,EAAQ4X,IAAK,OAAAuH,OAAA,GAMtC,GAFAN,EAAiBjV,IAAI5J,EAAQ4X,IAAI,GAE7B/X,EAAe+U,KAAY5U,EAAQmW,cAAe,OAAAgJ,OAAA,GAIR,IAA1Cnf,EAAQuC,OAAOzE,QnDjGd,WmDkGHyE,EAAY7E,WAGd,I9BtGQ,8B8BuGFsC,EAAQuU,KC/EX,SACLK,EACArS,EACAvC,EAAuBmT,GAEH,IADlB4D,EAAE5D,EAAF4D,GAAItD,EAAIN,EAAJM,KAEAvF,EAAU+P,GAAmB,CACjCpjB,KAAMmF,EAAQnF,KACd6B,IAAKkY,EACL/W,OAAQ0E,IAGJ6c,E/BzBG,qB+B0BPpf,EAAQnF,MACRmF,EAAQ4T,MACqB,iBAAtB5T,EAAQ4T,KAAK/Y,KACbmF,EAAQ4T,KAAK/Y,KAAI,KACpBmF,EAAQnF,KAoCd,SAASwkB,EACPC,EACA1L,EACAtO,GAEA,OAAON,EAAa0D,QAAQpE,MAAK,WAC/B,IAAItE,EAAQmW,gBAAiBtW,EAAe+U,GAY5C,IACE,OAAOoB,GACLpB,EACArS,EACA,CACEqV,GAAI3L,KACJ1J,OAAQ3E,EAAUjB,QAClB4X,K/BrGC,6B+BsGD1M,KAAM7H,EAAQ6H,KACdhN,KAAMmF,EAAQnF,KACdykB,MACA1L,OACAtO,SAEF,CAAEyR,KAAItD,SAER,MAAOrW,GACP,MAAM,IAAIK,MAAM,oCACsB2hB,EAAO,OAAOxhB,IAAW,OAAO4R,GAClEpS,QAOH4H,EAAawC,IAAI,CAxEfxC,EAAa0D,QAAQpE,MAAK,WAC/B,IAAItE,EAAQmW,gBAAiBtW,EAAe+U,GAI5C,IACE,OAAOoB,GACLpB,EACArS,EACA,CACEqV,GAAI3L,KACJ1J,OAAQ3E,EAAUjB,QAClB4X,K/B3DJ,wB+B4DI1M,KAAM7H,EAAQ6H,KACdhN,KAAMmF,EAAQnF,MAEhB,CAAEkc,KAAItD,SAER,MAAOrW,GACP,MAAM,IAAIK,MAAM,+BACiB2hB,EAAO,OAAOxhB,IAAW,OAAO4R,GAC7DpS,QAsDR4H,EAAagC,KAAI,WACf,IAAKkH,EACH,MAAM,IAAIzQ,MAAM,sCACwBuC,EAAQnF,KAAI,SAAS0H,EAAM,OAAO5F,OAAOC,SAASC,SAAQ,KAAKF,OAAOC,SAASe,KAAOhB,OAAOC,SAAS2iB,UAMhJ,OAAOrR,EAAQjJ,QAAQ,CAAE2P,SAAQrS,SAAQqR,KAF5B5T,EAAQ4T,UAGpBtP,MACD,SAACsP,GACC,OAAOyL,E/BlIH,U+BkIqCzL,MAE3C,SAACtO,GACC,OAAO+Z,E/BpIL,Q+BoIqC,KAAM/Z,QAIhDhB,KAAKiL,IACL3I,OAAM,SAACxJ,GACN,GAAI8Q,GAAWA,EAAQsR,YACrB,OAAOtR,EAAQsR,YAAYpiB,GAE3B,MAAMA,KD5CNqiB,CAAc7K,EAAQrS,EAAQvC,EAAS,CAAE+W,KAAItD,S9BvGxC,+B8BwGIzT,EAAQuU,KCkFlB,SACLK,EACArS,EACAvC,GAEA,IAAIge,GAA0Bhe,EAAQ6H,MAAtC,CAIA,InD0tBqCvF,EmD1tB/B4L,EAAU4P,GAAoB9d,EAAQ6H,MAE5C,IAAKqG,EACH,MAAM,IAAIzQ,MAAM,2DAC6CuC,EAAQnF,KAAI,SAAS0H,EAAM,OAAO5F,OAAOC,SAASC,SAAQ,KAAKF,OAAOC,SAASe,KAAOhB,OAAOC,SAAS2iB,UAIrK,IAAKld,EAAY6L,EAAQrQ,OAAQ0E,GAC/B,MAAM,IAAI9E,MAAM,mBACK8E,EAAM,2BnDgtBQD,EmD/sB/B4L,EAAQrQ,OnDgtBV2E,MAAMC,QAAQH,GACT,IAAIA,EAAQa,KAAK,OAAM,IACrB9G,EAAQiG,GACV,UAAUA,EAAQ/F,WAAU,IAE5B+F,EAAQ/F,amDhtBjB,GAAIqY,IAAW1G,EAAQxR,IACrB,MAAM,IAAIe,MAAM,oDAGlBsgB,GAAuB/d,EAAQ6H,M/BjNvB,U+B0NJ7H,EAAQsf,IAKVpR,EAAQtJ,QAAQgB,OAAO5F,EAAQsF,O/BhOvB,Y+BiOCtF,EAAQsf,KAKjBpR,EAAQtJ,QAAQC,QAAQ,CAAE+P,SAAQrS,SAAQqR,KAAM5T,EAAQ4T,QDlIpD8L,CAAe9K,EAAQrS,EAAQvC,G9BxG/B,0B8ByGSA,EAAQuU,MC8ClB,SACLK,EACArS,EACAvC,GAEA,IAAIge,GAA0Bhe,EAAQ6H,MAAtC,CAIA,IAAMqG,EAAU4P,GAAoB9d,EAAQ6H,MAE5C,IAAKqG,EACH,MAAM,IAAIzQ,MAAM,sDACwCuC,EAAQnF,KAAI,SAAS0H,EAAM,OAAO5F,OAAOC,SAASC,SAAQ,KAAKF,OAAOC,SAASe,KAAOhB,OAAOC,SAAS2iB,UAIhK,IACE,IAAKld,EAAY6L,EAAQrQ,OAAQ0E,GAC/B,MAAM,IAAI9E,MAAM,cACA8E,EAAM,0BAA0B2L,EAAQrQ,OAAOtB,YAIjE,GAAIqY,IAAW1G,EAAQxR,IACrB,MAAM,IAAIe,MAAM,+CAElB,MAAOL,GACP8Q,EAAQtJ,QAAQgB,OAAOxI,GAGzB8Q,EAAQoR,KAAM,GD5ERK,CAAU/K,EAAQrS,EAAQvC,GAE5B,MAAO5C,GACP6I,YAAW,WACT,MAAM7I,IACL,KAENqZ,EAAA,EAAAA,EA5BqBqI,EAAQhgB,OAAA2X,IAAA,GAAAyI,EAAAnX,IAAE,OAAFmX,EAAAC,GE7EzB,SAASpI,GACdlc,EACAqT,EACAjJ,GAEA,IAAKpK,EACH,MAAM,IAAI4C,MAAM,iBASlB,GALuB,mBADvByQ,EAAUA,GAZH,MAcLjJ,EAAUiJ,EACVA,EAfK,KAkBFjJ,EACH,MAAM,IAAIxH,MAAM,oBAGlB,IAUMmiB,EHwGD,SAASC,EAAkBrM,EAUhCkL,GAC0B,IATxB7jB,EAAI2Y,EAAJ3Y,KACKilB,EAAYtM,EAAjB9W,IACAmB,EAAM2V,EAAN3V,OAQIqgB,EAAmBpL,GAAY,oBAErC,IAAKjY,GAAwB,iBAATA,EAClB,MAAM,IAAI4C,MAAM,yCAGlB,GACEqiB,G7BzIoB,M6B0IpBA,GAEA5F,GAAYE,cAAc0F,GAC1B,CAEA,IAEMC,EAFwBD,EAEU9E,cAAc1W,MAAK,SAAC0b,GAC1D,OAAOH,EAAmB,CAAEhlB,OAAM6B,IAAKsjB,EAAWniB,UAAU6gB,MAG9D,MAAO,CACLtW,OAAQ,WACN2X,EAAuBzb,MACrB,SAACsb,GAAe,OAAKA,EAAgBxX,WACrCmH,MAOR,IAAI7S,EAA2CojB,EAE/C,GAAItd,MAAMC,QAAQ/F,GAAM,CACS,IAA/B,IAAMujB,EAAsB,GAAGC,EAAA,EAAAC,EAEZzjB,EAAGwjB,EAAAC,EAAArhB,OAAAohB,IACpBD,EAAoBxhB,KAClBohB,EAAmB,CAAEhlB,OAAMgD,SAAQnB,IAFxByjB,EAAAD,IAEqCxB,IAIpD,MAAO,CACLtW,OAAM,WAAG,QAAAgY,EAAA,EAAAA,EACsBH,EAAmBnhB,OAAAshB,IAAnBH,EAAmBG,GAC/BhY,WAMvB,GAAI5F,MAAMC,QAAQ5E,GAAS,CACM,IAA/B,IAAMoiB,EAAsB,GAAGI,EAAA,EAAAC,EAEZziB,EAAMwiB,EAAAC,EAAAxhB,OAAAuhB,IACvBJ,EAAoBxhB,KAClBohB,EAAmB,CAAEhlB,OAAM6B,MAAKmB,OAFrByiB,EAAAD,IAEqC3B,IAIpD,MAAO,CACLtW,OAAM,WAAG,QAAAmY,EAAA,EAAAA,EACsBN,EAAmBnhB,OAAAyhB,IAAnBN,EAAmBM,GAC/BnY,WAMvB,IAAMoY,EAAmBvC,GAAmB,CAAEpjB,OAAM6B,MAAKmB,WAEpDnB,G7BxMiB,M6BwMVA,IACVA,EAAMiW,MAIR,IAAM8N,GADN5iB,EAASA,G7B5Ma,K6B6MGtB,WAEzB,GAAIikB,EACF,MAAI9jB,GAAOmB,EACH,IAAIJ,MAAM,uCACyB5C,EAAI,cAAcgD,EAAOtB,WAAU,SACxEG,IAAQiW,KAAgB,WAAa,aAAW,WAG3CjW,EACH,IAAIe,MAAM,uCACyB5C,EAAI,SACzC6B,IAAQiW,KAAgB,WAAa,aAAW,WAG3C9U,EACH,IAAIJ,MAAM,uCACyB5C,EAAI,cAAcgD,EAAOtB,YAG5D,IAAIkB,MAAM,uCAAuC5C,GAI3D,IAGI6lB,EACAC,EAJEC,EAAmB1C,EAAiB7T,SAAS3N,GAAK,iBAAO,MACzDmkB,EAAyBxW,GAASuW,EAAkB/lB,GAAM,iBAAO,MAiBvE,OAZIwB,GAAQwB,IACV6iB,EAA8BrW,GAC5BwW,EA/OmB,oBAiPnB,iBAAM,OAGoBpiB,KAD5BkiB,EAA6B,CAAEhC,MAAO9gB,EAAQ6gB,aAG9CmC,EAAuBJ,GAAa/B,EAG/B,CACLtW,OAAM,kBACGyY,EAAuBJ,GAE1BE,IACFD,EAA4BrY,OAC1BqY,EAA4B5iB,QAAQ6iB,EAA4B,IAG7DD,EAA4B5hB,eACxB+hB,EAAuC,kBAI7C7lB,OAAOoO,KAAKyX,GAAwB/hB,eAChC8hB,EAAiB/lB,GAGtB6B,IAAQ1B,OAAOoO,KAAKwX,GAAkB9hB,QACxCof,EAAiBzL,IAAI/V,KG5PHmjB,CACtB,CAAEhlB,OAAM6B,IAXYwR,EAAQvR,OAWAkB,OAVfqQ,EAAQrQ,QhCLD,KgCgBpB,CACEoH,QAVmBA,GAAWiJ,EAAQjJ,QAWtCua,YATFtR,EAAQ4S,cACP,SAAC1jB,GACA,MAAMA,KAWV,MAAO,CACLgL,OAAM,WACJwX,EAAgBxX,WASf,SAAS2Y,GACdlmB,EACAqT,EACAjJ,GAGuB,mBADvBiJ,EAAUA,GAxDH,MA0DLjJ,EAAUiJ,EACVA,EA3DK,IA8DP,IACIwQ,EADE9Z,EAAU,IAAII,EAoBpB,OAjBAkJ,EAAQ4S,aAAe,SAAC1jB,GACtBshB,EAAStW,SACTxD,EAAQgB,OAAOxI,IAGjBshB,EAAW3H,GAAGlc,EAAMqT,GAAS,SAAC0Q,GAG5B,GAFAF,EAAStW,SACTxD,EAAQC,QAAQ+Z,GACZ3Z,EACF,OAAOA,EAAQ2Z,MAKnBha,EAAQwD,OAASsW,EAAStW,OAGnBxD,EL7DT2Y,GAAkD,uBAAI,SACpD7gB,EACAghB,EACA7f,GAEsC,IAAlCA,EAAOC,QhDhCJ,WgDiCLD,E3BToB,K2ByCtBnB,EAAIskB,YAAYtD,EAAmB7f,IAInC0f,GAA4C,iBAAI,SAC9C7gB,EACAghB,EACA7f,GAEA,IAAKuX,OAA4BM,KAC/B,MAAM,IAAIjY,MAAM,iCAGlB,GAAIM,EAAarB,GACf,MAAM,IAAIe,MAAM,oEAKlB,IAAqC,IAAjCmE,EAAgBjF,OAAQD,GAC1B,MAAM,IAAIe,MAAM,yFT0Ef,SACLf,EACAmB,EACAmC,GAEA,IAAMihB,EAAiB7f,EAASzE,OAAQD,GAClCwkB,EAAkB9f,EAAS1E,EAAKC,QAEtC,IAAKskB,IAAmBC,EACtB,MAAM,IAAIzjB,MAAM,+DAKXoY,GAAiBnZ,GAAK4H,MAAK,SAAC0R,GACjC,OAAOA,EAAYtZ,EAAKmB,EAAQmC,MSpFhCmhB,CAAkBzkB,EAAKmB,EAAQ6f,IAQjCH,GAA4C,iBAAI,SAC9C7gB,EACAghB,GAEA,IMrGE9c,EAAajE,QAAQgG,MAAM,yCNsG3B,MAAM,IAAIlF,MAAM,2CAGlB,IAAKM,EAAarB,GAChB,MAAM,IAAIe,MAAM,yEAKlB,IAAqC,IAAjCmE,EAAgBjF,OAAQD,GAC1B,MAAM,IAAIe,MAAM,wFAMlB,IAAM2jB,EAAgB7P,GAAU7U,GAEhC,IAAK0kB,EACH,MAAM,IAAI3jB,MAAM,mDAGlB2jB,EAAcpK,eAAe,CAC3BpC,OAAQjY,OACR4F,OAAQ3E,IACRgW,KAAM8J,KO/BL,IAAMjK,GAAiB,SAAjBA,EAAkB4N,EAAexmB,EAAM+Y,EAAM1F,GAExD,IAAMoT,GADNpT,EAAUA,GAAW,IACSrQ,QlC3ER,IkC4EhB0jB,EAAkBrT,EAAQjH,UCjGmB,EDkG7Cua,EAAetT,EAAQjH,SCtGK,IDuG5BkP,EAAgBjI,EAAQiI,gBAAiB,EAE/C,OAAO+D,GAAYqB,cAAc8F,EAAe,CAAE5N,SAC/CuH,cACA1W,MAAK,SAAC5H,GAEL,OAAOsI,EAAagC,KAAI,WAGtB,GAvER,SACEnM,EACA6B,EACAmB,GAEA,IAAKhD,EACH,MAAM,IAAI4C,MAAM,iBAGlB,GAAII,GAEkB,iBAAXA,IACN2E,MAAMC,QAAQ5E,KACdxB,GAAQwB,GAET,MAAM,IAAIyJ,UAAU,gBACFzM,EAAI,qBAAqB+H,KAAKC,UAC5ChF,GACD,oCAKP,GAAIgC,EAAenD,GACjB,MAAM,IAAIe,MAAM,gBAAgB5C,EAAI,6BA6ChC4mB,CAAgB5mB,EAAM6B,EAAK4kB,GtD2nB5B,SACLnkB,EACAmB,GAEA,IAAMojB,EAAergB,EAAY/C,GAEjC,GAAIojB,EACF,OAAIA,IAAiBvkB,EAOvB,GAAImB,IAAUnB,EACZ,OAAO,EAGT,GAAIkC,EAAOf,KAAWA,EACpB,OAAO,EACR,QAAAqjB,EAAA,EAAAC,EAEmBjjB,EAAUxB,GAAOwkB,EAAAC,EAAA9iB,OAAA6iB,IACnC,GADcC,EAAAD,KACArjB,EACZ,OAAO,EAIX,OAAO,EsDrpBGujB,CAAWllB,OAAQD,GACrB,OAAOsX,GAAiBtX,EAAK8kB,MAG9Bld,MAAK,SAAAwd,GACJ,OAhDV,SACEplB,EACAqlB,EACAC,EAAqB7O,GAEC,IADpBM,EAAIN,EAAJM,KAEF,OAAOzO,EAAagC,KAAI,WACtB,MAA4B,iBAAjB+a,EACFA,EAGF/c,EAAagC,KAAI,WACtB,OACEgb,GAAgBzO,GAAS7W,EAAK,CAAE+W,SAAQnP,MAAK,SAAA2Q,GAAS,OAAAA,EAANpX,aAEjDyG,MAAK,SAAC2d,GACP,IAAK5f,EAAY0f,EAAcA,GAC7B,MAAM,IAAItkB,MAAM,UACJoF,GAAUkf,GAAa,mBAAmBlf,GAClDkf,IAKN,OAAOE,QAwBIC,CAAgBxlB,EAAK4kB,QADW,IAAAQ,EAAP,GAAEA,GAA3BjkB,OACkD,CAAE4V,YAE5DnP,MAAK,SAACyd,GACL,I7CgjBR7Z,EAGIjB,E6CnjBUpJ,EAASkkB,EAET3C,ElC/GL,qBkCgHCvkB,GACA+Y,GACqB,iBAAdA,EAAK/Y,KACL+Y,EAAK/Y,KAAI,KACZA,EAMA+J,EAAU,IAAII,EACd6C,EAAUhN,EAAI,IAAIoR,KAExB,IAAKkK,EAAe,CAClB,IAAMgM,EAAyC,CAC7CtnB,OACA6B,MACAmB,SACA+G,YLlGP,SACLiD,EACA6W,GAE0BtM,GAAY,qBACpBxI,IAAI/B,EAAM6W,GK+FlB0D,CAAoBva,EAAMsa,GAE1B,IAAME,EAAcvP,GAAY,mBAAmBzI,SACjD3N,GACA,iBAAM,MAER2lB,EAAY5jB,KAAKmG,GAEjBA,EAAQgC,OAAM,YL/EnB,SAAqCiB,GACTuK,GAAY,4BACpBxI,IAAI/B,GAAM,GK8EvBya,CAA4Bza,GAC5BkW,GAAuBlW,MAGzB,IAAM0a,EjCpJX,SAAuB7lB,GAE5B,OADqBoW,GAAY,gBACb3X,IAAIuB,GAAK,GiCkJK8lB,CAAc9lB,GCzJjB,IADN,ID6JT+lB,EAAkBlB,EAEpBmB,EAAaH,EACbI,EAAaF,EAEXnS,G7CogBhBpI,E6CpgBwC,WAC5B,OAAIrI,EAAenD,GACVkI,EAAQgB,OACb,IAAInI,MAAM,qBACa5C,EAAI,YACvBsnB,EAAiB7C,IAAM,WAAa,SAMxC6C,EAAiBS,UACZhe,EAAQgB,OACb,IAAInI,MAAM,uCAAuC5C,KAIrD6nB,EAAapZ,KAAKuZ,IAAIH,EChLD,IDgLmC,IACpC,IAAhBC,IACFA,EAAarZ,KAAKuZ,IAAIF,EClLH,IDkLqC,IAGrDR,EAAiB7C,KAAsB,IAAfoD,EAMH,IAAfC,EACF/d,EAAQgB,OACb,IAAInI,MAAM,+BACuB2hB,EAAO,OAAOxhB,IAAW,OAAO6kB,EAAe,YAH7E,EALE7d,EAAQgB,OACb,IAAInI,MAAM,0BACkB2hB,EAAO,OAAOxhB,IAAW,OAAO2kB,EAAe,SCxL1D,I9CwqBjC,SAASO,IACP7b,EAAUhB,YAAW,WACnBiC,IACA4a,M8C3qB6B,K9C+qBjCA,GAEO,CACL1a,OAAM,WACJhB,aAAaH,M6C/ePrC,EACGkC,SAAQ,WACPwJ,EAASlI,SACTia,EAAYha,OAAOga,EAAYvkB,QAAQ8G,EAAS,OAEjDgC,MAAM2I,IAGX,OAAOyG,GACLtZ,EACAmB,EACA,CACE+Z,GAAI3L,KACJ1J,OAAQ3E,EAAUjB,QAClB4X,KlCvNF,4BkCwNE1M,OACAhN,OACA+Y,OACAuC,iBAEF,CAAEY,MAAItD,SACNnP,MACA,WACE,OAAO6R,EAAgBvR,EAAQC,UAAYD,KAE7C,SAACxH,GACC,MAAM,IAAIK,MAAM,mCACqB2hB,EAAO,OAAOxhB,IAAW,OAAO4R,GACjEpS,cEhNX,SAASif,GACdL,EACAne,EACAwF,GAEA,OAAO0f,GAAyB/G,EAAane,EAAQwF,EAAK,CAAE0T,MAAItD,UAG3D,SAASiJ,GACd9H,EACArS,EACAvC,GAEA,OAAOgjB,GAA2BpO,EAAQrS,EAAQvC,EAAS,CAAE+W,MAAItD,UAG5D,SAASwP,GAAkBvmB,GAChC,OAAO,IAAIwd,GAAY,CAAEzG,QAAM/W,QAG1B,SAAS6e,GACd7e,GAEA,OAAOwd,GAAYqB,cAAc7e,EAAK,CAAE+W,UAGnC,SAASyP,KNuET,IAAkC5M,EACvCS,EACAtD,EAKMb,EM7EDrB,KAAY4R,cACf5R,KAAY4R,aAAc,ENsE5BpM,GADuCT,EMnEX,CAAES,MAAItD,UNoElCsD,GACAtD,EAAI6C,EAAJ7C,MAKMb,EAASrB,MACRyF,eACLpE,EAAOoE,gBACN,SAAChX,GAAO,OAAKgX,GAAehX,EAAS,CAAE+W,KAAItD,UAoDzC,SAA0BE,GAMb,IALlBoD,EAAEpD,EAAFoD,GACAtD,EAAIE,EAAJF,KAKOrB,KAAc/H,SAAS,uBAAuB,WACnD,OlConBFhH,EkCpnB0B1G,QlCwnBtBymB,iBkCxnB8B,UlCsnBlCne,EkCtnB6C,SAAC2Z,IAjDzC,SACLA,EAAoBpL,GAEpB,IADEuD,EAAEvD,EAAFuD,GAAItD,EAAID,EAAJC,KAENzO,EAAagC,KAAI,WAOf,IAAM4N,EAASgK,EAAMhK,QAAUgK,EAAMyE,cACjC9gB,EACFqc,EAAMrc,QAAWqc,EAAM0E,eAAiB1E,EAAM0E,cAAc/gB,OACxDqR,EAAOgL,EAAMhL,KAMnB,GAJe,SAAXrR,IACFA,EAAY7E,WAGTkX,EAAL,CAIA,IAAKrS,EACH,MAAM,IAAI9E,MAAM,2CAYlBuZ,GAAe,CAAEpC,SAAQrS,SAAQqR,QAAQ,CAAEmD,KAAItD,aAc7C8P,CAAgB3E,EAAO,CAAE7H,KAAItD,WlCunB1B,CACLrL,OAAM,WACJ/E,EAAImgB,oBkC3nB0B,UlC2nBCve,KAR9B,IACL5B,EAEA4B,KwC9vBEwe,CAAkB,CAAE1M,MAAItD,UAGtBoD,GAAY,CAAEE,MAAItD,QAAMuD,oBrCevB,SAAkByE,GAML,IALlB1E,EAAE0E,EAAF1E,GACAtD,EAAIgI,EAAJhI,KAKOrB,GAAY,oBAAoB/H,SAAS,iBAAiB,WAC/D,IAAMqU,EAA4B3H,EClE5B,kBDwBsB,CAAElZ,OCXV,MDW8B,SAAAyY,GAElD,OADApD,GAD2DoD,EAAN1B,OACzB,CAAE/W,OADqCyY,EAAN/T,SAEtD,CAAEmR,WAAYT,SA0Cf9V,EAASkE,IAUf,OATIlE,GACFoW,GAASpW,EAAQ,CAAEsW,SAAQ7M,OAAM,SAACxJ,OAQ7BshB,KqChCPgF,CAAU,CAAE3M,MAAItD,WAIb,SAASkQ,KNqIT,IACCjF,GDvID,WACsD,IAA3D,IAAMkF,EAAoBxR,GAAY,qBAAqBqE,EAAA,EAAAoN,EACxCD,EAAkBxa,OAAMqN,EAAAoN,EAAA/kB,OAAA2X,IAAE,CAAxC,IAAM5O,EAAIgc,EAAApN,GACPiI,EAAWkF,EAAkBzoB,IAAI0M,GACnC6W,IACFA,EAASkE,WAAY,GAEvBgB,EAAkBnR,IAAI5K,IOLxBic,INqIMpF,EAAWtM,KAAcjX,IAAI,yBAEjCujB,EAAStW,gBjC5KJzL,OAAgB,uBwClBlB,ICuBI0a,GDvBE0M,IAAQ,EEDd,SAASC,GAActnB,GAC2B,IAAvD,IAAuD+Z,EAAA,EAAAwN,EAA/BnR,GAAY,mBACE3X,IAAIuB,EAAK,IAAG+Z,EAAAwN,EAAAnlB,OAAA2X,IAAhCwN,EAAAxN,GAEb7Q,OACC,IAAInI,MAAM,WAENoC,EAAenD,GAAO,SAAW,cAAY,qBAIlDkK,MAAM2I,IDgBX8H,GAAS,CACPR,eACAqN,WnB0HG,SACLjhB,EACApF,GAEA,IAAMsmB,EAAU/R,GAAY,WACtBgS,EAAehS,GAAY,gBAIjC,OAFAvU,EAASA,GAAUmF,EAAiBC,GAE7BkhB,EAAQ9Z,SAASxM,GAAQ,kBAC9BmH,EAAagC,KAAI,WACf,GAAIpJ,MAAgBC,EAClB,MAAM,IAAIJ,MAAM,6DAC+CI,GAIjE,IAAMhD,EAAO2a,GAAc3X,GAG3B,GAFcmD,EAAerE,OAAQ9B,GAGnC,MAAM,IAAI4C,MAAM,mBAAmB5C,EAAI,2BAGzC,IAAMwpB,EAtDZ,SAAyBxpB,EAAcoI,GACrC,IAAMohB,EAASzgB,SAAS2V,cAAc,UAqBtC,OAnBA8K,EAAOnS,aAAa,OAAQrX,GAC5BwpB,EAAOnS,aAAa,KAAMrX,GAE1BwpB,EAAOnS,aAAa,QAAD,6EAInBmS,EAAOnS,aAAa,cAAD,KACnBmS,EAAOnS,aAAa,SAAD,KACnBmS,EAAOnS,aAAa,YAAD,MACnBmS,EAAOnS,aAAa,oBAAD,QAEnBmS,EAAOnS,aAAa,WAAD,MACnBmS,EAAOnS,aAAa,SAAD,QACnBmS,EAAOnS,aAAa,QAAD,IACnBmS,EAAOnS,aAAa,OAAD,gBAEnBmS,EAAOjT,IAAMnO,EAENohB,EAgCYC,CAAgBzpB,EAAMoI,GAGrC,OAFAmhB,EAAaxa,IAAI/L,EAAQwmB,GAElB1O,GAAkBrR,MAAK,SAAC4L,GAC7BA,EAAK2J,YAAYwK,GACjB,IAAMhN,EAASgN,EAAOhkB,cAEtB,OAAO,IAAI2E,GAAa,SAACH,EAASe,GAChCye,EAAOjB,iBAAiB,OAAQve,GAChCwf,EAAOjB,iBAAiB,QAASxd,MAEhCtB,MAAK,WACJ,OAAO0P,GAAiBqD,EgBnMN,IhBmM8B,UAAUpU,MAE3DqB,MAAK,WACJ,OAAO+S,emBhKfhB,cACAkO,QnBqNG,SAAiB7nB,EAA4BuG,GAClDoT,GAAW,CAAE3Z,MAAKmB,OAAQmF,EAAiBC,MmBrNzCyS,YACAH,eACAH,yBACAoP,UnB+GG,SAAmBvhB,EAAapF,GAErC,OADgBuU,GAAY,WACbhI,IAAIvM,GAAUmF,EAAiBC,KmBhH5CoS,qBACAC,wBACAmP,enB6OG,WAE4C,IADjD,IAAMN,EAAU/R,GAAY,WACtBgS,EAAehS,GAAY,gBAAgB+L,EAAA,EAAAuG,EAE5BN,EAAahb,OAAM+U,EAAAuG,EAAA5lB,OAAAqf,IAAE,CAArC,IACGpf,EAAQqlB,EAAajpB,IADZupB,EAAAvG,IAEXpf,GAASA,EAAMuB,YACjBvB,EAAMuB,WAAW2D,YAAYlF,GAGjCqlB,EAAanV,QACbkV,EAAQlV,UmBnPRiU","file":"post-robot.ie.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"postRobot\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"postRobot\"] = factory();\n\telse\n\t\troot[\"postRobot\"] = factory();\n})((typeof self !== 'undefined' ? self : this), function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","/* @flow */\n\nexport function isRegex(item: mixed): boolean {\n  // $FlowFixMe method-unbinding\n  return Object.prototype.toString.call(item) === \"[object RegExp]\";\n}\n\n// eslint-disable-next-line no-unused-vars\nexport function noop(...args: $ReadOnlyArray<mixed>) {\n  // pass\n}\n","/* @flow */\n\nexport const PROTOCOL = {\n  MOCK: (\"mock:\": \"mock:\"),\n  FILE: (\"file:\": \"file:\"),\n  ABOUT: (\"about:\": \"about:\"),\n};\n\nexport const WILDCARD = \"*\";\n\nexport const WINDOW_TYPE = {\n  IFRAME: (\"iframe\": \"iframe\"),\n  POPUP: (\"popup\": \"popup\"),\n};\n","/* @flow */\n/* eslint max-lines: 0 */\n\nimport { isRegex, noop } from \"./util\";\nimport type {\n  CrossDomainWindowType,\n  SameDomainWindowType,\n  DomainMatcher,\n} from \"./types\";\nimport { PROTOCOL, WILDCARD } from \"./constants\";\n\nconst IE_WIN_ACCESS_ERROR = \"Call was rejected by callee.\\r\\n\";\n\nexport function getActualProtocol(win: SameDomainWindowType = window): ?string {\n  return win.location.protocol;\n}\n\nexport function getProtocol(win: SameDomainWindowType = window): ?string {\n  if (win.mockDomain) {\n    const protocol = win.mockDomain.split(\"//\")[0];\n\n    if (protocol) {\n      return protocol;\n    }\n  }\n\n  return getActualProtocol(win);\n}\n\nexport function isFileProtocol(win: SameDomainWindowType = window): boolean {\n  return getProtocol(win) === PROTOCOL.FILE;\n}\n\nexport function isAboutProtocol(win: SameDomainWindowType = window): boolean {\n  return getProtocol(win) === PROTOCOL.ABOUT;\n}\n\nexport function isMockProtocol(win: SameDomainWindowType = window): boolean {\n  return getProtocol(win) === PROTOCOL.MOCK;\n}\n\nexport function getParent(\n  win?: CrossDomainWindowType = window\n): ?CrossDomainWindowType {\n  if (!win) {\n    return;\n  }\n\n  try {\n    if (win.parent && win.parent !== win) {\n      return win.parent;\n    }\n  } catch (err) {\n    // pass\n  }\n}\n\nexport function getOpener(\n  win?: CrossDomainWindowType = window\n): ?CrossDomainWindowType {\n  if (!win) {\n    return;\n  }\n\n  // Make sure we're not actually an iframe which has had window.open() called on us\n  if (getParent(win)) {\n    return;\n  }\n\n  try {\n    return win.opener;\n  } catch (err) {\n    // pass\n  }\n}\n\nexport function canReadFromWindow(\n  win: CrossDomainWindowType | SameDomainWindowType\n): boolean {\n  try {\n    // $FlowFixMe\n    noop(win && win.location && win.location.href);\n    return true;\n  } catch (err) {\n    // pass\n  }\n\n  return false;\n}\n\nexport function getActualDomain(win?: SameDomainWindowType = window): string {\n  const location = win.location;\n\n  if (!location) {\n    throw new Error(`Can not read window location`);\n  }\n\n  const protocol = getActualProtocol(win);\n\n  if (!protocol) {\n    throw new Error(`Can not read window protocol`);\n  }\n\n  if (protocol === PROTOCOL.FILE) {\n    return `${PROTOCOL.FILE}//`;\n  }\n\n  if (protocol === PROTOCOL.ABOUT) {\n    const parent = getParent(win);\n    if (parent && canReadFromWindow(parent)) {\n      // $FlowFixMe\n      return getActualDomain(parent);\n    }\n\n    return `${PROTOCOL.ABOUT}//`;\n  }\n\n  const host = location.host;\n\n  if (!host) {\n    throw new Error(`Can not read window host`);\n  }\n\n  return `${protocol}//${host}`;\n}\n\nexport function getDomain(win?: SameDomainWindowType = window): string {\n  const domain = getActualDomain(win);\n\n  if (domain && win.mockDomain && win.mockDomain.indexOf(PROTOCOL.MOCK) === 0) {\n    return win.mockDomain;\n  }\n\n  return domain;\n}\n\nexport function isBlankDomain(win: CrossDomainWindowType): boolean {\n  try {\n    // $FlowFixMe\n    if (!win.location.href) {\n      return true;\n    }\n\n    if (win.location.href === \"about:blank\") {\n      return true;\n    }\n  } catch (err) {\n    // pass\n  }\n\n  return false;\n}\n\nexport function isActuallySameDomain(win: CrossDomainWindowType): boolean {\n  try {\n    if (win === window) {\n      return true;\n    }\n  } catch (err) {\n    // pass\n  }\n\n  try {\n    const desc = Object.getOwnPropertyDescriptor(win, \"location\");\n\n    if (desc && desc.enumerable === false) {\n      return false;\n    }\n  } catch (err) {\n    // pass\n  }\n\n  try {\n    // $FlowFixMe\n    if (isAboutProtocol(win) && canReadFromWindow(win)) {\n      return true;\n    }\n  } catch (err) {\n    // pass\n  }\n\n  try {\n    // $FlowFixMe\n    if (isMockProtocol(win) && canReadFromWindow(win)) {\n      return true;\n    }\n  } catch (err) {\n    // pass\n  }\n\n  try {\n    // $FlowFixMe\n    if (getActualDomain(win) === getActualDomain(window)) {\n      return true;\n    }\n  } catch (err) {\n    // pass\n  }\n\n  return false;\n}\n\nexport function isSameDomain(\n  win: CrossDomainWindowType | SameDomainWindowType\n): boolean {\n  if (!isActuallySameDomain(win)) {\n    return false;\n  }\n\n  try {\n    if (win === window) {\n      return true;\n    }\n\n    // $FlowFixMe\n    if (isAboutProtocol(win) && canReadFromWindow(win)) {\n      return true;\n    }\n\n    // $FlowFixMe\n    if (getDomain(window) === getDomain(win)) {\n      return true;\n    }\n  } catch (err) {\n    // pass\n  }\n\n  return false;\n}\n\nexport function assertSameDomain(\n  win: CrossDomainWindowType | SameDomainWindowType\n): SameDomainWindowType {\n  if (!isSameDomain(win)) {\n    throw new Error(`Expected window to be same domain`);\n  }\n\n  // $FlowFixMe\n  return win;\n}\n\nexport function getParents(\n  win: CrossDomainWindowType\n): $ReadOnlyArray<CrossDomainWindowType> {\n  const result = [];\n\n  try {\n    while (win.parent !== win) {\n      result.push(win.parent);\n      win = win.parent;\n    }\n  } catch (err) {\n    // pass\n  }\n\n  return result;\n}\n\nexport function isAncestorParent(\n  parent: CrossDomainWindowType,\n  child: CrossDomainWindowType\n): boolean {\n  if (!parent || !child) {\n    return false;\n  }\n\n  const childParent = getParent(child);\n\n  if (childParent) {\n    return childParent === parent;\n  }\n\n  if (getParents(child).indexOf(parent) !== -1) {\n    return true;\n  }\n\n  return false;\n}\n\nexport function getFrames(\n  win: CrossDomainWindowType\n): $ReadOnlyArray<CrossDomainWindowType> {\n  const result = [];\n\n  let frames;\n\n  try {\n    frames = win.frames;\n  } catch (err) {\n    frames = win;\n  }\n\n  let len;\n\n  try {\n    len = frames.length;\n  } catch (err) {\n    // pass\n  }\n\n  if (len === 0) {\n    return result;\n  }\n\n  if (len) {\n    for (let i = 0; i < len; i++) {\n      let frame;\n\n      try {\n        frame = frames[i];\n      } catch (err) {\n        continue;\n      }\n\n      result.push(frame);\n    }\n\n    return result;\n  }\n\n  for (let i = 0; i < 100; i++) {\n    let frame;\n\n    try {\n      frame = frames[i];\n    } catch (err) {\n      return result;\n    }\n\n    if (!frame) {\n      return result;\n    }\n\n    result.push(frame);\n  }\n\n  return result;\n}\n\nexport function getAllChildFrames(\n  win: CrossDomainWindowType\n): $ReadOnlyArray<CrossDomainWindowType> {\n  const result = [];\n\n  for (const frame of getFrames(win)) {\n    result.push(frame);\n\n    for (const childFrame of getAllChildFrames(frame)) {\n      result.push(childFrame);\n    }\n  }\n\n  return result;\n}\n\nexport function getTop(\n  win?: CrossDomainWindowType = window\n): ?CrossDomainWindowType {\n  try {\n    if (win.top) {\n      return win.top;\n    }\n  } catch (err) {\n    // pass\n  }\n\n  if (getParent(win) === win) {\n    return win;\n  }\n\n  try {\n    if (isAncestorParent(window, win) && window.top) {\n      return window.top;\n    }\n  } catch (err) {\n    // pass\n  }\n\n  try {\n    if (isAncestorParent(win, window) && window.top) {\n      return window.top;\n    }\n  } catch (err) {\n    // pass\n  }\n\n  for (const frame of getAllChildFrames(win)) {\n    try {\n      if (frame.top) {\n        return frame.top;\n      }\n    } catch (err) {\n      // pass\n    }\n\n    if (getParent(frame) === frame) {\n      return frame;\n    }\n  }\n}\n\nexport function getNextOpener(\n  win?: CrossDomainWindowType = window\n): ?CrossDomainWindowType {\n  return getOpener(getTop(win) || win);\n}\n\nexport function getUltimateTop(\n  win?: CrossDomainWindowType = window\n): CrossDomainWindowType {\n  const opener = getNextOpener(win);\n\n  if (opener) {\n    return getUltimateTop(opener);\n  }\n\n  return top;\n}\n\nexport function getAllFramesInWindow(\n  win: CrossDomainWindowType\n): $ReadOnlyArray<CrossDomainWindowType> {\n  const top = getTop(win);\n\n  if (!top) {\n    throw new Error(`Can not determine top window`);\n  }\n\n  let result = [...getAllChildFrames(top), top];\n\n  // Win may be in shadow dom\n  if (result.indexOf(win) === -1) {\n    result = [...result, win, ...getAllChildFrames(win)];\n  }\n\n  return result;\n}\n\nexport function getAllWindows(\n  win?: CrossDomainWindowType = window\n): $ReadOnlyArray<CrossDomainWindowType> {\n  const frames = getAllFramesInWindow(win);\n  const opener = getNextOpener(win);\n\n  if (opener) {\n    return [...getAllWindows(opener), ...frames];\n  } else {\n    return frames;\n  }\n}\n\nexport function isTop(win: CrossDomainWindowType): boolean {\n  return win === getTop(win);\n}\n\nexport function isFrameWindowClosed(frame: HTMLIFrameElement): boolean {\n  if (!frame.contentWindow) {\n    return true;\n  }\n\n  if (!frame.parentNode) {\n    return true;\n  }\n\n  const doc = frame.ownerDocument;\n\n  if (doc && doc.documentElement && !doc.documentElement.contains(frame)) {\n    let parent = frame;\n\n    while (parent.parentNode && parent.parentNode !== parent) {\n      parent = parent.parentNode;\n    }\n\n    // $FlowFixMe\n    if (!parent.host || !doc.documentElement.contains(parent.host)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction safeIndexOf<T>(collection: $ReadOnlyArray<T>, item: T): number {\n  for (let i = 0; i < collection.length; i++) {\n    try {\n      if (collection[i] === item) {\n        return i;\n      }\n    } catch (err) {\n      // pass\n    }\n  }\n\n  return -1;\n}\n\nconst iframeWindows = [];\nconst iframeFrames = [];\n\nexport function isWindowClosed(\n  win: CrossDomainWindowType,\n  allowMock: boolean = true\n): boolean {\n  try {\n    if (win === window) {\n      return false;\n    }\n  } catch (err) {\n    return true;\n  }\n\n  try {\n    if (!win) {\n      return true;\n    }\n  } catch (err) {\n    return true;\n  }\n\n  try {\n    if (win.closed) {\n      return true;\n    }\n  } catch (err) {\n    // I love you so much IE\n\n    if (err && err.message === IE_WIN_ACCESS_ERROR) {\n      return false;\n    }\n\n    return true;\n  }\n\n  if (allowMock && isSameDomain(win)) {\n    try {\n      // $FlowFixMe\n      if (win.mockclosed) {\n        return true;\n      }\n    } catch (err) {\n      // pass\n    }\n  }\n\n  // Mobile safari\n\n  try {\n    if (!win.parent || !win.top) {\n      return true;\n    }\n  } catch (err) {\n    // pass\n  }\n\n  // Yes, this actually happens in IE. win === win errors out when the window\n  // is from an iframe, and the iframe was removed from the page.\n\n  try {\n    noop(win === win); // eslint-disable-line no-self-compare\n  } catch (err) {\n    return true;\n  }\n\n  // IE orphaned frame\n\n  const iframeIndex = safeIndexOf(iframeWindows, win);\n\n  if (iframeIndex !== -1) {\n    const frame = iframeFrames[iframeIndex];\n\n    if (frame && isFrameWindowClosed(frame)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction cleanIframes() {\n  for (let i = 0; i < iframeWindows.length; i++) {\n    let closed = false;\n\n    try {\n      closed = iframeWindows[i].closed;\n    } catch (err) {\n      // pass\n    }\n\n    if (closed) {\n      iframeFrames.splice(i, 1);\n      iframeWindows.splice(i, 1);\n    }\n  }\n}\n\nexport function linkFrameWindow(frame: HTMLIFrameElement) {\n  cleanIframes();\n\n  if (frame && frame.contentWindow) {\n    try {\n      iframeWindows.push(frame.contentWindow);\n      iframeFrames.push(frame);\n    } catch (err) {\n      // pass\n    }\n  }\n}\n\nexport function getUserAgent(win: ?SameDomainWindowType): string {\n  win = win || window;\n  return win.navigator.mockUserAgent || win.navigator.userAgent;\n}\n\nexport function getFrameByName(\n  win: CrossDomainWindowType,\n  name: string\n): ?CrossDomainWindowType {\n  const winFrames = getFrames(win);\n\n  for (const childFrame of winFrames) {\n    try {\n      if (\n        isSameDomain(childFrame) &&\n        // $FlowFixMe\n        childFrame.name === name &&\n        winFrames.indexOf(childFrame) !== -1\n      ) {\n        return childFrame;\n      }\n    } catch (err) {\n      // pass\n    }\n  }\n\n  try {\n    // $FlowFixMe\n    if (winFrames.indexOf(win.frames[name]) !== -1) {\n      // $FlowFixMe\n      return win.frames[name];\n    }\n  } catch (err) {\n    // pass\n  }\n\n  try {\n    if (winFrames.indexOf(win[name]) !== -1) {\n      return win[name];\n    }\n  } catch (err) {\n    // pass\n  }\n}\n\nexport function findChildFrameByName(\n  win: CrossDomainWindowType,\n  name: string\n): ?CrossDomainWindowType {\n  const frame = getFrameByName(win, name);\n\n  if (frame) {\n    return frame;\n  }\n\n  for (const childFrame of getFrames(win)) {\n    const namedFrame = findChildFrameByName(childFrame, name);\n\n    if (namedFrame) {\n      return namedFrame;\n    }\n  }\n}\n\nexport function findFrameByName(\n  win: CrossDomainWindowType,\n  name: string\n): ?CrossDomainWindowType {\n  const frame = getFrameByName(win, name);\n\n  if (frame) {\n    return frame;\n  }\n\n  const top = getTop(win) || win;\n\n  return findChildFrameByName(top, name);\n}\n\nexport function isParent(\n  win: CrossDomainWindowType,\n  frame: CrossDomainWindowType\n): boolean {\n  const frameParent = getParent(frame);\n\n  if (frameParent) {\n    return frameParent === win;\n  }\n\n  for (const childFrame of getFrames(win)) {\n    if (childFrame === frame) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexport function isOpener(\n  parent: CrossDomainWindowType,\n  child: CrossDomainWindowType\n): boolean {\n  return parent === getOpener(child);\n}\n\nexport function getAncestor(\n  win?: CrossDomainWindowType = window\n): ?CrossDomainWindowType {\n  win = win || window;\n\n  const opener = getOpener(win);\n\n  if (opener) {\n    return opener;\n  }\n\n  const parent = getParent(win);\n\n  if (parent) {\n    return parent;\n  }\n}\n\nexport function getAncestors(\n  win: CrossDomainWindowType\n): $ReadOnlyArray<CrossDomainWindowType> {\n  const results = [];\n\n  let ancestor = win;\n\n  while (ancestor) {\n    ancestor = getAncestor(ancestor);\n    if (ancestor) {\n      results.push(ancestor);\n    }\n  }\n\n  return results;\n}\n\nexport function isAncestor(\n  parent: CrossDomainWindowType,\n  child: CrossDomainWindowType\n): boolean {\n  const actualParent = getAncestor(child);\n\n  if (actualParent) {\n    if (actualParent === parent) {\n      return true;\n    }\n\n    return false;\n  }\n\n  if (child === parent) {\n    return false;\n  }\n\n  if (getTop(child) === child) {\n    return false;\n  }\n\n  for (const frame of getFrames(parent)) {\n    if (frame === child) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexport function isPopup(win?: CrossDomainWindowType = window): boolean {\n  return Boolean(getOpener(win));\n}\n\nexport function isIframe(win?: CrossDomainWindowType = window): boolean {\n  return Boolean(getParent(win));\n}\n\nexport function isFullpage(win?: CrossDomainWindowType = window): boolean {\n  return Boolean(!isIframe(win) && !isPopup(win));\n}\n\nfunction anyMatch(collection1, collection2): boolean {\n  for (const item1 of collection1) {\n    for (const item2 of collection2) {\n      if (item1 === item2) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\nexport function getDistanceFromTop(\n  win: CrossDomainWindowType = window\n): number {\n  let distance = 0;\n  let parent = win;\n\n  while (parent) {\n    parent = getParent(parent);\n    if (parent) {\n      distance += 1;\n    }\n  }\n\n  return distance;\n}\n\nexport function getNthParent(\n  win: CrossDomainWindowType,\n  n: number = 1\n): ?CrossDomainWindowType {\n  let parent = win;\n\n  for (let i = 0; i < n; i++) {\n    if (!parent) {\n      return;\n    }\n\n    parent = getParent(parent);\n  }\n\n  return parent;\n}\n\nexport function getNthParentFromTop(\n  win: CrossDomainWindowType,\n  n: number = 1\n): ?CrossDomainWindowType {\n  return getNthParent(win, getDistanceFromTop(win) - n);\n}\n\nexport function isSameTopWindow(\n  win1: CrossDomainWindowType,\n  win2: CrossDomainWindowType\n): boolean {\n  const top1 = getTop(win1) || win1;\n  const top2 = getTop(win2) || win2;\n\n  try {\n    if (top1 && top2) {\n      if (top1 === top2) {\n        return true;\n      }\n\n      return false;\n    }\n  } catch (err) {\n    // pass\n  }\n\n  const allFrames1 = getAllFramesInWindow(win1);\n  const allFrames2 = getAllFramesInWindow(win2);\n\n  if (anyMatch(allFrames1, allFrames2)) {\n    return true;\n  }\n\n  const opener1 = getOpener(top1);\n  const opener2 = getOpener(top2);\n\n  if (opener1 && anyMatch(getAllFramesInWindow(opener1), allFrames2)) {\n    return false;\n  }\n\n  if (opener2 && anyMatch(getAllFramesInWindow(opener2), allFrames1)) {\n    return false;\n  }\n\n  return false;\n}\n\nexport function matchDomain(\n  pattern: DomainMatcher,\n  origin: DomainMatcher\n): boolean {\n  if (typeof pattern === \"string\") {\n    if (typeof origin === \"string\") {\n      return pattern === WILDCARD || origin === pattern;\n    }\n\n    if (isRegex(origin)) {\n      return false;\n    }\n\n    if (Array.isArray(origin)) {\n      return false;\n    }\n  }\n\n  if (isRegex(pattern)) {\n    if (isRegex(origin)) {\n      return pattern.toString() === origin.toString();\n    }\n\n    if (Array.isArray(origin)) {\n      return false;\n    }\n\n    // $FlowFixMe\n    return Boolean(origin.match(pattern));\n  }\n\n  if (Array.isArray(pattern)) {\n    if (Array.isArray(origin)) {\n      return JSON.stringify(pattern) === JSON.stringify(origin);\n    }\n\n    if (isRegex(origin)) {\n      return false;\n    }\n\n    return pattern.some((subpattern) => matchDomain(subpattern, origin));\n  }\n\n  return false;\n}\n\nexport function stringifyDomainPattern(pattern: DomainMatcher): string {\n  if (Array.isArray(pattern)) {\n    return `(${pattern.join(\" | \")})`;\n  } else if (isRegex(pattern)) {\n    return `RegExp(${pattern.toString()})`;\n  } else {\n    return pattern.toString();\n  }\n}\n\nexport function getDomainFromUrl(url: string): string {\n  let domain;\n\n  if (url.match(/^(https?|mock|file):\\/\\//)) {\n    domain = url;\n  } else {\n    return getDomain();\n  }\n\n  domain = domain.split(\"/\").slice(0, 3).join(\"/\");\n\n  return domain;\n}\n\nexport function onCloseWindow(\n  win: CrossDomainWindowType,\n  callback: Function,\n  delay: number = 1000,\n  maxtime: number = Infinity\n): {| cancel: () => void |} {\n  let timeout;\n\n  const check = () => {\n    if (isWindowClosed(win)) {\n      if (timeout) {\n        clearTimeout(timeout);\n      }\n\n      return callback();\n    }\n\n    if (maxtime <= 0) {\n      clearTimeout(timeout);\n    } else {\n      maxtime -= delay;\n      timeout = setTimeout(check, delay);\n    }\n  };\n\n  check();\n\n  return {\n    cancel() {\n      if (timeout) {\n        clearTimeout(timeout);\n      }\n    },\n  };\n}\n\n// eslint-disable-next-line complexity\nexport function isWindow(obj: Object): boolean {\n  try {\n    if (obj === window) {\n      return true;\n    }\n  } catch (err) {\n    if (err && err.message === IE_WIN_ACCESS_ERROR) {\n      return true;\n    }\n  }\n\n  try {\n    // $FlowFixMe method-unbinding\n    if (Object.prototype.toString.call(obj) === \"[object Window]\") {\n      return true;\n    }\n  } catch (err) {\n    if (err && err.message === IE_WIN_ACCESS_ERROR) {\n      return true;\n    }\n  }\n\n  try {\n    if (window.Window && obj instanceof window.Window) {\n      return true;\n    }\n  } catch (err) {\n    if (err && err.message === IE_WIN_ACCESS_ERROR) {\n      return true;\n    }\n  }\n\n  try {\n    if (obj && obj.self === obj) {\n      return true;\n    }\n  } catch (err) {\n    if (err && err.message === IE_WIN_ACCESS_ERROR) {\n      return true;\n    }\n  }\n\n  try {\n    if (obj && obj.parent === obj) {\n      return true;\n    }\n  } catch (err) {\n    if (err && err.message === IE_WIN_ACCESS_ERROR) {\n      return true;\n    }\n  }\n\n  try {\n    if (obj && obj.top === obj) {\n      return true;\n    }\n  } catch (err) {\n    if (err && err.message === IE_WIN_ACCESS_ERROR) {\n      return true;\n    }\n  }\n\n  try {\n    // eslint-disable-next-line no-self-compare\n    if (noop(obj === obj) === \"__unlikely_value__\") {\n      return false;\n    }\n  } catch (err) {\n    return true;\n  }\n\n  try {\n    if (\n      obj &&\n      obj.__cross_domain_utils_window_check__ === \"__unlikely_value__\"\n    ) {\n      return false;\n    }\n  } catch (err) {\n    return true;\n  }\n\n  try {\n    if (\"postMessage\" in obj && \"self\" in obj && \"location\" in obj) {\n      return true;\n    }\n  } catch (err) {\n    // pass\n  }\n\n  return false;\n}\n\nexport function isBrowser(): boolean {\n  return (\n    typeof window !== \"undefined\" && typeof window.location !== \"undefined\"\n  );\n}\n\nexport function isCurrentDomain(domain: string): boolean {\n  if (!isBrowser()) {\n    return false;\n  }\n\n  return getDomain() === domain;\n}\n\nexport function isMockDomain(domain: string): boolean {\n  return domain.indexOf(PROTOCOL.MOCK) === 0;\n}\n\nexport function normalizeMockUrl(url: string): string {\n  if (!isMockDomain(getDomainFromUrl(url))) {\n    return url;\n  }\n\n  if (!__TEST__) {\n    throw new Error(`Mock urls not supported out of test mode`);\n  }\n\n  return url.replace(/^mock:\\/\\/[^/]+/, getActualDomain(window));\n}\n\nexport function getFrameForWindow(win: CrossDomainWindowType): ?HTMLElement {\n  if (isSameDomain(win)) {\n    return assertSameDomain(win).frameElement;\n  }\n\n  for (const frame of document.querySelectorAll(\"iframe\")) {\n    if (frame && frame.contentWindow && frame.contentWindow === win) {\n      return frame;\n    }\n  }\n}\n\nexport function closeWindow(win: CrossDomainWindowType) {\n  if (isIframe(win)) {\n    const frame = getFrameForWindow(win);\n    if (frame && frame.parentElement) {\n      frame.parentElement.removeChild(frame);\n      return;\n    }\n  }\n\n  try {\n    win.close();\n  } catch (err) {\n    // pass\n  }\n}\n","/* @flow */\n\nexport function isPromise(item : mixed) : boolean {\n    try {\n        if (!item) {\n            return false;\n        }\n\n        if (typeof Promise !== 'undefined' && item instanceof Promise) {\n            return true;\n        }\n\n        if (typeof window !== 'undefined' && typeof window.Window === 'function' && item instanceof window.Window) {\n            return false;\n        }\n\n        if (typeof window !== 'undefined' && typeof window.constructor === 'function' && item instanceof window.constructor) {\n            return false;\n        }\n\n        const toString = ({}).toString;\n\n        if (toString) {\n            const name = toString.call(item);\n\n            if (name === '[object Window]' || name === '[object global]' || name === '[object DOMWindow]') {\n                return false;\n            }\n        }\n\n        if (typeof item.then === 'function') {\n            return true;\n        }\n    } catch (err) {\n        return false;\n    }\n\n    return false;\n}\n","/* @flow */\n\nimport type { ZalgoPromise } from './promise';\n\nconst dispatchedErrors = [];\nconst possiblyUnhandledPromiseHandlers : Array<(mixed, promise? : ZalgoPromise<mixed>) => void> = [];\n\nexport function dispatchPossiblyUnhandledError<T>(err : mixed, promise : ZalgoPromise<T>) {\n\n    if (dispatchedErrors.indexOf(err) !== -1) {\n        return;\n    }\n\n    dispatchedErrors.push(err);\n\n    setTimeout(() => {\n        if (__DEBUG__) {\n            // $FlowFixMe\n            throw new Error(`${ err.stack || err.toString() }\\n\\nFrom promise:\\n\\n${ promise.stack }`);\n        }\n\n        throw err;\n    }, 1);\n\n    for (let j = 0; j < possiblyUnhandledPromiseHandlers.length; j++) {\n        // $FlowFixMe\n        possiblyUnhandledPromiseHandlers[j](err, promise);\n    }\n}\n\nexport function onPossiblyUnhandledException(handler : (mixed, promise? : ZalgoPromise<mixed>) => void) : {| cancel : () => void |} {\n    possiblyUnhandledPromiseHandlers.push(handler);\n\n    return {\n        cancel() {\n            possiblyUnhandledPromiseHandlers.splice(possiblyUnhandledPromiseHandlers.indexOf(handler), 1);\n        }\n    };\n}\n","/* @flow */\n\nimport type { ZalgoPromise } from './promise';\n\nlet activeCount = 0;\nlet flushPromise;\n\nfunction flushActive() {\n    if (!activeCount && flushPromise) {\n        const promise = flushPromise;\n        flushPromise = null;\n        promise.resolve();\n    }\n}\n\nexport function startActive() {\n    activeCount += 1;\n}\n\nexport function endActive() {\n    activeCount -= 1;\n    flushActive();\n}\n\nexport function awaitActive(Zalgo : Class<ZalgoPromise<*>>) : ZalgoPromise<void> { // eslint-disable-line no-undef\n    const promise = flushPromise = flushPromise || new Zalgo();\n    flushActive();\n    return promise;\n}\n","/* @flow */\n/* eslint no-use-before-define: off */\n\nimport { isPromise } from './utils';\nimport { onPossiblyUnhandledException, dispatchPossiblyUnhandledError } from './exceptions';\nimport { startActive, endActive, awaitActive } from './flush';\n\nexport class ZalgoPromise<R : mixed> {\n\n    resolved : boolean;\n    rejected : boolean;\n    errorHandled : boolean;\n    value : R;\n    error : mixed;\n    // eslint-disable-next-line flowtype/no-mutable-array\n    handlers : Array<{|\n        promise : ZalgoPromise<*>,\n        onSuccess : void | (result : R) => mixed,\n        onError : void | (error : mixed) => mixed\n    |}>;\n    dispatching : boolean;\n    stack : string;\n\n    constructor(handler : ?(resolve : (result : R) => void, reject : (error : mixed) => void) => void) {\n\n        this.resolved = false;\n        this.rejected = false;\n        this.errorHandled = false;\n\n        this.handlers = [];\n\n        if (handler) {\n\n            let result;\n            let error;\n            let resolved = false;\n            let rejected = false;\n            let isAsync = false;\n\n            startActive();\n\n            try {\n                handler(res => {\n                    if (isAsync) {\n                        this.resolve(res);\n                    } else {\n                        resolved = true;\n                        result = res;\n                    }\n\n                }, err => {\n                    if (isAsync) {\n                        this.reject(err);\n                    } else {\n                        rejected = true;\n                        error = err;\n                    }\n                });\n\n            } catch (err) {\n                endActive();\n                this.reject(err);\n                return;\n            }\n\n            endActive();\n\n            isAsync = true;\n\n            if (resolved) {\n                // $FlowFixMe\n                this.resolve(result);\n            } else if (rejected) {\n                this.reject(error);\n            }\n        }\n\n        if (__DEBUG__) {\n            try {\n                throw new Error(`ZalgoPromise`);\n            } catch (err) {\n                this.stack = err.stack;\n            }\n        }\n    }\n\n    resolve(result : R) : ZalgoPromise<R> {\n        if (this.resolved || this.rejected) {\n            return this;\n        }\n\n        if (isPromise(result)) {\n            throw new Error('Can not resolve promise with another promise');\n        }\n\n        this.resolved = true;\n        this.value = result;\n        this.dispatch();\n\n        return this;\n    }\n\n    reject(error : mixed) : ZalgoPromise<R> {\n        if (this.resolved || this.rejected) {\n            return this;\n        }\n\n        if (isPromise(error)) {\n            throw new Error('Can not reject promise with another promise');\n        }\n\n        if (!error) {\n            // $FlowFixMe\n            const err = (error && typeof error.toString === 'function' ? error.toString() : Object.prototype.toString.call(error));\n            error = new Error(`Expected reject to be called with Error, got ${ err }`);\n        }\n\n        this.rejected = true;\n        this.error = error;\n\n        if (!this.errorHandled) {\n            setTimeout(() => {\n                if (!this.errorHandled) {\n                    dispatchPossiblyUnhandledError(error, this);\n                }\n            }, 1);\n        }\n\n        this.dispatch();\n\n        return this;\n    }\n\n    asyncReject(error : mixed) : ZalgoPromise<R> {\n        this.errorHandled = true;\n        this.reject(error);\n        return this;\n    }\n\n    dispatch() {\n\n        const { dispatching, resolved, rejected, handlers } = this;\n\n        if (dispatching) {\n            return;\n        }\n\n        if (!resolved && !rejected) {\n            return;\n        }\n\n        this.dispatching = true;\n        startActive();\n\n        const chain = <T>(firstPromise : ZalgoPromise<T>, secondPromise : ZalgoPromise<T>) => {\n            return firstPromise.then(res => {\n                secondPromise.resolve(res);\n            }, err => {\n                secondPromise.reject(err);\n            });\n        };\n\n        for (let i = 0; i < handlers.length; i++) {\n\n            const { onSuccess, onError, promise } = handlers[i];\n\n            let result;\n\n            if (resolved) {\n\n                try {\n                    result = onSuccess ? onSuccess(this.value) : this.value;\n                } catch (err) {\n                    promise.reject(err);\n                    continue;\n                }\n\n            } else if (rejected) {\n\n                if (!onError) {\n                    promise.reject(this.error);\n                    continue;\n                }\n\n                try {\n                    result = onError(this.error);\n                } catch (err) {\n                    promise.reject(err);\n                    continue;\n                }\n            }\n\n            if (result instanceof ZalgoPromise && (result.resolved || result.rejected)) {\n                const promiseResult : ZalgoPromise<*> = result;\n\n                if (promiseResult.resolved) {\n                    promise.resolve(promiseResult.value);\n                } else {\n                    promise.reject(promiseResult.error);\n                }\n\n                promiseResult.errorHandled = true;\n\n            } else if (isPromise(result)) {\n\n                if (result instanceof ZalgoPromise && (result.resolved || result.rejected)) {\n                    if (result.resolved) {\n                        promise.resolve(result.value);\n                    } else {\n                        promise.reject(result.error);\n                    }\n\n                } else {\n                    // $FlowFixMe\n                    chain(result, promise);\n                }\n\n            } else {\n\n                promise.resolve(result);\n            }\n        }\n\n        handlers.length = 0;\n        this.dispatching = false;\n        endActive();\n    }\n\n    then<X, Y>(onSuccess : void | (result : R) => (ZalgoPromise<X> | Y), onError : void | (error : mixed) => (ZalgoPromise<X> | Y)) : ZalgoPromise<X | Y> {\n\n        if (onSuccess && typeof onSuccess !== 'function' && !onSuccess.call) {\n            throw new Error('Promise.then expected a function for success handler');\n        }\n\n        if (onError && typeof onError !== 'function' && !onError.call) {\n            throw new Error('Promise.then expected a function for error handler');\n        }\n\n        const promise = new ZalgoPromise();\n\n        this.handlers.push({\n            promise,\n            onSuccess,\n            onError\n        });\n\n        this.errorHandled = true;\n\n        this.dispatch();\n\n        return promise;\n    }\n\n    catch<X, Y>(onError : (error : mixed) => ZalgoPromise<X> | Y) : ZalgoPromise<X | Y> {\n        // $FlowFixMe incompatible-call\n        const resultPromise : ZalgoPromise<X | Y> = this.then(undefined, onError);\n        return resultPromise;\n    }\n\n    finally(onFinally : () => mixed) : ZalgoPromise<R> {\n\n        if (onFinally && typeof onFinally !== 'function' && !onFinally.call) {\n            throw new Error('Promise.finally expected a function');\n        }\n\n        return this.then((result) => {\n            return ZalgoPromise.try(onFinally)\n                .then(() => {\n                    return result;\n                });\n        }, (err) => {\n            return ZalgoPromise.try(onFinally)\n                .then(() => {\n                    throw err;\n                });\n        });\n    }\n\n    timeout(time : number, err : ?Error) : ZalgoPromise<R> {\n\n        if (this.resolved || this.rejected) {\n            return this;\n        }\n\n        const timeout = setTimeout(() => {\n\n            if (this.resolved || this.rejected) {\n                return;\n            }\n\n            this.reject(err || new Error(`Promise timed out after ${ time }ms`));\n\n        }, time);\n\n        return this.then(result => {\n            clearTimeout(timeout);\n            return result;\n        });\n    }\n\n    // $FlowFixMe\n    toPromise() : Promise<R> {\n        // $FlowFixMe\n        if (typeof Promise === 'undefined') {\n            throw new TypeError(`Could not find Promise`);\n        }\n        // $FlowFixMe\n        return Promise.resolve(this); // eslint-disable-line compat/compat\n    }\n\n    lazy() : ZalgoPromise<R> {\n        this.errorHandled = true;\n        return this;\n    }\n\n    static resolve<X, Y>(value : ZalgoPromise<X> | Y) : ZalgoPromise<X | Y> {\n\n        if (value instanceof ZalgoPromise) {\n            // $FlowFixMe incompatible-type-arg\n            const result : ZalgoPromise<X | Y> = value;\n            return result;\n        }\n\n        if (isPromise(value)) {\n            // $FlowFixMe\n            return new ZalgoPromise((resolve, reject) => value.then(resolve, reject));\n        }\n\n        return new ZalgoPromise().resolve(value);\n    }\n\n    static reject(error : mixed) : ZalgoPromise<R> {\n        return new ZalgoPromise().reject(error);\n    }\n\n    static asyncReject(error : mixed) : ZalgoPromise<R> {\n        return new ZalgoPromise().asyncReject(error);\n    }\n\n    static all<X : $ReadOnlyArray<mixed>>(promises : X) : ZalgoPromise<$TupleMap<X, <Y>(ZalgoPromise<Y> | Y) => Y>> { // eslint-disable-line no-undef\n\n        const promise = new ZalgoPromise();\n        let count = promises.length;\n        // eslint-disable-next-line no-undef, unicorn/prefer-spread\n        const results = ([] : $TupleMap<X, <Y>(ZalgoPromise<Y> | Y) => Y>).slice();\n\n        if (!count) {\n            promise.resolve(results);\n            return promise;\n        }\n\n        const chain = <T>(i : number, firstPromise : ZalgoPromise<T>, secondPromise : ZalgoPromise<T>) => {\n            return firstPromise.then(res => {\n                results[i] = res;\n                count -= 1;\n                if (count === 0) {\n                    promise.resolve(results);\n                }\n            }, err => {\n                secondPromise.reject(err);\n            });\n        };\n\n        for (let i = 0; i < promises.length; i++) {\n            const prom = promises[i];\n\n            if (prom instanceof ZalgoPromise) {\n                if (prom.resolved) {\n                    results[i] = prom.value;\n                    count -= 1;\n                    continue;\n                }\n            } else if (!isPromise(prom)) {\n                results[i] = prom;\n                count -= 1;\n                continue;\n            }\n\n            chain(i, ZalgoPromise.resolve(prom), promise);\n        }\n\n        if (count === 0) {\n            promise.resolve(results);\n        }\n\n        return promise;\n    }\n\n    static hash<O : Object>(promises : O) : ZalgoPromise<$ObjMap<O, <Y>(ZalgoPromise<Y> | Y) => Y>> { // eslint-disable-line no-undef\n        const result = {};\n        const awaitPromises = [];\n\n        for (const key in promises) {\n            if (promises.hasOwnProperty(key)) {\n                const value = promises[key];\n\n                if (isPromise(value)) {\n                    awaitPromises.push(value.then(res => {\n                        result[key] = res;\n                    }));\n                } else {\n                    result[key] = value;\n                }\n            }\n        }\n\n        return ZalgoPromise.all(awaitPromises).then(() => result);\n    }\n\n    static map<T, X>(items : $ReadOnlyArray<T>, method : (T) => (ZalgoPromise<X> | X)) : ZalgoPromise<$ReadOnlyArray<X>> {\n        // $FlowFixMe\n        return ZalgoPromise.all(items.map(method));\n    }\n\n    static onPossiblyUnhandledException(handler : (err : mixed) => void) : {| cancel : () => void |} {\n        return onPossiblyUnhandledException(handler);\n    }\n\n    static try<X, Y, C : mixed, A : $ReadOnlyArray<mixed>>(method : (...args : $ReadOnlyArray<mixed>) => (ZalgoPromise<X> | Y), context? : C, args? : A) : ZalgoPromise<X | Y> {\n\n        if (method && typeof method !== 'function' && !method.call) {\n            throw new Error('Promise.try expected a function');\n        }\n\n        let result : ZalgoPromise<X> | Y;\n\n        startActive();\n\n        try {\n            result = method.apply(context, args || []);\n        } catch (err) {\n            endActive();\n            return ZalgoPromise.reject(err);\n        }\n\n        endActive();\n\n        // $FlowFixMe incompatible-call\n        const resultPromise = ZalgoPromise.resolve(result);\n\n        return resultPromise;\n    }\n\n    static delay(delay : number) : ZalgoPromise<void> {\n        return new ZalgoPromise(resolve => {\n            setTimeout(resolve, delay);\n        });\n    }\n\n    static isPromise(value : mixed) : boolean {\n\n        if (value && value instanceof ZalgoPromise) {\n            return true;\n        }\n\n        return isPromise(value);\n    }\n\n    static flush() : ZalgoPromise<void> {\n        return awaitActive(ZalgoPromise);\n    }\n}\n","export default function _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}","import setPrototypeOf from \"@babel/runtime/helpers/esm/setPrototypeOf\";\nexport default function _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  setPrototypeOf(subClass, superClass);\n}","/* @flow */\n\nexport function safeIndexOf<T>(collection : $ReadOnlyArray<T>, item : T) : number {\n    for (let i = 0; i < collection.length; i++) {\n\n        try {\n            if (collection[i] === item) {\n                return i;\n            }\n        } catch (err) {\n            // pass\n        }\n    }\n\n    return -1;\n}\n\n// eslint-disable-next-line no-unused-vars\nexport function noop(...args : $ReadOnlyArray<mixed>) {\n    // pass\n}\n","/* @flow */\n\nimport { isWindow, isWindowClosed } from '@krakenjs/cross-domain-utils/src';\n\nimport { hasNativeWeakMap } from './native';\nimport { noop, safeIndexOf } from './util';\n\nexport class CrossDomainSafeWeakMap<K : Object, V : mixed> {\n\n    name : string;\n    weakmap : ?WeakMap<K, V>;\n    // eslint-disable-next-line flowtype/no-mutable-array\n    keys : Array<K>;\n    // eslint-disable-next-line flowtype/no-mutable-array\n    values : Array<V>;\n\n    constructor() {\n        // eslint-disable-next-line no-bitwise\n        this.name = `__weakmap_${ Math.random() * 1e9 >>> 0 }__`;\n\n        if (hasNativeWeakMap()) {\n            try {\n                this.weakmap = new WeakMap();\n            } catch (err) {\n                // pass\n            }\n        }\n\n        this.keys  = [];\n        this.values = [];\n    }\n\n    _cleanupClosedWindows() {\n\n        const weakmap = this.weakmap;\n        const keys = this.keys;\n\n        for (let i = 0; i < keys.length; i++) {\n            const value = keys[i];\n\n            if (isWindow(value) && isWindowClosed(value)) {\n\n                if (weakmap) {\n                    try {\n                        weakmap.delete(value);\n                    } catch (err) {\n                        // pass\n                    }\n                }\n\n                keys.splice(i, 1);\n                this.values.splice(i, 1);\n\n                i -= 1;\n            }\n        }\n    }\n\n    isSafeToReadWrite(key : K) : boolean {\n\n        if (isWindow(key)) {\n            return false;\n        }\n\n        try {\n            noop(key && key.self);\n            noop(key && key[this.name]);\n        } catch (err) {\n            return false;\n        }\n\n        return true;\n    }\n\n    set(key : K, value : V) {\n\n        if (!key) {\n            throw new Error(`WeakMap expected key`);\n        }\n\n        const weakmap = this.weakmap;\n\n        if (weakmap) {\n            try {\n                weakmap.set(key, value);\n            } catch (err) {\n                delete this.weakmap;\n            }\n        }\n\n        if (this.isSafeToReadWrite(key)) {\n            try {\n                const name = this.name;\n                const entry = key[name];\n\n                if (entry && entry[0] === key) {\n                    entry[1] = value;\n                } else {\n                    Object.defineProperty(key, name, {\n                        value:    [ key, value ],\n                        writable: true\n                    });\n                }\n\n                return;\n\n            } catch (err) {\n                // pass\n            }\n        }\n\n        this._cleanupClosedWindows();\n\n        const keys = this.keys;\n        const values = this.values;\n        const index = safeIndexOf(keys, key);\n\n        if (index === -1) {\n            keys.push(key);\n            values.push(value);\n        } else {\n            values[index] = value;\n        }\n    }\n\n    get(key : K) : V | void {\n\n        if (!key) {\n            throw new Error(`WeakMap expected key`);\n        }\n\n        const weakmap = this.weakmap;\n\n        if (weakmap) {\n            try {\n                if (weakmap.has(key)) {\n                    return weakmap.get(key);\n                }\n\n            } catch (err) {\n                delete this.weakmap;\n            }\n        }\n\n        if (this.isSafeToReadWrite(key)) {\n            try {\n                const entry = key[this.name];\n\n                if (entry && entry[0] === key) {\n                    return entry[1];\n                }\n\n                return;\n            } catch (err) {\n                // pass\n            }\n        }\n\n        this._cleanupClosedWindows();\n\n        const keys = this.keys;\n        const index = safeIndexOf(keys, key);\n\n        if (index === -1) {\n            return;\n        }\n\n        return this.values[index];\n    }\n\n    delete(key : K) {\n\n        if (!key) {\n            throw new Error(`WeakMap expected key`);\n        }\n\n        const weakmap = this.weakmap;\n\n        if (weakmap) {\n            try {\n                weakmap.delete(key);\n            } catch (err) {\n                delete this.weakmap;\n            }\n        }\n\n        if (this.isSafeToReadWrite(key)) {\n            try {\n                const entry = key[this.name];\n\n                if (entry && entry[0] === key) {\n                    entry[0] = entry[1] = undefined;\n                }\n            } catch (err) {\n                // pass\n            }\n        }\n\n        this._cleanupClosedWindows();\n\n        const keys = this.keys;\n        const index = safeIndexOf(keys, key);\n\n        if (index !== -1) {\n            keys.splice(index, 1);\n            this.values.splice(index, 1);\n        }\n    }\n\n    has(key : K) : boolean {\n\n        if (!key) {\n            throw new Error(`WeakMap expected key`);\n        }\n\n        const weakmap = this.weakmap;\n\n        if (weakmap) {\n            try {\n                if (weakmap.has(key)) {\n                    return true;\n                }\n            } catch (err) {\n                delete this.weakmap;\n            }\n        }\n\n        if (this.isSafeToReadWrite(key)) {\n            try {\n                const entry = key[this.name];\n\n                if (entry && entry[0] === key) {\n                    return true;\n                }\n\n                return false;\n            } catch (err) {\n                // pass\n            }\n        }\n\n        this._cleanupClosedWindows();\n\n        const index = safeIndexOf(this.keys, key);\n        return index !== -1;\n    }\n\n    getOrSet(key : K, getter : () => V) : V {\n        if (this.has(key)) {\n            // $FlowFixMe\n            return this.get(key);\n        }\n\n        const value = getter();\n        this.set(key, value);\n        return value;\n    }\n}\n","/* @flow */\n/* eslint max-lines: 0 */\nimport { ZalgoPromise } from \"@krakenjs/zalgo-promise/src\";\nimport { WeakMap } from \"@krakenjs/cross-domain-safe-weakmap/src\";\n\nimport {\n  BLANK_URL,\n  ctrlCharactersRegex,\n  htmlCtrlEntityRegex,\n  htmlEntitiesRegex,\n  invalidProtocolRegex,\n  relativeFirstCharacters,\n  urlSchemeRegex,\n} from \"./constants\";\nimport type { CancelableType } from \"./types\";\n\nexport function isElement(element: mixed): boolean {\n  let passed = false;\n\n  try {\n    if (element instanceof window.Element) {\n      passed = true;\n    } else if (\n      element !== null &&\n      typeof element === \"object\" &&\n      element.nodeType === 1 &&\n      typeof element.style === \"object\" &&\n      typeof element.ownerDocument === \"object\"\n    ) {\n      passed = true;\n    }\n  } catch (_) {\n    // we don't have an element\n  }\n\n  return passed;\n}\n\nexport function getFunctionName<T: Function>(fn: T): string {\n  return fn.name || fn.__name__ || fn.displayName || \"anonymous\";\n}\n\nexport function setFunctionName<T: Function>(fn: T, name: string): T {\n  try {\n    delete fn.name;\n    fn.name = name;\n  } catch (err) {\n    // pass\n  }\n\n  fn.__name__ = fn.displayName = name;\n  return fn;\n}\n\nexport function base64encode(str: string): string {\n  if (typeof btoa === \"function\") {\n    return btoa(\n      encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, (m, p1) => {\n        return String.fromCharCode(parseInt(p1, 16));\n      })\n    ).replace(/[=]/g, \"\");\n  }\n\n  if (typeof Buffer !== \"undefined\") {\n    return Buffer.from(str, \"utf8\").toString(\"base64\").replace(/[=]/g, \"\");\n  }\n\n  throw new Error(`Can not find window.btoa or Buffer`);\n}\n\nexport function base64decode(str: string): string {\n  if (typeof atob === \"function\") {\n    return decodeURIComponent(\n      // $FlowFixMe[method-unbinding]\n      Array.prototype.map\n        .call(atob(str), (c) => {\n          // eslint-disable-next-line prefer-template\n          return \"%\" + (\"00\" + c.charCodeAt(0).toString(16)).slice(-2);\n        })\n        .join(\"\")\n    );\n  }\n\n  if (typeof Buffer !== \"undefined\") {\n    return Buffer.from(str, \"base64\").toString(\"utf8\");\n  }\n\n  throw new Error(`Can not find window.atob or Buffer`);\n}\n\nexport function uniqueID(): string {\n  const chars = \"0123456789abcdef\";\n\n  const randomID = \"xxxxxxxxxx\".replace(/./g, () => {\n    return chars.charAt(Math.floor(Math.random() * chars.length));\n  });\n\n  const timeID = base64encode(\n    new Date().toISOString().slice(11, 19).replace(\"T\", \".\")\n  )\n    .replace(/[^a-zA-Z0-9]/g, \"\")\n    .toLowerCase();\n\n  return `uid_${randomID}_${timeID}`;\n}\n\nexport function getGlobal(): Object {\n  if (typeof window !== \"undefined\") {\n    return window;\n  }\n  if (typeof global !== \"undefined\") {\n    return global;\n  }\n  if (typeof __GLOBAL__ !== \"undefined\") {\n    return __GLOBAL__;\n  }\n  throw new Error(`No global found`);\n}\n\nlet objectIDs;\n\nexport function getObjectID(obj: Object): string {\n  objectIDs = objectIDs || new WeakMap();\n\n  if (\n    obj === null ||\n    obj === undefined ||\n    (typeof obj !== \"object\" && typeof obj !== \"function\")\n  ) {\n    throw new Error(`Invalid object`);\n  }\n\n  let uid = objectIDs.get(obj);\n\n  if (!uid) {\n    uid = `${typeof obj}:${uniqueID()}`;\n    objectIDs.set(obj, uid);\n  }\n\n  return uid;\n}\n\nfunction serializeArgs<T>(args: $ReadOnlyArray<T>): string {\n  try {\n    // $FlowFixMe[method-unbinding]\n    return JSON.stringify(Array.prototype.slice.call(args), (subkey, val) => {\n      // Treat each distinct function as unique for purposes of memoization\n      // e.g. even if someFunction.stringify() is the same, we may use a different memoize cache\n      // if the actual function is different.\n      if (typeof val === \"function\") {\n        return `memoize[${getObjectID(val)}]`;\n      }\n\n      // By default JSON.stringify(domElement) returns '{}'. This ensures that stays true even for non-standard\n      // elements (e.g. React-rendered dom elements) with custom properties\n      if (isElement(val)) {\n        return {};\n      }\n\n      return val;\n    });\n  } catch (err) {\n    throw new Error(`Arguments not serializable -- can not be used to memoize`);\n  }\n}\n\nexport function getEmptyObject(): {||} {\n  // $FlowFixMe\n  return {};\n}\n\ntype MemoizeOptions = {|\n  name?: string,\n  time?: number,\n  thisNamespace?: boolean,\n|};\n\nconst getDefaultMemoizeOptions = (): MemoizeOptions => {\n  // $FlowFixMe\n  return {};\n};\n\nexport type Memoized<F> = F & {| reset: () => void |};\n\nlet memoizeGlobalIndex = 0;\nlet memoizeGlobalIndexValidFrom = 0;\n\nexport function memoize<F: Function>(\n  method: F,\n  options?: MemoizeOptions = getDefaultMemoizeOptions()\n): Memoized<F> {\n  const { thisNamespace = false, time: cacheTime } = options;\n\n  let simpleCache;\n  let thisCache;\n\n  let memoizeIndex = memoizeGlobalIndex;\n  memoizeGlobalIndex += 1;\n\n  const memoizedFunction = function memoizedFunction(...args): mixed {\n    if (memoizeIndex < memoizeGlobalIndexValidFrom) {\n      simpleCache = null;\n      thisCache = null;\n      memoizeIndex = memoizeGlobalIndex;\n      memoizeGlobalIndex += 1;\n    }\n\n    let cache;\n\n    if (thisNamespace) {\n      thisCache = thisCache || new WeakMap();\n      cache = thisCache.getOrSet(this, getEmptyObject);\n    } else {\n      cache = simpleCache = simpleCache || {};\n    }\n\n    let cacheKey;\n\n    try {\n      cacheKey = serializeArgs(args);\n    } catch {\n      return method.apply(this, arguments);\n    }\n\n    let cacheResult = cache[cacheKey];\n\n    if (cacheResult && cacheTime && Date.now() - cacheResult.time < cacheTime) {\n      delete cache[cacheKey];\n      cacheResult = null;\n    }\n\n    if (cacheResult) {\n      return cacheResult.value;\n    }\n\n    const time = Date.now();\n    const value = method.apply(this, arguments);\n\n    cache[cacheKey] = { time, value };\n\n    return value;\n  };\n\n  memoizedFunction.reset = () => {\n    simpleCache = null;\n    thisCache = null;\n  };\n\n  // $FlowFixMe\n  const result: F = memoizedFunction;\n\n  return setFunctionName(\n    result,\n    `${options.name || getFunctionName(method)}::memoized`\n  );\n}\n\nmemoize.clear = () => {\n  memoizeGlobalIndexValidFrom = memoizeGlobalIndex;\n};\n\nexport function promiseIdentity<T: mixed>(\n  item: ZalgoPromise<T> | T\n): ZalgoPromise<T> {\n  // $FlowFixMe\n  return ZalgoPromise.resolve(item);\n}\n\nexport function memoizePromise<R>(\n  // eslint-disable-next-line flowtype/no-weak-types\n  method: (...args: $ReadOnlyArray<any>) => ZalgoPromise<R>\n  // eslint-disable-next-line flowtype/no-weak-types\n): (...args: $ReadOnlyArray<any>) => ZalgoPromise<R> {\n  let cache = {};\n\n  function memoizedPromiseFunction(\n    // eslint-disable-next-line flowtype/no-weak-types\n    ...args: $ReadOnlyArray<any>\n  ): ZalgoPromise<R> {\n    const key: string = serializeArgs(args);\n\n    if (cache.hasOwnProperty(key)) {\n      return cache[key];\n    }\n\n    cache[key] = ZalgoPromise.try(() => method.apply(this, arguments)).finally(\n      () => {\n        delete cache[key];\n      }\n    );\n\n    return cache[key];\n  }\n\n  memoizedPromiseFunction.reset = () => {\n    cache = {};\n  };\n\n  return setFunctionName(\n    memoizedPromiseFunction,\n    `${getFunctionName(method)}::promiseMemoized`\n  );\n}\n\ntype PromisifyOptions = {|\n  name?: string,\n|};\n\nconst getDefaultPromisifyOptions = (): PromisifyOptions => {\n  // $FlowFixMe\n  return {};\n};\n\nexport function promisify<R>(\n  // eslint-disable-next-line flowtype/no-weak-types\n  method: (...args: $ReadOnlyArray<any>) => R,\n  options: PromisifyOptions = getDefaultPromisifyOptions()\n  // eslint-disable-next-line flowtype/no-weak-types\n): (...args: $ReadOnlyArray<any>) => ZalgoPromise<R> {\n  function promisifiedFunction(): ZalgoPromise<R> {\n    return ZalgoPromise.try(method, this, arguments);\n  }\n\n  if (options.name) {\n    promisifiedFunction.displayName = `${options.name}:promisified`;\n  }\n\n  return setFunctionName(\n    promisifiedFunction,\n    `${getFunctionName(method)}::promisified`\n  );\n}\n\nexport function inlineMemoize<R>(\n  // eslint-disable-next-line flowtype/no-weak-types\n  method: (...args: $ReadOnlyArray<any>) => R,\n  // eslint-disable-next-line flowtype/no-weak-types\n  logic: (...args: $ReadOnlyArray<any>) => R,\n  // eslint-disable-next-line flowtype/no-weak-types\n  args: $ReadOnlyArray<any> = []\n): R {\n  // $FlowFixMe\n  const cache: {| [string]: R |} = (method.__inline_memoize_cache__ =\n    // $FlowFixMe\n    method.__inline_memoize_cache__ || {});\n  const key = serializeArgs(args);\n\n  if (cache.hasOwnProperty(key)) {\n    return cache[key];\n  }\n\n  const result = (cache[key] = logic(...args));\n\n  return result;\n}\n\n// eslint-disable-next-line no-unused-vars\nexport function noop(...args: $ReadOnlyArray<mixed>) {\n  // pass\n}\n\nexport function once(method: Function): Function {\n  let called = false;\n\n  const onceFunction = function (): mixed {\n    if (!called) {\n      called = true;\n      return method.apply(this, arguments);\n    }\n  };\n\n  return setFunctionName(onceFunction, `${getFunctionName(method)}::once`);\n}\n\nexport function hashStr(str: string): number {\n  let hash = 0;\n  for (let i = 0; i < str.length; i++) {\n    hash += str[i].charCodeAt(0) * Math.pow((i % 10) + 1, 5);\n  }\n  return Math.floor(Math.pow(Math.sqrt(hash), 5));\n}\n\nexport function strHashStr(str: string): string {\n  let hash = \"\";\n\n  for (let i = 0; i < str.length; i++) {\n    let total = str[i].charCodeAt(0) * i;\n\n    if (str[i + 1]) {\n      total += str[i + 1].charCodeAt(0) * (i - 1);\n    }\n\n    hash += String.fromCharCode(97 + (Math.abs(total) % 26));\n  }\n\n  return hash;\n}\n\nexport function match(str: string, pattern: RegExp): ?string {\n  const regmatch = str.match(pattern);\n  if (regmatch) {\n    return regmatch[1];\n  }\n}\n\nexport function awaitKey<T: mixed>(obj: Object, key: string): ZalgoPromise<T> {\n  return new ZalgoPromise((resolve) => {\n    let value = obj[key];\n\n    if (value) {\n      return resolve(value);\n    }\n\n    delete obj[key];\n\n    Object.defineProperty(obj, key, {\n      configurable: true,\n\n      set(item) {\n        value = item;\n\n        if (value) {\n          resolve(value);\n        }\n      },\n\n      get(): T {\n        return value;\n      },\n    });\n  });\n}\n\nexport function stringifyError(err: mixed, level: number = 1): string {\n  if (level >= 3) {\n    return \"stringifyError stack overflow\";\n  }\n\n  try {\n    if (!err) {\n      // $FlowFixMe[method-unbinding]\n      return `<unknown error: ${Object.prototype.toString.call(err)}>`;\n    }\n\n    if (typeof err === \"string\") {\n      return err;\n    }\n\n    if (err instanceof Error) {\n      const stack = err && err.stack;\n      const message = err && err.message;\n\n      if (stack && message) {\n        if (stack.indexOf(message) !== -1) {\n          return stack;\n        } else {\n          return `${message}\\n${stack}`;\n        }\n      } else if (stack) {\n        return stack;\n      } else if (message) {\n        return message;\n      }\n    }\n\n    if (err && err.toString && typeof err.toString === \"function\") {\n      // $FlowFixMe\n      return err.toString();\n    }\n\n    // $FlowFixMe[method-unbinding]\n    return Object.prototype.toString.call(err);\n  } catch (newErr) {\n    return `Error while stringifying error: ${stringifyError(\n      newErr,\n      level + 1\n    )}`;\n  }\n}\n\nexport function stringifyErrorMessage(err: mixed): string {\n  // $FlowFixMe[method-unbinding]\n  const defaultMessage = `<unknown error: ${Object.prototype.toString.call(\n    err\n  )}>`;\n\n  if (!err) {\n    return defaultMessage;\n  }\n\n  if (err instanceof Error) {\n    return err.message || defaultMessage;\n  }\n\n  if (typeof err.message === \"string\") {\n    return err.message || defaultMessage;\n  }\n\n  return defaultMessage;\n}\n\nexport function stringify(item: mixed): string {\n  if (typeof item === \"string\") {\n    return item;\n  }\n\n  if (item && item.toString && typeof item.toString === \"function\") {\n    // $FlowFixMe\n    return item.toString();\n  }\n\n  // $FlowFixMe[method-unbinding]\n  return Object.prototype.toString.call(item);\n}\n\nexport function domainMatches(hostname: string, domain: string): boolean {\n  hostname = hostname.split(\"://\")[1];\n  const index = hostname.indexOf(domain);\n  return index !== -1 && hostname.slice(index) === domain;\n}\n\nexport function patchMethod(obj: Object, name: string, handler: Function) {\n  const original = obj[name];\n\n  obj[name] = function patchedMethod(): mixed {\n    return handler({\n      context: this,\n      // $FlowFixMe[method-unbinding]\n      args: Array.prototype.slice.call(arguments),\n      original,\n      callOriginal: () => original.apply(this, arguments),\n    });\n  };\n}\n\nexport function extend<T: Object | Function>(obj: T, source: Object): T {\n  if (!source) {\n    return obj;\n  }\n\n  if (Object.assign) {\n    return Object.assign(obj, source);\n  }\n\n  for (const key in source) {\n    if (source.hasOwnProperty(key)) {\n      obj[key] = source[key];\n    }\n  }\n\n  return obj;\n}\n\nexport function values<T>(obj: { [string]: T }): $ReadOnlyArray<T> {\n  if (Object.values) {\n    // $FlowFixMe\n    return Object.values(obj);\n  }\n\n  const result: Array<T> = [];\n  for (const key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      // $FlowFixMe[escaped-generic]\n      result.push(obj[key]);\n    }\n  }\n\n  // $FlowFixMe\n  return result;\n}\n\n// eslint-disable-next-line no-undef\nexport const memoizedValues: <T>({ [string]: T }) => $ReadOnlyArray<T> =\n  memoize(values);\n\nexport function perc(pixels: number, percentage: number): number {\n  return Math.round((pixels * percentage) / 100);\n}\n\nexport function min(...args: $ReadOnlyArray<number>): number {\n  return Math.min(...args);\n}\n\nexport function max(...args: $ReadOnlyArray<number>): number {\n  return Math.max(...args);\n}\n\nexport function roundUp(num: number, nearest: number): number {\n  const remainder = num % nearest;\n  return remainder ? num - remainder + nearest : num;\n}\n\nexport function regexMap<T>(\n  str: string,\n  regexp: RegExp,\n  handler: () => T\n): $ReadOnlyArray<T> {\n  const results = [];\n\n  // $FlowFixMe\n  str.replace(regexp, function regexMapMatcher(item) {\n    results.push(handler ? handler.apply(null, arguments) : item);\n  });\n\n  // $FlowFixMe\n  return results;\n}\n\nexport function svgToBase64(svg: string): string {\n  return `data:image/svg+xml;base64,${base64encode(svg)}`;\n}\n\nexport function objFilter<T, R>(\n  obj: { [string]: T },\n  filter?: (T, ?string) => mixed = Boolean\n): { [string]: R } {\n  const result = {};\n\n  for (const key in obj) {\n    if (!obj.hasOwnProperty(key) || !filter(obj[key], key)) {\n      continue;\n    }\n\n    result[key] = obj[key];\n  }\n\n  return result;\n}\n\nexport function identity<T>(item: T): T {\n  return item;\n}\n\nexport function regexTokenize(\n  text: string,\n  regexp: RegExp\n): $ReadOnlyArray<string> {\n  const result = [];\n  text.replace(regexp, (token) => {\n    result.push(token);\n    return \"\";\n  });\n  return result;\n}\n\nexport function promiseDebounce<T>(\n  method: () => ZalgoPromise<T> | T,\n  delay: number = 50\n): () => ZalgoPromise<T> {\n  let promise;\n  let timeout;\n\n  const promiseDebounced = function (): ZalgoPromise<T> {\n    if (timeout) {\n      clearTimeout(timeout);\n    }\n\n    const localPromise = (promise = promise || new ZalgoPromise());\n\n    timeout = setTimeout(() => {\n      promise = null;\n      timeout = null;\n\n      ZalgoPromise.try(method).then(\n        (result) => {\n          localPromise.resolve(result);\n        },\n        (err) => {\n          localPromise.reject(err);\n        }\n      );\n    }, delay);\n\n    return localPromise;\n  };\n\n  return setFunctionName(\n    promiseDebounced,\n    `${getFunctionName(method)}::promiseDebounced`\n  );\n}\n\nexport function safeInterval(\n  method: Function,\n  time: number\n): {| cancel: () => void |} {\n  let timeout;\n\n  function loop() {\n    timeout = setTimeout(() => {\n      method();\n      loop();\n    }, time);\n  }\n\n  loop();\n\n  return {\n    cancel() {\n      clearTimeout(timeout);\n    },\n  };\n}\n\nexport function isInteger(str: string): boolean {\n  return Boolean(str.match(/^[0-9]+$/));\n}\n\nexport function isFloat(str: string): boolean {\n  return Boolean(str.match(/^[0-9]+\\.[0-9]+$/));\n}\n\nexport function serializePrimitive(value: string | number | boolean): string {\n  return value.toString();\n}\n\nexport function deserializePrimitive(value: string): string | number | boolean {\n  if (value === \"true\") {\n    return true;\n  } else if (value === \"false\") {\n    return false;\n  } else if (isInteger(value)) {\n    return parseInt(value, 10);\n  } else if (isFloat(value)) {\n    return parseFloat(value);\n  } else {\n    return value;\n  }\n}\n\nexport function dotify(\n  obj: Object,\n  prefix: string = \"\",\n  newobj: Object = {}\n): { [string]: string } {\n  prefix = prefix ? `${prefix}.` : prefix;\n  for (const key in obj) {\n    if (\n      !obj.hasOwnProperty(key) ||\n      obj[key] === undefined ||\n      obj[key] === null ||\n      typeof obj[key] === \"function\"\n    ) {\n      continue;\n    } else if (\n      obj[key] &&\n      Array.isArray(obj[key]) &&\n      obj[key].length &&\n      obj[key].every((val) => typeof val !== \"object\")\n    ) {\n      newobj[`${prefix}${key}[]`] = obj[key].join(\",\");\n    } else if (obj[key] && typeof obj[key] === \"object\") {\n      newobj = dotify(obj[key], `${prefix}${key}`, newobj);\n    } else {\n      newobj[`${prefix}${key}`] = serializePrimitive(obj[key]);\n    }\n  }\n  return newobj;\n}\n\nexport function undotify(obj: { [string]: string }): Object {\n  const result = {};\n\n  for (let key in obj) {\n    if (!obj.hasOwnProperty(key) || typeof obj[key] !== \"string\") {\n      continue;\n    }\n\n    let value = obj[key];\n\n    if (key.match(/^.+\\[\\]$/)) {\n      key = key.slice(0, -2);\n      value = value.split(\",\").map(deserializePrimitive);\n    } else {\n      value = deserializePrimitive(value);\n    }\n\n    let keyResult = result;\n    const parts = key.split(\".\");\n    for (let i = 0; i < parts.length; i++) {\n      const part = parts[i];\n      const isLast = i + 1 === parts.length;\n      const isIndex = !isLast && isInteger(parts[i + 1]);\n\n      if (\n        part === \"constructor\" ||\n        part === \"prototype\" ||\n        part === \"__proto__\"\n      ) {\n        throw new Error(`Disallowed key: ${part}`);\n      }\n\n      if (isLast) {\n        // $FlowFixMe\n        keyResult[part] = value;\n      } else {\n        // $FlowFixMe\n        keyResult = keyResult[part] = keyResult[part] || (isIndex ? [] : {});\n      }\n    }\n  }\n\n  return result;\n}\n\nexport type EventEmitterType = {|\n  on: (eventName: string, handler: Function) => CancelableType,\n  once: (eventName: string, handler: Function) => CancelableType,\n  trigger: (\n    eventName: string,\n    ...args: $ReadOnlyArray<mixed>\n  ) => ZalgoPromise<void>,\n  triggerOnce: (\n    eventName: string,\n    ...args: $ReadOnlyArray<mixed>\n  ) => ZalgoPromise<void>,\n  reset: () => void,\n|};\n\nexport function eventEmitter(): EventEmitterType {\n  const triggered = {};\n  let handlers = {};\n\n  const emitter = {\n    on(eventName: string, handler: Function): CancelableType {\n      const handlerList = (handlers[eventName] = handlers[eventName] || []);\n\n      handlerList.push(handler);\n\n      let cancelled = false;\n\n      return {\n        cancel() {\n          if (!cancelled) {\n            cancelled = true;\n            handlerList.splice(handlerList.indexOf(handler), 1);\n          }\n        },\n      };\n    },\n\n    once(eventName: string, handler: Function): CancelableType {\n      const listener = emitter.on(eventName, () => {\n        listener.cancel();\n        handler();\n      });\n\n      return listener;\n    },\n\n    trigger(\n      eventName: string,\n      ...args: $ReadOnlyArray<mixed>\n    ): ZalgoPromise<void> {\n      const handlerList = handlers[eventName];\n      const promises = [];\n\n      if (handlerList) {\n        for (const handler of handlerList) {\n          promises.push(ZalgoPromise.try(() => handler(...args)));\n        }\n      }\n\n      return ZalgoPromise.all(promises).then(noop);\n    },\n\n    triggerOnce(\n      eventName: string,\n      ...args: $ReadOnlyArray<mixed>\n    ): ZalgoPromise<void> {\n      if (triggered[eventName]) {\n        return ZalgoPromise.resolve();\n      }\n\n      triggered[eventName] = true;\n      return emitter.trigger(eventName, ...args);\n    },\n\n    reset() {\n      handlers = {};\n    },\n  };\n\n  return emitter;\n}\n\nexport function camelToDasherize(string: string): string {\n  return string.replace(/([A-Z])/g, (g) => {\n    return `-${g.toLowerCase()}`;\n  });\n}\n\nexport function dasherizeToCamel(string: string): string {\n  return string.replace(/-([a-z])/g, (g) => {\n    return g[1].toUpperCase();\n  });\n}\n\nexport function capitalizeFirstLetter(string: string): string {\n  return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();\n}\n\nexport function get(item: Object, path: string, def: mixed): mixed {\n  if (!path) {\n    return def;\n  }\n\n  const pathParts = path.split(\".\");\n\n  // Loop through each section of our key path\n\n  for (let i = 0; i < pathParts.length; i++) {\n    // If we have an object, we can get the key\n    if (typeof item === \"object\" && item !== null) {\n      item = item[pathParts[i]];\n\n      // Otherwise, we should return the default (undefined if not provided)\n    } else {\n      return def;\n    }\n  }\n\n  // If our final result is undefined, we should return the default\n\n  return item === undefined ? def : item;\n}\n\nexport function safeTimeout(method: Function, time: number) {\n  const interval = safeInterval(() => {\n    time -= 100;\n    if (time <= 0) {\n      interval.cancel();\n      method();\n    }\n  }, 100);\n}\n\nexport function defineLazyProp<T>(\n  obj: Object | $ReadOnlyArray<mixed>,\n  key: string | number,\n  getter: () => T\n) {\n  if (Array.isArray(obj)) {\n    if (typeof key !== \"number\") {\n      throw new TypeError(`Array key must be number`);\n    }\n  } else if (typeof obj === \"object\" && obj !== null) {\n    if (typeof key !== \"string\") {\n      throw new TypeError(`Object key must be string`);\n    }\n  }\n\n  Object.defineProperty(obj, key, {\n    configurable: true,\n    enumerable: true,\n    get: () => {\n      // $FlowFixMe\n      delete obj[key];\n      const value = getter();\n      // $FlowFixMe\n      obj[key] = value;\n      return value;\n    },\n    set: (value: T) => {\n      // $FlowFixMe\n      delete obj[key];\n      // $FlowFixMe\n      obj[key] = value;\n    },\n  });\n}\n\n// eslint-disable-next-line no-undef\nexport function arrayFrom<T>(item: Iterable<T>): $ReadOnlyArray<T> {\n  // $FlowFixMe[method-unbinding]\n  return Array.prototype.slice.call(item);\n}\n\nexport function isObject(item: mixed): boolean {\n  return typeof item === \"object\" && item !== null;\n}\n\nexport function isObjectObject(obj: mixed): boolean {\n  return (\n    // $FlowFixMe[method-unbinding]\n    isObject(obj) && Object.prototype.toString.call(obj) === \"[object Object]\"\n  );\n}\n\nexport function isPlainObject(obj: mixed): boolean {\n  if (!isObjectObject(obj)) {\n    return false;\n  }\n\n  // $FlowFixMe\n  const constructor = obj.constructor;\n\n  if (typeof constructor !== \"function\") {\n    return false;\n  }\n\n  const prototype = constructor.prototype;\n\n  if (!isObjectObject(prototype)) {\n    return false;\n  }\n\n  if (!prototype.hasOwnProperty(\"isPrototypeOf\")) {\n    return false;\n  }\n\n  return true;\n}\n\nexport function replaceObject<T: $ReadOnlyArray<mixed> | Object>(\n  item: T,\n  replacer: (mixed, string | number, string) => mixed,\n  fullKey: string = \"\"\n): T {\n  if (Array.isArray(item)) {\n    const length = item.length;\n    const result: Array<mixed> = [];\n\n    for (let i = 0; i < length; i++) {\n      defineLazyProp(result, i, () => {\n        const itemKey = fullKey ? `${fullKey}.${i}` : `${i}`;\n        const el = item[i];\n\n        let child = replacer(el, i, itemKey);\n\n        if (isPlainObject(child) || Array.isArray(child)) {\n          // $FlowFixMe\n          child = replaceObject(child, replacer, itemKey);\n        }\n\n        return child;\n      });\n    }\n\n    // $FlowFixMe\n    return result;\n  } else if (isPlainObject(item)) {\n    const result = {};\n\n    for (const key in item) {\n      if (!item.hasOwnProperty(key)) {\n        continue;\n      }\n\n      defineLazyProp(result, key, () => {\n        const itemKey = fullKey ? `${fullKey}.${key}` : `${key}`;\n        // $FlowFixMe\n        const el = item[key];\n\n        let child = replacer(el, key, itemKey);\n\n        if (isPlainObject(child) || Array.isArray(child)) {\n          // $FlowFixMe\n          child = replaceObject(child, replacer, itemKey);\n        }\n\n        return child;\n      });\n    }\n\n    // $FlowFixMe\n    return result;\n  } else {\n    throw new Error(`Pass an object or array`);\n  }\n}\n\nexport function copyProp(\n  source: Object,\n  target: Object,\n  name: string,\n  def: mixed\n) {\n  if (source.hasOwnProperty(name)) {\n    const descriptor = Object.getOwnPropertyDescriptor(source, name);\n    // $FlowFixMe\n    Object.defineProperty(target, name, descriptor);\n  } else {\n    target[name] = def;\n  }\n}\n\ntype RegexResultType = {|\n  text: string,\n  groups: $ReadOnlyArray<string>,\n  start: number,\n  end: number,\n  length: number,\n  replace: (text: string) => string,\n|};\n\nexport function regex(\n  pattern: string | RegExp,\n  string: string,\n  start: number = 0\n): ?RegexResultType {\n  if (typeof pattern === \"string\") {\n    // eslint-disable-next-line security/detect-non-literal-regexp\n    pattern = new RegExp(pattern);\n  }\n\n  const result = string.slice(start).match(pattern);\n\n  if (!result) {\n    return;\n  }\n\n  // $FlowFixMe\n  const index: number = result.index;\n  const regmatch = result[0];\n\n  return {\n    text: regmatch,\n    groups: result.slice(1),\n    start: start + index,\n    end: start + index + regmatch.length,\n    length: regmatch.length,\n\n    replace(text: string): string {\n      if (!regmatch) {\n        return \"\";\n      }\n\n      return `${regmatch.slice(0, start + index)}${text}${regmatch.slice(\n        index + regmatch.length\n      )}`;\n    },\n  };\n}\n\nexport function regexAll(\n  pattern: string | RegExp,\n  string: string\n): $ReadOnlyArray<RegexResultType> {\n  const matches = [];\n  let start = 0;\n\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    const regmatch = regex(pattern, string, start);\n\n    if (!regmatch) {\n      break;\n    }\n\n    matches.push(regmatch);\n    start = match.end;\n  }\n\n  return matches;\n}\n\nexport function isDefined(value: ?mixed): boolean {\n  return value !== null && value !== undefined;\n}\n\nexport function cycle(method: Function): ZalgoPromise<void> {\n  return ZalgoPromise.try(method).then(() => cycle(method));\n}\n\nexport function debounce<T>(\n  method: (...args: $ReadOnlyArray<mixed>) => T,\n  time: number = 100\n): (...args: $ReadOnlyArray<mixed>) => void {\n  let timeout;\n\n  const debounceWrapper = function () {\n    clearTimeout(timeout);\n\n    timeout = setTimeout(() => {\n      return method.apply(this, arguments);\n    }, time);\n  };\n\n  return setFunctionName(\n    debounceWrapper,\n    `${getFunctionName(method)}::debounced`\n  );\n}\n\nexport function isRegex(item: mixed): boolean {\n  // $FlowFixMe[method-unbinding]\n  return Object.prototype.toString.call(item) === \"[object RegExp]\";\n}\n\ntype FunctionProxy<T: Function> = (method: T) => T;\n\nexport const weakMapMemoize: FunctionProxy<*> = <R: mixed>(\n  // eslint-disable-next-line flowtype/no-weak-types\n  method: (arg: any) => R\n  // eslint-disable-next-line flowtype/no-weak-types\n): ((...args: $ReadOnlyArray<any>) => R) => {\n  const weakmap = new WeakMap();\n\n  // eslint-disable-next-line flowtype/no-weak-types\n  return function weakmapMemoized(arg: any): R {\n    return weakmap.getOrSet(arg, () => method.call(this, arg));\n  };\n};\n\ntype FunctionPromiseProxy<\n  R: mixed,\n  T: (...args: $ReadOnlyArray<mixed>) => ZalgoPromise<R>\n> = (T) => T;\n\nexport const weakMapMemoizePromise: FunctionPromiseProxy<*, *> = <R: mixed>(\n  // eslint-disable-next-line flowtype/no-weak-types\n  method: (arg: any) => ZalgoPromise<R>\n  // eslint-disable-next-line flowtype/no-weak-types\n): ((...args: $ReadOnlyArray<any>) => ZalgoPromise<R>) => {\n  const weakmap = new WeakMap();\n\n  // eslint-disable-next-line flowtype/no-weak-types\n  return function weakmapMemoizedPromise(arg: any): ZalgoPromise<R> {\n    return weakmap.getOrSet(arg, () =>\n      method.call(this, arg).finally(() => {\n        weakmap.delete(arg);\n      })\n    );\n  };\n};\n\nexport function getOrSet<O: Object, T: mixed>(\n  obj: O,\n  key: string,\n  getter: () => T\n): T {\n  if (obj.hasOwnProperty(key)) {\n    return obj[key];\n  }\n\n  const val = getter();\n  obj[key] = val;\n  return val;\n}\n\nexport type CleanupType = {|\n  set: <T: mixed>(string, T) => T, // eslint-disable-line no-undef\n  register: (Function) => {| cancel: () => void |},\n  all: (err?: mixed) => ZalgoPromise<void>,\n|};\n\nexport function cleanup(obj: Object): CleanupType {\n  const tasks = [];\n  let cleaned = false;\n  let cleanErr;\n\n  const cleaner = {\n    set<T: mixed>(name: string, item: T): T {\n      if (!cleaned) {\n        obj[name] = item;\n        cleaner.register(() => {\n          delete obj[name];\n        });\n      }\n      return item;\n    },\n\n    register(method: Function): {| cancel: () => void |} {\n      const task = once(() => method(cleanErr));\n\n      if (cleaned) {\n        method(cleanErr);\n      } else {\n        tasks.push(task);\n      }\n\n      return {\n        cancel: () => {\n          const index = tasks.indexOf(task);\n          if (index !== -1) {\n            tasks.splice(index, 1);\n          }\n        },\n      };\n    },\n\n    all(err?: mixed): ZalgoPromise<void> {\n      cleanErr = err;\n\n      const results = [];\n      cleaned = true;\n\n      while (tasks.length) {\n        const task = tasks.shift();\n        results.push(task());\n      }\n\n      return ZalgoPromise.all(results).then(noop);\n    },\n  };\n\n  return cleaner;\n}\n\nexport function tryCatch<T>(\n  fn: () => T\n): {| result: T, error: void |} | {| result: void, error: mixed |} {\n  let result;\n  let error;\n\n  try {\n    result = fn();\n  } catch (err) {\n    error = err;\n  }\n\n  // $FlowFixMe\n  return { result, error };\n}\n\n// eslint-disable-next-line flowtype/no-mutable-array\nexport function removeFromArray<X, T: Array<X>>(arr: T, item: X) {\n  const index = arr.indexOf(item);\n  if (index !== -1) {\n    arr.splice(index, 1);\n  }\n}\n\nexport function assertExists<T>(name: string, thing: void | null | T): T {\n  if (thing === null || typeof thing === \"undefined\") {\n    throw new Error(`Expected ${name} to be present`);\n  }\n\n  return thing;\n}\n\nexport function unique(arr: $ReadOnlyArray<string>): $ReadOnlyArray<string> {\n  const result = {};\n  for (const item of arr) {\n    result[item] = true;\n  }\n  return Object.keys(result);\n}\n\nexport const constHas = <X: string | boolean | number, T: { [string]: X }>(\n  constant: T,\n  value: X\n): boolean => {\n  return memoizedValues(constant).indexOf(value) !== -1;\n};\n\nexport function dedupeErrors<T>(handler: (mixed) => T): (mixed) => T | void {\n  const seenErrors = [];\n  const seenStringifiedErrors = {};\n\n  return (err) => {\n    if (seenErrors.indexOf(err) !== -1) {\n      return;\n    }\n\n    seenErrors.push(err);\n\n    const stringifiedError = stringifyError(err);\n    if (seenStringifiedErrors[stringifiedError]) {\n      return;\n    }\n\n    seenStringifiedErrors[stringifiedError] = true;\n    return handler(err);\n  };\n}\n\nexport class ExtendableError extends Error {\n  constructor(message: string) {\n    super(message);\n    // eslint-disable-next-line unicorn/custom-error-definition\n    this.name = this.constructor.name;\n    if (typeof Error.captureStackTrace === \"function\") {\n      Error.captureStackTrace(this, this.constructor);\n    } else {\n      this.stack = new Error(message).stack;\n    }\n  }\n}\n\nfunction isRelativeUrlWithoutProtocol(url: string): boolean {\n  return relativeFirstCharacters.indexOf(url[0]) > -1;\n}\n\nfunction decodeHtmlCharacters(str: string): string {\n  const removedNullByte: string = str.replace(ctrlCharactersRegex, \"\");\n  return removedNullByte.replace(htmlEntitiesRegex, (matchRegex, dec) => {\n    return String.fromCharCode(dec);\n  });\n}\n\nexport function sanitizeUrl(url?: string): string {\n  if (!url) {\n    return BLANK_URL;\n  }\n\n  const sanitizedUrl = decodeHtmlCharacters(url)\n    .replace(htmlCtrlEntityRegex, \"\")\n    .replace(ctrlCharactersRegex, \"\")\n    .trim();\n\n  if (!sanitizedUrl) {\n    return BLANK_URL;\n  }\n\n  if (isRelativeUrlWithoutProtocol(sanitizedUrl)) {\n    return sanitizedUrl;\n  }\n\n  const urlSchemeParseResults = sanitizedUrl.match(urlSchemeRegex);\n\n  if (!urlSchemeParseResults) {\n    return sanitizedUrl;\n  }\n\n  const urlScheme = urlSchemeParseResults[0];\n\n  if (invalidProtocolRegex.test(urlScheme)) {\n    return BLANK_URL;\n  }\n\n  return sanitizedUrl;\n}\n","/* @flow */\n\nexport function hasNativeWeakMap() : boolean {\n\n    if (typeof WeakMap === 'undefined') {\n        return false;\n    }\n\n    if (typeof Object.freeze === 'undefined') {\n        return false;\n    }\n\n    try {\n\n        const testWeakMap = new WeakMap();\n        const testKey = {};\n        const testValue = '__testvalue__';\n\n        Object.freeze(testKey);\n\n        testWeakMap.set(testKey, testValue);\n\n        if (testWeakMap.get(testKey) === testValue) {\n            return true;\n        }\n\n        return false;\n\n    } catch (err) {\n\n        return false;\n    }\n}\n","export default function _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}","export default function _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}","import setPrototypeOf from \"@babel/runtime/helpers/esm/setPrototypeOf\";\nimport isNativeReflectConstruct from \"@babel/runtime/helpers/esm/isNativeReflectConstruct\";\nexport default function _construct(Parent, args, Class) {\n  if (isNativeReflectConstruct()) {\n    _construct = Reflect.construct;\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n\n  return _construct.apply(null, arguments);\n}","import getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport setPrototypeOf from \"@babel/runtime/helpers/esm/setPrototypeOf\";\nimport isNativeFunction from \"@babel/runtime/helpers/esm/isNativeFunction\";\nimport construct from \"@babel/runtime/helpers/esm/construct\";\nexport default function _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n\n  _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !isNativeFunction(Class)) return Class;\n\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n\n      _cache.set(Class, Wrapper);\n    }\n\n    function Wrapper() {\n      return construct(Class, arguments, getPrototypeOf(this).constructor);\n    }\n\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return setPrototypeOf(Wrapper, Class);\n  };\n\n  return _wrapNativeSuper(Class);\n}","export default function _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}","/* @flow */\n/* eslint max-lines: off */\nimport { ZalgoPromise } from \"@krakenjs/zalgo-promise/src\";\nimport {\n  linkFrameWindow,\n  isWindowClosed,\n  assertSameDomain,\n  type SameDomainWindowType,\n  type CrossDomainWindowType,\n} from \"@krakenjs/cross-domain-utils/src\";\nimport { WeakMap } from \"@krakenjs/cross-domain-safe-weakmap/src\";\n\nimport {\n  isElement,\n  inlineMemoize,\n  memoize,\n  noop,\n  stringify,\n  capitalizeFirstLetter,\n  once,\n  extend,\n  safeInterval,\n  uniqueID,\n  arrayFrom,\n  ExtendableError,\n  strHashStr,\n} from \"./util\";\nimport { isDevice } from \"./device\";\nimport { KEY_CODES, ATTRIBUTES, UID_HASH_LENGTH } from \"./constants\";\nimport type { CancelableType } from \"./types\";\n\ntype ElementRefType = string | HTMLElement;\n\nexport function getBody(): HTMLBodyElement {\n  // eslint-disable-next-line compat/compat\n  const body = document.body;\n\n  if (!body) {\n    throw new Error(`Body element not found`);\n  }\n\n  return body;\n}\n\nexport function isDocumentReady(): boolean {\n  // eslint-disable-next-line compat/compat\n  return Boolean(document.body) && document.readyState === \"complete\";\n}\n\nexport function isDocumentInteractive(): boolean {\n  // eslint-disable-next-line compat/compat\n  return Boolean(document.body) && document.readyState === \"interactive\";\n}\n\nexport function urlEncode(str: string): string {\n  return encodeURIComponent(str);\n}\n\nexport function waitForWindowReady(): ZalgoPromise<void> {\n  return inlineMemoize(waitForWindowReady, (): ZalgoPromise<void> => {\n    return new ZalgoPromise((resolve) => {\n      if (isDocumentReady()) {\n        resolve();\n      }\n\n      window.addEventListener(\"load\", () => resolve());\n    });\n  });\n}\n\ntype WaitForDocumentReady = () => ZalgoPromise<void>;\n\nexport const waitForDocumentReady: WaitForDocumentReady = memoize(() => {\n  return new ZalgoPromise((resolve) => {\n    if (isDocumentReady() || isDocumentInteractive()) {\n      return resolve();\n    }\n\n    const interval = setInterval(() => {\n      if (isDocumentReady() || isDocumentInteractive()) {\n        clearInterval(interval);\n        return resolve();\n      }\n    }, 10);\n  });\n});\n\nexport function waitForDocumentBody(): ZalgoPromise<HTMLBodyElement> {\n  return ZalgoPromise.try(() => {\n    if (document.body) {\n      return document.body;\n    }\n\n    return waitForDocumentReady().then(() => {\n      if (document.body) {\n        return document.body;\n      }\n\n      throw new Error(\"Document ready but document.body not present\");\n    });\n  });\n}\n\nexport function parseQuery(queryString: string): Object {\n  return inlineMemoize(\n    parseQuery,\n    (): Object => {\n      const params = {};\n\n      if (!queryString) {\n        return params;\n      }\n\n      if (queryString.indexOf(\"=\") === -1) {\n        return params;\n      }\n\n      for (let pair of queryString.split(\"&\")) {\n        pair = pair.split(\"=\");\n\n        if (pair[0] && pair[1]) {\n          params[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);\n        }\n      }\n\n      return params;\n    },\n    [queryString]\n  );\n}\n\nexport function getQueryParam(name: string): string {\n  return parseQuery(window.location.search.slice(1))[name];\n}\n\nexport function urlWillRedirectPage(url: string): boolean {\n  if (url.indexOf(\"#\") === -1) {\n    return true;\n  }\n\n  if (url.indexOf(\"#\") === 0) {\n    return false;\n  }\n\n  if (url.split(\"#\")[0] === window.location.href.split(\"#\")[0]) {\n    return false;\n  }\n\n  return true;\n}\n\nexport type Query = {\n  [string]: boolean | string,\n};\n\nexport function formatQuery(obj: Query = {}): string {\n  return Object.keys(obj)\n    .filter((key) => {\n      return typeof obj[key] === \"string\" || typeof obj[key] === \"boolean\";\n    })\n    .map((key) => {\n      const val = obj[key];\n\n      if (typeof val !== \"string\" && typeof val !== \"boolean\") {\n        throw new TypeError(`Invalid type for query`);\n      }\n\n      return `${urlEncode(key)}=${urlEncode(val.toString())}`;\n    })\n    .join(\"&\");\n}\n\nexport function extendQuery(originalQuery: string, props: Query = {}): string {\n  if (!props || !Object.keys(props).length) {\n    return originalQuery;\n  }\n\n  return formatQuery({\n    ...parseQuery(originalQuery),\n    ...props,\n  });\n}\n\nexport function extendUrl(\n  url: string,\n  options: {| query?: Query, hash?: Query |}\n): string {\n  const query = options.query || {};\n  const hash = options.hash || {};\n\n  let originalUrl;\n  let originalQuery;\n  let originalHash;\n\n  [originalUrl, originalHash] = url.split(\"#\");\n  [originalUrl, originalQuery] = originalUrl.split(\"?\");\n\n  const queryString = extendQuery(originalQuery, query);\n  const hashString = extendQuery(originalHash, hash);\n\n  if (queryString) {\n    originalUrl = `${originalUrl}?${queryString}`;\n  }\n\n  if (hashString) {\n    originalUrl = `${originalUrl}#${hashString}`;\n  }\n\n  return originalUrl;\n}\n\nexport function redirect(\n  url: string,\n  win: CrossDomainWindowType = window\n): ZalgoPromise<void> {\n  return new ZalgoPromise((resolve) => {\n    win.location = url;\n    if (!urlWillRedirectPage(url)) {\n      resolve();\n    }\n  });\n}\n\nexport function hasMetaViewPort(): boolean {\n  const meta = document.querySelector(\"meta[name=viewport]\");\n\n  if (isDevice() && window.screen.width < 660 && !meta) {\n    return false;\n  }\n\n  return true;\n}\n\nexport function isElementVisible(el: HTMLElement): boolean {\n  return Boolean(\n    el.offsetWidth || el.offsetHeight || el.getClientRects().length\n  );\n}\n\nexport function getPerformance(): ?Performance {\n  return inlineMemoize(getPerformance, (): ?Performance => {\n    const performance = window.performance;\n\n    if (\n      performance &&\n      performance.now &&\n      performance.timing &&\n      performance.timing.connectEnd &&\n      performance.timing.navigationStart &&\n      Math.abs(performance.now() - Date.now()) > 1000 &&\n      performance.now() -\n        (performance.timing.connectEnd - performance.timing.navigationStart) >\n        0\n    ) {\n      return performance;\n    }\n  });\n}\n\nexport function enablePerformance(): boolean {\n  return Boolean(getPerformance());\n}\n\nexport function getPageRenderTime(): ZalgoPromise<?number> {\n  return waitForDocumentReady().then(() => {\n    const performance = getPerformance();\n\n    if (!performance) {\n      return;\n    }\n\n    const timing = performance.timing;\n\n    if (timing.connectEnd && timing.domInteractive) {\n      return timing.domInteractive - timing.connectEnd;\n    }\n  });\n}\n\nexport function htmlEncode(html: string = \"\"): string {\n  return html\n    .toString()\n    .replace(/&/g, \"&amp;\")\n    .replace(/</g, \"&lt;\")\n    .replace(/>/g, \"&gt;\")\n    .replace(/\"/g, \"&quot;\")\n    .replace(/'/g, \"&#39;\")\n    .replace(/\\//g, \"&#x2F;\");\n}\n\nexport function isBrowser(): boolean {\n  return typeof window !== \"undefined\" && window.location !== undefined;\n}\n\nexport function querySelectorAll(\n  selector: string,\n  doc: HTMLElement = window.document\n): $ReadOnlyArray<HTMLElement> {\n  // $FlowFixMe[method-unbinding]\n  return Array.prototype.slice.call(doc.querySelectorAll(selector));\n}\n\n/**\n * Sets up event handlers for click events and\n * enter/space keypresses.\n * @callback handler\n * @param {HTMLElement} element\n * @param {handler} handler\n */\nexport function onClick(element: HTMLElement, handler: (Event) => void) {\n  element.addEventListener(\"touchstart\", noop, { passive: true });\n  element.addEventListener(\"click\", handler);\n  element.addEventListener(\"keypress\", (event: Event) => {\n    if (\n      // $FlowFixMe\n      event.keyCode === KEY_CODES.ENTER ||\n      // $FlowFixMe\n      event.keyCode === KEY_CODES.SPACE\n    ) {\n      return handler(event);\n    }\n  });\n}\n\nexport function getScript({\n  host = window.location.host,\n  path,\n  reverse = false,\n}: {|\n  host?: string,\n  path: string,\n  reverse?: boolean,\n|}): ?HTMLScriptElement {\n  return inlineMemoize(\n    getScript,\n    (): ?HTMLScriptElement => {\n      const url = `${host}${path}`;\n      // $FlowFixMe[method-unbinding]\n      const scripts = Array.prototype.slice.call(\n        document.getElementsByTagName(\"script\")\n      );\n\n      if (reverse) {\n        scripts.reverse();\n      }\n\n      for (const script of scripts) {\n        if (!script.src) {\n          continue;\n        }\n\n        const src = script.src.replace(/^https?:\\/\\//, \"\").split(\"?\")[0];\n\n        if (src === url) {\n          return script;\n        }\n      }\n    },\n    [path]\n  );\n}\n\nexport function isLocalStorageEnabled(): boolean {\n  return inlineMemoize(isLocalStorageEnabled, () => {\n    try {\n      if (typeof window === \"undefined\") {\n        return false;\n      }\n\n      if (window.localStorage) {\n        const value = Math.random().toString();\n        window.localStorage.setItem(\"__test__localStorage__\", value);\n        const result = window.localStorage.getItem(\"__test__localStorage__\");\n        window.localStorage.removeItem(\"__test__localStorage__\");\n        if (value === result) {\n          return true;\n        }\n      }\n    } catch (err) {\n      // pass\n    }\n    return false;\n  });\n}\n\nexport function getBrowserLocales(): $ReadOnlyArray<{|\n  country?: string,\n  lang: string,\n|}> {\n  const nav = window.navigator;\n\n  const locales = nav.languages ? [...nav.languages] : [];\n\n  if (nav.language) {\n    locales.push(nav.language);\n  }\n\n  if (nav.userLanguage) {\n    locales.push(nav.userLanguage);\n  }\n\n  return locales\n    .map((locale) => {\n      if (locale && locale.match(/^[a-z]{2}[-_][A-Z]{2}$/)) {\n        const [lang, country] = locale.split(/[-_]/);\n        return { country, lang };\n      }\n\n      if (locale && locale.match(/^[a-z]{2}$/)) {\n        return { lang: locale };\n      }\n\n      return null;\n    })\n    .filter(Boolean);\n}\n\nexport function appendChild(container: HTMLElement, child: HTMLElement | Text) {\n  container.appendChild(child);\n}\n\nexport function getElementSafe(\n  id: ElementRefType,\n  doc: Document | HTMLElement = document\n): ?HTMLElement {\n  if (isElement(id)) {\n    // $FlowFixMe\n    return id;\n  }\n\n  if (typeof id === \"string\") {\n    return doc.querySelector(id);\n  }\n}\n\nexport function getElement(\n  id: ElementRefType,\n  doc: Document | HTMLElement = document\n): HTMLElement {\n  const element = getElementSafe(id, doc);\n\n  if (element) {\n    return element;\n  }\n\n  throw new Error(`Can not find element: ${stringify(id)}`);\n}\n\nexport function elementReady(id: ElementRefType): ZalgoPromise<HTMLElement> {\n  return new ZalgoPromise((resolve, reject) => {\n    const name = stringify(id);\n    let el = getElementSafe(id);\n\n    if (el) {\n      return resolve(el);\n    }\n\n    if (isDocumentReady()) {\n      return reject(\n        new Error(`Document is ready and element ${name} does not exist`)\n      );\n    }\n\n    const interval = setInterval(() => {\n      el = getElementSafe(id);\n\n      if (el) {\n        resolve(el);\n        clearInterval(interval);\n        return;\n      }\n\n      if (isDocumentReady()) {\n        clearInterval(interval);\n        return reject(\n          new Error(`Document is ready and element ${name} does not exist`)\n        );\n      }\n    }, 10);\n  });\n}\n\n// eslint-disable-next-line unicorn/custom-error-definition\nexport class PopupOpenError extends ExtendableError {}\n\ntype PopupOptions = {|\n  name?: string,\n  width?: number,\n  height?: number,\n  top?: number,\n  left?: number,\n  status?: 0 | 1,\n  resizable?: 0 | 1,\n  toolbar?: 0 | 1,\n  menubar?: 0 | 1,\n  scrollbars?: 0 | 1,\n  closeOnUnload?: 0 | 1,\n|};\n\nexport function popup(\n  url: string,\n  options?: PopupOptions\n): CrossDomainWindowType {\n  // $FlowFixMe\n  options = options || {};\n\n  const { closeOnUnload = 1, name = \"\", width, height } = options;\n\n  let top = 0;\n  let left = 0;\n\n  if (width) {\n    if (window.outerWidth) {\n      left = Math.round((window.outerWidth - width) / 2) + window.screenX;\n    } else if (window.screen.width) {\n      left = Math.round((window.screen.width - width) / 2);\n    }\n  }\n\n  if (height) {\n    if (window.outerHeight) {\n      top = Math.round((window.outerHeight - height) / 2) + window.screenY;\n    } else if (window.screen.height) {\n      top = Math.round((window.screen.height - height) / 2);\n    }\n  }\n\n  delete options.closeOnUnload;\n  delete options.name;\n\n  if (width && height) {\n    // $FlowFixMe\n    options = {\n      top,\n      left,\n      width,\n      height,\n      status: 1,\n      toolbar: 0,\n      menubar: 0,\n      resizable: 1,\n      scrollbars: 1,\n      ...options,\n    };\n  }\n\n  const params = Object.keys(options)\n    // eslint-disable-next-line array-callback-return\n    .map((key) => {\n      // $FlowFixMe\n      if (options[key] !== null && options[key] !== undefined) {\n        return `${key}=${stringify(options[key])}`;\n      }\n    })\n    .filter(Boolean)\n    .join(\",\");\n\n  let win;\n\n  try {\n    win = window.open(url, name, params);\n  } catch (err) {\n    throw new PopupOpenError(\n      `Can not open popup window - ${err.stack || err.message}`\n    );\n  }\n\n  if (isWindowClosed(win)) {\n    const err = new PopupOpenError(`Can not open popup window - blocked`);\n    throw err;\n  }\n\n  if (closeOnUnload) {\n    window.addEventListener(\"unload\", () => win.close());\n  }\n\n  return win;\n}\n\nexport function writeToWindow(win: SameDomainWindowType, html: string) {\n  try {\n    win.document.open();\n    win.document.write(html);\n    win.document.close();\n  } catch (err) {\n    try {\n      win.location = `javascript: document.open(); document.write(${JSON.stringify(\n        html\n      )}); document.close();`;\n    } catch (err2) {\n      // pass\n    }\n  }\n}\n\nexport function writeElementToWindow(\n  win: SameDomainWindowType,\n  el: HTMLElement\n) {\n  const tag = el.tagName.toLowerCase();\n\n  if (tag !== \"html\") {\n    throw new Error(`Expected element to be html, got ${tag}`);\n  }\n\n  const documentElement = win.document.documentElement;\n\n  for (const child of arrayFrom(documentElement.children)) {\n    documentElement.removeChild(child);\n  }\n\n  for (const child of arrayFrom(el.children)) {\n    documentElement.appendChild(child);\n  }\n}\n\nexport function setStyle(\n  el: HTMLElement,\n  styleText: string,\n  doc: Document = window.document\n) {\n  // $FlowFixMe\n  if (el.styleSheet) {\n    // $FlowFixMe\n    el.styleSheet.cssText = styleText;\n  } else {\n    el.appendChild(doc.createTextNode(styleText));\n  }\n}\n\nexport type ElementOptionsType = {|\n  style?: { [string]: string },\n  id?: string,\n  class?: ?$ReadOnlyArray<string>,\n  attributes?: { [string]: string },\n  styleSheet?: ?string,\n  html?: ?string,\n|};\n\nlet awaitFrameLoadPromises: WeakMap<\n  HTMLIFrameElement,\n  ZalgoPromise<HTMLIFrameElement>\n>;\n\nexport function awaitFrameLoad(\n  frame: HTMLIFrameElement\n): ZalgoPromise<HTMLIFrameElement> {\n  awaitFrameLoadPromises = awaitFrameLoadPromises || new WeakMap();\n\n  if (awaitFrameLoadPromises.has(frame)) {\n    const promise = awaitFrameLoadPromises.get(frame);\n    if (promise) {\n      return promise;\n    }\n  }\n\n  const promise = new ZalgoPromise((resolve, reject) => {\n    frame.addEventListener(\"load\", () => {\n      linkFrameWindow(frame);\n      resolve(frame);\n    });\n\n    frame.addEventListener(\"error\", (err: Event) => {\n      if (frame.contentWindow) {\n        resolve(frame);\n      } else {\n        reject(err);\n      }\n    });\n  });\n\n  awaitFrameLoadPromises.set(frame, promise);\n\n  return promise;\n}\n\nexport function awaitFrameWindow(\n  frame: HTMLIFrameElement\n): ZalgoPromise<CrossDomainWindowType> {\n  return awaitFrameLoad(frame).then((loadedFrame) => {\n    if (!loadedFrame.contentWindow) {\n      throw new Error(`Could not find window in iframe`);\n    }\n\n    return loadedFrame.contentWindow;\n  });\n}\n\nconst getDefaultCreateElementOptions = (): ElementOptionsType => {\n  // $FlowFixMe\n  return {};\n};\n\nexport function createElement(\n  tag: string = \"div\",\n  options: ElementOptionsType = getDefaultCreateElementOptions(),\n  container: ?HTMLElement\n): HTMLElement {\n  tag = tag.toLowerCase();\n  const element = document.createElement(tag);\n\n  if (options.style) {\n    extend(element.style, options.style);\n  }\n\n  if (options.class) {\n    element.className = options.class.join(\" \");\n  }\n\n  if (options.id) {\n    element.setAttribute(\"id\", options.id);\n  }\n\n  if (options.attributes) {\n    for (const key of Object.keys(options.attributes)) {\n      element.setAttribute(key, options.attributes[key]);\n    }\n  }\n\n  if (options.styleSheet) {\n    setStyle(element, options.styleSheet);\n  }\n\n  if (container) {\n    appendChild(container, element);\n  }\n\n  if (options.html) {\n    if (tag === \"iframe\") {\n      // $FlowFixMe\n      if (!container || !element.contentWindow) {\n        throw new Error(\n          `Iframe html can not be written unless container provided and iframe in DOM`\n        );\n      }\n\n      // $FlowFixMe\n      writeToWindow(element.contentWindow, options.html);\n    } else {\n      element.innerHTML = options.html;\n    }\n  }\n\n  return element;\n}\n\ntype StringMap = {|\n  [string]: string,\n|};\n\nexport type IframeElementOptionsType = {|\n  style?: StringMap,\n  class?: ?$ReadOnlyArray<string>,\n  attributes?: StringMap,\n  styleSheet?: ?string,\n  html?: ?string,\n  url?: ?string,\n|};\n\nconst getDefaultIframeOptions = (): IframeElementOptionsType => {\n  // $FlowFixMe\n  return {};\n};\n\nconst getDefaultStringMap = (): StringMap => {\n  // $FlowFixMe\n  return {};\n};\n\nexport function iframe(\n  options: IframeElementOptionsType = getDefaultIframeOptions(),\n  container: ?HTMLElement\n): HTMLIFrameElement {\n  const attributes = options.attributes || getDefaultStringMap();\n  const style = options.style || getDefaultStringMap();\n\n  // $FlowFixMe\n  const newAttributes = {\n    allowTransparency: \"true\",\n    ...attributes,\n  };\n\n  // $FlowFixMe\n  const newStyle = {\n    backgroundColor: \"transparent\",\n    border: \"none\",\n    ...style,\n  };\n\n  const frame = createElement(\"iframe\", {\n    attributes: newAttributes,\n    style: newStyle,\n    html: options.html,\n    class: options.class,\n  });\n\n  const isIE = window.navigator.userAgent.match(/MSIE|Edge/i);\n\n  if (!frame.hasAttribute(\"id\")) {\n    frame.setAttribute(\"id\", uniqueID());\n  }\n\n  // $FlowFixMe\n  awaitFrameLoad(frame);\n\n  if (container) {\n    const el = getElement(container);\n    el.appendChild(frame);\n  }\n\n  if (options.url || isIE) {\n    frame.setAttribute(\"src\", options.url || \"about:blank\");\n  }\n\n  // $FlowFixMe\n  return frame;\n}\n\nexport function addEventListener(\n  obj: HTMLElement,\n  event: string,\n  handler: (event: Event) => void\n): CancelableType {\n  obj.addEventListener(event, handler);\n  return {\n    cancel() {\n      obj.removeEventListener(event, handler);\n    },\n  };\n}\n\nexport function bindEvents(\n  element: HTMLElement,\n  eventNames: $ReadOnlyArray<string>,\n  handler: (event: Event) => void\n): CancelableType {\n  handler = once(handler);\n\n  for (const eventName of eventNames) {\n    element.addEventListener(eventName, handler);\n  }\n\n  return {\n    cancel: once(() => {\n      for (const eventName of eventNames) {\n        element.removeEventListener(eventName, handler);\n      }\n    }),\n  };\n}\n\nconst VENDOR_PREFIXES = [\"webkit\", \"moz\", \"ms\", \"o\"];\n\nexport function setVendorCSS(\n  element: HTMLElement,\n  name: string,\n  value: string\n) {\n  // $FlowFixMe\n  element.style[name] = value;\n\n  const capitalizedName = capitalizeFirstLetter(name);\n\n  for (const prefix of VENDOR_PREFIXES) {\n    // $FlowFixMe\n    element.style[`${prefix}${capitalizedName}`] = value;\n  }\n}\n\nconst ANIMATION_START_EVENTS = [\n  \"animationstart\",\n  \"webkitAnimationStart\",\n  \"oAnimationStart\",\n  \"MSAnimationStart\",\n];\nconst ANIMATION_END_EVENTS = [\n  \"animationend\",\n  \"webkitAnimationEnd\",\n  \"oAnimationEnd\",\n  \"MSAnimationEnd\",\n];\n\nexport function animate(\n  element: ElementRefType,\n  name: string,\n  clean: (Function) => void,\n  timeout: number = 1000\n): ZalgoPromise<void> {\n  return new ZalgoPromise((resolve, reject) => {\n    const el = getElement(element);\n\n    if (!el) {\n      return resolve();\n    }\n\n    let hasStarted = false;\n\n    // eslint-disable-next-line prefer-const\n    let startTimeout;\n    let endTimeout;\n    // eslint-disable-next-line prefer-const\n    let startEvent;\n    // eslint-disable-next-line prefer-const\n    let endEvent;\n\n    function cleanUp() {\n      clearTimeout(startTimeout);\n      clearTimeout(endTimeout);\n      startEvent.cancel();\n      endEvent.cancel();\n    }\n\n    startEvent = bindEvents(el, ANIMATION_START_EVENTS, (event) => {\n      // $FlowFixMe\n      if (event.target !== el || event.animationName !== name) {\n        return;\n      }\n\n      clearTimeout(startTimeout);\n\n      event.stopPropagation();\n\n      startEvent.cancel();\n      hasStarted = true;\n\n      endTimeout = setTimeout(() => {\n        cleanUp();\n        resolve();\n      }, timeout);\n    });\n\n    endEvent = bindEvents(el, ANIMATION_END_EVENTS, (event) => {\n      // $FlowFixMe\n      if (event.target !== el || event.animationName !== name) {\n        return;\n      }\n\n      cleanUp();\n\n      if (\n        // $FlowFixMe\n        typeof event.animationName === \"string\" &&\n        event.animationName !== name\n      ) {\n        return reject(\n          `Expected animation name to be ${name}, found ${event.animationName}`\n        );\n      }\n\n      return resolve();\n    });\n\n    setVendorCSS(el, \"animationName\", name);\n\n    startTimeout = setTimeout(() => {\n      if (!hasStarted) {\n        cleanUp();\n        return resolve();\n      }\n    }, 200);\n\n    if (clean) {\n      clean(cleanUp);\n    }\n  });\n}\n\nexport function makeElementVisible(element: HTMLElement) {\n  element.style.setProperty(\"visibility\", \"\");\n}\n\nexport function makeElementInvisible(element: HTMLElement) {\n  element.style.setProperty(\"visibility\", \"hidden\", \"important\");\n}\n\nexport function showElement(element: HTMLElement) {\n  element.style.setProperty(\"display\", \"\");\n}\n\nexport function hideElement(element: HTMLElement) {\n  element.style.setProperty(\"display\", \"none\", \"important\");\n}\n\nexport function destroyElement(element: HTMLElement) {\n  if (element && element.parentNode) {\n    element.parentNode.removeChild(element);\n  }\n}\n\nexport function showAndAnimate(\n  element: HTMLElement,\n  name: string,\n  clean: (Function) => void\n): ZalgoPromise<void> {\n  const animation = animate(element, name, clean);\n  showElement(element);\n  return animation;\n}\n\nexport function animateAndHide(\n  element: HTMLElement,\n  name: string,\n  clean: (Function) => void\n): ZalgoPromise<void> {\n  return animate(element, name, clean).then(() => {\n    hideElement(element);\n  });\n}\n\nexport function addClass(element: HTMLElement, name: string) {\n  element.classList.add(name);\n}\n\nexport function removeClass(element: HTMLElement, name: string) {\n  element.classList.remove(name);\n}\n\nexport function isElementClosed(el: HTMLElement): boolean {\n  if (\n    !el ||\n    !el.parentNode ||\n    !el.ownerDocument ||\n    !el.ownerDocument.documentElement ||\n    !el.ownerDocument.documentElement.contains(el)\n  ) {\n    return true;\n  }\n  return false;\n}\n\nexport function watchElementForClose(\n  element: HTMLElement,\n  handler: () => mixed\n): CancelableType {\n  handler = once(handler);\n\n  let cancelled = false;\n  const mutationObservers = [];\n  // eslint-disable-next-line prefer-const\n  let interval;\n  // eslint-disable-next-line prefer-const\n  let sacrificialFrame;\n  let sacrificialFrameWin;\n\n  const cancel = () => {\n    cancelled = true;\n    for (const observer of mutationObservers) {\n      observer.disconnect();\n    }\n    if (interval) {\n      interval.cancel();\n    }\n    if (sacrificialFrameWin) {\n      // eslint-disable-next-line no-use-before-define\n      sacrificialFrameWin.removeEventListener(\"unload\", elementClosed);\n    }\n    if (sacrificialFrame) {\n      destroyElement(sacrificialFrame);\n    }\n  };\n\n  const elementClosed = () => {\n    if (!cancelled) {\n      handler();\n      cancel();\n    }\n  };\n\n  if (isElementClosed(element)) {\n    elementClosed();\n    return { cancel };\n  }\n\n  // Strategy 1: Mutation observer\n\n  if (window.MutationObserver) {\n    let mutationElement = element.parentElement;\n    while (mutationElement) {\n      const mutationObserver = new window.MutationObserver(() => {\n        if (isElementClosed(element)) {\n          elementClosed();\n        }\n      });\n\n      mutationObserver.observe(mutationElement, { childList: true });\n      mutationObservers.push(mutationObserver);\n      mutationElement = mutationElement.parentElement;\n    }\n  }\n\n  // Strategy 2: Sacrificial iframe\n\n  sacrificialFrame = document.createElement(\"iframe\");\n  sacrificialFrame.setAttribute(\"name\", `__detect_close_${uniqueID()}__`);\n  sacrificialFrame.style.display = \"none\";\n  awaitFrameWindow(sacrificialFrame).then((frameWin) => {\n    sacrificialFrameWin = assertSameDomain(frameWin);\n    sacrificialFrameWin.addEventListener(\"unload\", elementClosed);\n  });\n  element.appendChild(sacrificialFrame);\n\n  // Strategy 3: Poller\n\n  const check = () => {\n    if (isElementClosed(element)) {\n      elementClosed();\n    }\n  };\n  interval = safeInterval(check, 1000);\n\n  return { cancel };\n}\n\nexport function fixScripts(el: HTMLElement, doc: Document = window.document) {\n  for (const script of querySelectorAll(\"script\", el)) {\n    const parentNode = script.parentNode;\n\n    if (!parentNode) {\n      continue;\n    }\n\n    const newScript = doc.createElement(\"script\");\n    newScript.text = script.textContent;\n    parentNode.replaceChild(newScript, script);\n  }\n}\n\ntype OnResizeOptions = {|\n  width?: boolean,\n  height?: boolean,\n  interval?: number,\n  win?: SameDomainWindowType,\n|};\n\nexport function onResize(\n  el: HTMLElement,\n  handler: ({| width: number, height: number |}) => void,\n  {\n    width = true,\n    height = true,\n    interval = 100,\n    win = window,\n  }: OnResizeOptions = {}\n): {| cancel: () => void |} {\n  let currentWidth = el.offsetWidth;\n  let currentHeight = el.offsetHeight;\n  let canceled = false;\n\n  handler({ width: currentWidth, height: currentHeight });\n\n  const check = () => {\n    if (canceled || !isElementVisible(el)) {\n      return;\n    }\n\n    const newWidth = el.offsetWidth;\n    const newHeight = el.offsetHeight;\n\n    if (\n      (width && newWidth !== currentWidth) ||\n      (height && newHeight !== currentHeight)\n    ) {\n      handler({ width: newWidth, height: newHeight });\n    }\n\n    currentWidth = newWidth;\n    currentHeight = newHeight;\n  };\n\n  let observer;\n  let timeout;\n\n  win.addEventListener(\"resize\", check);\n\n  if (typeof win.ResizeObserver !== \"undefined\") {\n    observer = new win.ResizeObserver(check);\n    observer.observe(el);\n    timeout = safeInterval(check, interval * 10);\n  } else if (typeof win.MutationObserver !== \"undefined\") {\n    observer = new win.MutationObserver(check);\n    observer.observe(el, {\n      attributes: true,\n      childList: true,\n      subtree: true,\n      characterData: false,\n    });\n    timeout = safeInterval(check, interval * 10);\n  } else {\n    timeout = safeInterval(check, interval);\n  }\n\n  return {\n    cancel: () => {\n      canceled = true;\n      observer.disconnect();\n      window.removeEventListener(\"resize\", check);\n      timeout.cancel();\n    },\n  };\n}\n\nexport function getResourceLoadTime(url: string): ?number {\n  const performance = getPerformance();\n\n  if (!performance) {\n    return;\n  }\n\n  // $FlowFixMe[method-unbinding]\n  if (typeof performance.getEntries !== \"function\") {\n    return;\n  }\n\n  const entries = performance.getEntries();\n\n  for (let i = 0; i < entries.length; i++) {\n    const entry = entries[i];\n\n    if (\n      entry &&\n      entry.name &&\n      entry.name.indexOf(url) === 0 &&\n      typeof entry.duration === \"number\"\n    ) {\n      return Math.floor(entry.duration);\n    }\n  }\n}\n\nexport function isShadowElement(element: Node): boolean {\n  while (element.parentNode) {\n    element = element.parentNode;\n  }\n\n  return element.toString() === \"[object ShadowRoot]\";\n}\n\nexport function getShadowRoot(element: Node): ?Node {\n  while (element.parentNode) {\n    element = element.parentNode;\n  }\n\n  if (isShadowElement(element)) {\n    return element;\n  }\n}\n\nexport function getShadowHost(element: Node): ?HTMLElement {\n  const shadowRoot = getShadowRoot(element);\n\n  // $FlowFixMe\n  if (shadowRoot && shadowRoot.host) {\n    // $FlowFixMe\n    return shadowRoot.host;\n  }\n}\n\nexport function insertShadowSlot(element: HTMLElement): HTMLElement {\n  const shadowHost = getShadowHost(element);\n\n  if (!shadowHost) {\n    throw new Error(`Element is not in shadow dom`);\n  }\n\n  const slotName = `shadow-slot-${uniqueID()}`;\n  const slot = document.createElement(\"slot\");\n  slot.setAttribute(\"name\", slotName);\n  element.appendChild(slot);\n\n  const slotProvider = document.createElement(\"div\");\n  slotProvider.setAttribute(\"slot\", slotName);\n  shadowHost.appendChild(slotProvider);\n\n  if (isShadowElement(shadowHost)) {\n    return insertShadowSlot(slotProvider);\n  }\n\n  return slotProvider;\n}\n\nexport function preventClickFocus(el: HTMLElement) {\n  const onFocus = (event: Event) => {\n    el.removeEventListener(\"focus\", onFocus);\n    event.preventDefault();\n    el.blur();\n    return false;\n  };\n\n  el.addEventListener(\"mousedown\", () => {\n    el.addEventListener(\"focus\", onFocus);\n    setTimeout(() => {\n      el.removeEventListener(\"focus\", onFocus);\n    }, 1);\n  });\n}\n\nexport function getStackTrace(): string {\n  try {\n    throw new Error(\"_\");\n  } catch (err) {\n    return err.stack || \"\";\n  }\n}\n\nfunction inferCurrentScript(): ?HTMLScriptElement {\n  try {\n    const stack = getStackTrace();\n    const stackDetails = /.*at [^(]*\\((.*):(.+):(.+)\\)$/gi.exec(stack);\n    const scriptLocation = stackDetails && stackDetails[1];\n\n    if (!scriptLocation) {\n      return;\n    }\n\n    // $FlowFixMe[method-unbinding]\n    for (const script of Array.prototype.slice\n      .call(document.getElementsByTagName(\"script\"))\n      .reverse()) {\n      if (script.src && script.src === scriptLocation) {\n        return script;\n      }\n    }\n  } catch (err) {\n    // pass\n  }\n}\n\nlet currentScript =\n  // eslint-disable-next-line compat/compat\n  typeof document !== \"undefined\" ? document.currentScript : null;\n\ntype GetCurrentScript = () => HTMLScriptElement;\n\nexport const getCurrentScript: GetCurrentScript = memoize(() => {\n  if (currentScript) {\n    return currentScript;\n  }\n\n  currentScript = inferCurrentScript();\n\n  if (currentScript) {\n    return currentScript;\n  }\n\n  throw new Error(\"Can not determine current script\");\n});\n\nconst currentUID = uniqueID();\n\ntype GetCurrentScriptUID = () => string;\n\nexport const getCurrentScriptUID: GetCurrentScriptUID = memoize(() => {\n  let script;\n\n  try {\n    script = getCurrentScript();\n  } catch (err) {\n    return currentUID;\n  }\n\n  let uid = script.getAttribute(ATTRIBUTES.UID);\n\n  if (uid && typeof uid === \"string\") {\n    return uid;\n  }\n\n  uid = script.getAttribute(`${ATTRIBUTES.UID}-auto`);\n\n  if (uid && typeof uid === \"string\") {\n    return uid;\n  }\n\n  if (script.src) {\n    const { src, dataset } = script;\n    const stringToHash = JSON.stringify({ src, dataset });\n    const hashedString = strHashStr(stringToHash);\n    const hashResult = hashedString.slice(\n      hashedString.length - UID_HASH_LENGTH\n    );\n\n    uid = `uid_${hashResult}`;\n  } else {\n    uid = uniqueID();\n  }\n\n  script.setAttribute(`${ATTRIBUTES.UID}-auto`, uid);\n\n  return uid;\n});\n\ntype SubmitFormOptions = {|\n  url: string,\n  target: string,\n  body?: {| [string]: string | boolean |},\n  method?: string,\n|};\n\nexport function submitForm({\n  url,\n  target,\n  body,\n  method = \"post\",\n}: SubmitFormOptions) {\n  const form = document.createElement(\"form\");\n  form.setAttribute(\"target\", target);\n  form.setAttribute(\"method\", method);\n  form.setAttribute(\"action\", url);\n  form.style.display = \"none\";\n\n  if (body) {\n    for (const key of Object.keys(body)) {\n      const input = document.createElement(\"input\");\n      input.setAttribute(\"name\", key);\n      input.setAttribute(\"value\", body[key]?.toString());\n      form.appendChild(input);\n    }\n  }\n\n  getBody().appendChild(form);\n  form.submit();\n  getBody().removeChild(form);\n}\n","/* @flow */\n\nimport {\n  type CrossDomainWindowType,\n  type SameDomainWindowType,\n} from \"@krakenjs/cross-domain-utils/src\";\nimport { WeakMap } from \"@krakenjs/cross-domain-safe-weakmap/src\";\nimport { getOrSet, getCurrentScriptUID } from \"@krakenjs/belter/src\";\n\nexport function getGlobalKey(): string {\n  if (__POST_ROBOT__.__SCRIPT_NAMESPACE__) {\n    return `${__POST_ROBOT__.__GLOBAL_KEY__}_${getCurrentScriptUID()}`;\n  } else {\n    return __POST_ROBOT__.__GLOBAL_KEY__;\n  }\n}\n\nexport function getGlobal(win: SameDomainWindowType = window): Object {\n  const globalKey = getGlobalKey();\n\n  if (win !== window) {\n    return win[globalKey];\n  }\n  const global: Object = (win[globalKey] = win[globalKey] || {});\n  return global;\n}\n\nexport function deleteGlobal() {\n  const globalKey = getGlobalKey();\n  delete window[globalKey];\n}\n\ntype ObjectGetter = () => Object;\nconst getObj: ObjectGetter = () => ({});\n\ntype GetOrSet<T> = ((string, () => T) => T) & ((string, () => void) => void);\n\ntype GlobalStore<T> = {|\n  get: ((string, T) => T) & ((string, void) => T | void),\n  set: (string, T) => T,\n  has: (string) => boolean,\n  del: (string) => void,\n  getOrSet: GetOrSet<T>,\n  reset: () => void,\n  keys: () => $ReadOnlyArray<string>,\n|};\n\nexport function globalStore<T: mixed>(\n  key?: string = \"store\",\n  defStore?: ObjectGetter = getObj\n): GlobalStore<T> {\n  return getOrSet(getGlobal(), key, () => {\n    let store = defStore();\n\n    return {\n      has: (storeKey) => {\n        return store.hasOwnProperty(storeKey);\n      },\n      get: (storeKey, defVal) => {\n        // $FlowFixMe\n        return store.hasOwnProperty(storeKey) ? store[storeKey] : defVal;\n      },\n      set: (storeKey, val) => {\n        store[storeKey] = val;\n        return val;\n      },\n      del: (storeKey) => {\n        delete store[storeKey];\n      },\n      getOrSet: (storeKey, getter) => {\n        // $FlowFixMe\n        return getOrSet(store, storeKey, getter);\n      },\n      reset: () => {\n        store = defStore();\n      },\n      keys: () => {\n        return Object.keys(store);\n      },\n    };\n  });\n}\n\nexport class WildCard {}\n\nexport function getWildcard(): WildCard {\n  const global = getGlobal();\n  global.WINDOW_WILDCARD = global.WINDOW_WILDCARD || new WildCard();\n  return global.WINDOW_WILDCARD;\n}\n\ntype WindowStore<T> = {|\n  get: ((CrossDomainWindowType | WildCard, T) => T) &\n    ((CrossDomainWindowType | WildCard, void) => T | void),\n  set: (CrossDomainWindowType | WildCard, T) => T,\n  has: (CrossDomainWindowType | WildCard) => boolean,\n  del: (CrossDomainWindowType | WildCard) => void,\n  getOrSet: (CrossDomainWindowType | WildCard, () => T) => T,\n|};\n\nexport function windowStore<T>(\n  key?: string = \"store\",\n  defStore?: ObjectGetter = getObj\n): WindowStore<T> {\n  return globalStore(\"windowStore\").getOrSet(key, () => {\n    const winStore = new WeakMap();\n\n    const getStore = (win: CrossDomainWindowType | WildCard): ObjectGetter => {\n      return winStore.getOrSet(win, defStore);\n    };\n\n    return {\n      has: (win) => {\n        const store = getStore(win);\n        return store.hasOwnProperty(key);\n      },\n      get: (win, defVal) => {\n        const store = getStore(win);\n        // $FlowFixMe\n        return store.hasOwnProperty(key) ? store[key] : defVal;\n      },\n      set: (win, val) => {\n        const store = getStore(win);\n        store[key] = val;\n        return val;\n      },\n      del: (win) => {\n        const store = getStore(win);\n        delete store[key];\n      },\n      getOrSet: (win, getter) => {\n        const store = getStore(win);\n        return getOrSet(store, key, getter);\n      },\n    };\n  });\n}\n","/* @flow */\n\nexport const KEY_CODES = {\n  ENTER: 13,\n  SPACE: 32,\n};\n\nexport const ATTRIBUTES = {\n  UID: \"data-uid\",\n};\n\nexport const UID_HASH_LENGTH = 30;\n\n/* eslint-disable no-control-regex*/\nexport const invalidProtocolRegex: RegExp =\n  /([^\\w]*)(javascript|data|vbscript)/im;\nexport const htmlEntitiesRegex: RegExp = /&#(\\w+)(^\\w|;)?/g;\nexport const htmlCtrlEntityRegex: RegExp = /&(newline|tab);/gi;\nexport const ctrlCharactersRegex: RegExp =\n  /[\\u0000-\\u001F\\u007F-\\u009F\\u2000-\\u200D\\uFEFF]/gim;\nexport const urlSchemeRegex: RegExp = /^.+(:|&colon;)/gim;\nexport const relativeFirstCharacters = [\".\", \"/\"];\nexport const BLANK_URL = \"about:blank\";\n/* eslint-enable no-control-regex*/\n","/* @flow */\n\nimport {\n  getAncestor,\n  type CrossDomainWindowType,\n} from \"@krakenjs/cross-domain-utils/src\";\nimport { ZalgoPromise } from \"@krakenjs/zalgo-promise/src\";\nimport { uniqueID } from \"@krakenjs/belter/src\";\n\nimport { MESSAGE_NAME, WILDCARD } from \"../conf\";\nimport { windowStore, globalStore, getGlobal } from \"../global\";\nimport type { OnType, SendType, CancelableType } from \"../types\";\n\nfunction getInstanceID(): string {\n  return globalStore(\"instance\").getOrSet(\"instanceID\", uniqueID);\n}\n\nfunction getHelloPromise(\n  win: CrossDomainWindowType\n): ZalgoPromise<{| domain: string |}> {\n  const helloPromises = windowStore(\"helloPromises\");\n  return helloPromises.getOrSet(win, () => new ZalgoPromise());\n}\n\nfunction resolveHelloPromise(\n  win: CrossDomainWindowType,\n  { domain }\n): ZalgoPromise<{| domain: string |}> {\n  const helloPromises = windowStore(\"helloPromises\");\n  const existingPromise = helloPromises.get(win);\n  if (existingPromise) {\n    existingPromise.resolve({ domain });\n  }\n  const newPromise = ZalgoPromise.resolve({ domain });\n  helloPromises.set(win, newPromise);\n  return newPromise;\n}\n\nfunction listenForHello({ on }: {| on: OnType |}): CancelableType {\n  return on(MESSAGE_NAME.HELLO, { domain: WILDCARD }, ({ source, origin }) => {\n    resolveHelloPromise(source, { domain: origin });\n    return { instanceID: getInstanceID() };\n  });\n}\n\nexport function sayHello(\n  win: CrossDomainWindowType,\n  { send }: {| send: SendType |}\n): ZalgoPromise<{|\n  win: CrossDomainWindowType,\n  domain: string,\n  instanceID: string,\n|}> {\n  return send(\n    win,\n    MESSAGE_NAME.HELLO,\n    { instanceID: getInstanceID() },\n    { domain: WILDCARD, timeout: -1 }\n  ).then(({ origin, data: { instanceID } }) => {\n    resolveHelloPromise(win, { domain: origin });\n    return { win, domain: origin, instanceID };\n  });\n}\n\nexport function getWindowInstanceID(\n  win: CrossDomainWindowType,\n  { send }: {| send: SendType |}\n): ZalgoPromise<string> {\n  return windowStore(\"windowInstanceIDPromises\").getOrSet(win, () => {\n    return sayHello(win, { send }).then(({ instanceID }) => instanceID);\n  });\n}\n\nexport function initHello({\n  on,\n  send,\n}: {|\n  on: OnType,\n  send: SendType,\n|}): CancelableType {\n  return globalStore(\"builtinListeners\").getOrSet(\"helloListener\", () => {\n    const listener = listenForHello({ on });\n\n    const parent = getAncestor();\n    if (parent) {\n      sayHello(parent, { send }).catch((err) => {\n        // $FlowFixMe\n        if (__TEST__ && getGlobal(parent)) {\n          throw err;\n        }\n      });\n    }\n\n    return listener;\n  });\n}\n\nexport function awaitWindowHello(\n  win: CrossDomainWindowType,\n  timeout: number = 5000,\n  name: string = \"Window\"\n): ZalgoPromise<{| domain: string |}> {\n  let promise = getHelloPromise(win);\n\n  if (timeout !== -1) {\n    promise = promise.timeout(\n      timeout,\n      new Error(`${name} did not load after ${timeout}ms`)\n    );\n  }\n\n  return promise;\n}\n","/* @flow */\n\nexport const MESSAGE_TYPE = {\n  REQUEST: (\"postrobot_message_request\": \"postrobot_message_request\"),\n  RESPONSE: (\"postrobot_message_response\": \"postrobot_message_response\"),\n  ACK: (\"postrobot_message_ack\": \"postrobot_message_ack\"),\n};\n\nexport const MESSAGE_ACK = {\n  SUCCESS: (\"success\": \"success\"),\n  ERROR: (\"error\": \"error\"),\n};\n\nexport const MESSAGE_NAME = {\n  METHOD: (\"postrobot_method\": \"postrobot_method\"),\n  HELLO: (\"postrobot_hello\": \"postrobot_hello\"),\n  OPEN_TUNNEL: (\"postrobot_open_tunnel\": \"postrobot_open_tunnel\"),\n};\n\nexport const SEND_STRATEGY = {\n  POST_MESSAGE: (\"postrobot_post_message\": \"postrobot_post_message\"),\n  BRIDGE: (\"postrobot_bridge\": \"postrobot_bridge\"),\n  GLOBAL: (\"postrobot_global\": \"postrobot_global\"),\n};\n\nexport const BRIDGE_NAME_PREFIX = \"__postrobot_bridge__\";\nexport const POSTROBOT_PROXY = \"__postrobot_proxy__\";\n\nexport const WILDCARD = \"*\";\n\nexport const SERIALIZATION_TYPE = {\n  CROSS_DOMAIN_ZALGO_PROMISE:\n    (\"cross_domain_zalgo_promise\": \"cross_domain_zalgo_promise\"),\n  CROSS_DOMAIN_FUNCTION: (\"cross_domain_function\": \"cross_domain_function\"),\n  CROSS_DOMAIN_WINDOW: (\"cross_domain_window\": \"cross_domain_window\"),\n};\n\nexport const METHOD = {\n  GET: (\"get\": \"get\"),\n  POST: (\"post\": \"post\"),\n};\n","/* @flow */\n\nimport { type CrossDomainWindowType } from \"@krakenjs/cross-domain-utils/src\";\n\nimport { windowStore } from \"../global\";\n\nexport function markWindowKnown(win: CrossDomainWindowType) {\n  const knownWindows = windowStore(\"knownWindows\");\n  knownWindows.set(win, true);\n}\n\nexport function isWindowKnown(win: CrossDomainWindowType): boolean {\n  const knownWindows = windowStore(\"knownWindows\");\n  return knownWindows.get(win, false);\n}\n","/* @flow */\n\nimport { TYPE } from './constants';\nimport type { CustomSerializedType } from './types';\n\nexport function isSerializedType(item : mixed) : boolean {\n    return (typeof item === 'object' && item !== null && typeof item.__type__ === 'string');\n}\n\nexport function determineType(val : mixed) : $Values<typeof TYPE> | void {\n    if (typeof val === 'undefined') {\n        return TYPE.UNDEFINED;\n    }\n\n    if (val === null) {\n        return TYPE.NULL;\n    }\n\n    if (Array.isArray(val)) {\n        return TYPE.ARRAY;\n    }\n\n    if (typeof val === 'function') {\n        return TYPE.FUNCTION;\n    }\n\n    if (typeof val === 'object') {\n\n        if (val instanceof Error) {\n            return TYPE.ERROR;\n        }\n\n        if (typeof val.then === 'function') {\n            return TYPE.PROMISE;\n        }\n\n        // $FlowFixMe method-unbinding\n        if (Object.prototype.toString.call(val) === '[object RegExp]') {\n            return TYPE.REGEX;\n        }\n\n        // $FlowFixMe method-unbinding\n        if (Object.prototype.toString.call(val) === '[object Date]') {\n            return TYPE.DATE;\n        }\n\n        return TYPE.OBJECT;\n    }\n\n    if (typeof val === 'string') {\n        return TYPE.STRING;\n    }\n\n    if (typeof val === 'number') {\n        return TYPE.NUMBER;\n    }\n\n    if (typeof val === 'boolean') {\n        return TYPE.BOOLEAN;\n    }\n}\n\nexport function serializeType<T : string, V : mixed>(type : T, val : V) : CustomSerializedType<T, V> {\n    return {\n        __type__: type,\n        __val__:  val\n    };\n}\n","/* @flow */\n\nexport const TYPE = {\n    FUNCTION:  ('function' : 'function'),\n    ERROR:     ('error' : 'error'),\n    PROMISE:   ('promise' : 'promise'),\n    REGEX:     ('regex' : 'regex'),\n    DATE:      ('date' : 'date'),\n    ARRAY:     ('array' : 'array'),\n    OBJECT:    ('object' : 'object'),\n    STRING:    ('string' : 'string'),\n    NUMBER:    ('number' : 'number'),\n    BOOLEAN:   ('boolean' : 'boolean'),\n    NULL:      ('null' : 'null'),\n    UNDEFINED: ('undefined' : 'undefined')\n};\n","/* @flow */\n\nimport { TYPE } from './constants';\nimport type { Thenable, CustomSerializedType, NativeSerializedType } from './types';\nimport { determineType, isSerializedType } from './common';\nimport {\n    serializeFunction,\n    serializeError, type SerializedError,\n    serializePromise,\n    serializeRegex, type SerializedRegex,\n    serializeDate, type SerializedDate,\n    serializeArray,\n    serializeObject,\n    serializeString,\n    serializeNumber,\n    serializeBoolean,\n    serializeNull,\n    serializeUndefined\n} from './serializers';\n\ntype NativeSerializer<V : mixed, S : mixed, T : $Values<typeof TYPE>> = (value : V, key : string) => NativeSerializedType<T, S>;\ntype CustomSerializer<V : mixed, S : mixed, T : string> = (value : V, key : string) => CustomSerializedType<T, S>;\ntype PrimitiveSerializer<V : mixed, S : mixed> = (value : V, key : string) => S;\ntype CustomOrPrimitiveSerializer<V : mixed, T : string> = CustomSerializer<V, *, T> | PrimitiveSerializer<V, *>;\ntype NativeOrCustomOrPrimitiveSerializer<V : mixed, S : mixed, T : string> = NativeSerializer<V, S, T> | CustomOrPrimitiveSerializer<V, T>;\n\ntype Serializers = {|\n    function? : CustomOrPrimitiveSerializer<Function, typeof TYPE.FUNCTION>,\n    error? : NativeOrCustomOrPrimitiveSerializer<Error, SerializedError, typeof TYPE.ERROR>,\n    promise? : CustomOrPrimitiveSerializer<Thenable, typeof TYPE.PROMISE>,\n    regex? : NativeOrCustomOrPrimitiveSerializer<RegExp, SerializedRegex, typeof TYPE.REGEX>,\n    date? : NativeOrCustomOrPrimitiveSerializer<Date, SerializedDate, typeof TYPE.DATE>,\n    array? : CustomOrPrimitiveSerializer<$ReadOnlyArray<mixed>, typeof TYPE.ARRAY>,\n    object? : CustomOrPrimitiveSerializer<Object, typeof TYPE.OBJECT>,\n    string? : CustomOrPrimitiveSerializer<string, typeof TYPE.STRING>,\n    number? : CustomOrPrimitiveSerializer<number, typeof TYPE.NUMBER>,\n    boolean? : CustomOrPrimitiveSerializer<boolean, typeof TYPE.BOOLEAN>,\n    null? : CustomOrPrimitiveSerializer<null, typeof TYPE.NULL>,\n    undefined? : CustomOrPrimitiveSerializer<void, typeof TYPE.UNDEFINED>\n|};\n\nconst SERIALIZER : Serializers = {\n    [ TYPE.FUNCTION ]:  serializeFunction,\n    [ TYPE.ERROR ]:     serializeError,\n    [ TYPE.PROMISE ]:   serializePromise,\n    [ TYPE.REGEX ]:     serializeRegex,\n    [ TYPE.DATE ]:      serializeDate,\n    [ TYPE.ARRAY ]:     serializeArray,\n    [ TYPE.OBJECT ]:    serializeObject,\n    [ TYPE.STRING ]:    serializeString,\n    [ TYPE.NUMBER ]:    serializeNumber,\n    [ TYPE.BOOLEAN ]:   serializeBoolean,\n    [ TYPE.NULL ]:      serializeNull,\n    [ TYPE.UNDEFINED ]: serializeUndefined\n};\n\n// $FlowFixMe\nconst defaultSerializers : Serializers = {};\n\nexport function serialize<T : mixed>(obj : T, serializers : Serializers = defaultSerializers) : string {\n\n    function replacer(key) : ?mixed {\n        const val = this[key];\n\n        if (isSerializedType(this)) {\n            return val;\n        }\n        \n        const type = determineType(val);\n\n        if (!type) {\n            return val;\n        }\n\n        // $FlowFixMe\n        const serializer = serializers[type] || SERIALIZER[type];\n\n        if (!serializer) {\n            return val;\n        }\n\n        return serializer(val, key);\n    }\n\n    const result = JSON.stringify(obj, replacer);\n\n    if (typeof result === 'undefined') {\n        return TYPE.UNDEFINED;\n    }\n\n    return result;\n}\n","/* @flow */\n\nexport type SerializedFunction = void;\n\nexport function serializeFunction() : SerializedFunction {\n    // pass\n}\n\nexport function deserializeFunction() {\n    throw new Error(`Function serialization is not implemented; nothing to deserialize`);\n}\n","/* @flow */\n\nimport { serializeType } from '../common';\nimport { TYPE } from '../constants';\nimport type { NativeSerializedType } from '../types';\n\nimport { serializeObject } from './object';\n\nexport type SerializedError = {|\n    message : string,\n    stack : string,\n    code : string | number | void,\n    data : mixed\n|};\n\n// $FlowFixMe\nexport function serializeError({ message, stack, code, data } : Error) : NativeSerializedType<typeof TYPE.ERROR, SerializedError> {\n    return serializeType(TYPE.ERROR, { message, stack, code, data });\n}\n\nexport function deserializeError({ message, stack, code, data } : SerializedError) : Error {\n    const error = new Error(message);\n    // $FlowFixMe\n    error.code = code;\n\n    if (data) {\n        // $FlowFixMe\n        error.data = serializeObject(data);\n    }\n\n    error.stack = `${ stack }\\n\\n${ error.stack }`;\n    return error;\n}\n","/* @flow */\n\nimport type { Thenable } from '../types';\n\nexport type SerializedPromise = void;\n\nexport function serializePromise() : SerializedPromise {\n    // pass\n}\n\nexport function deserializePromise() : Thenable {\n    throw new Error(`Promise serialization is not implemented; nothing to deserialize`);\n}\n","/* @flow */\n\nimport { serializeType } from '../common';\nimport { TYPE } from '../constants';\nimport type { NativeSerializedType } from '../types';\n\nexport type SerializedRegex = string;\n\nexport function serializeRegex(val : RegExp) : NativeSerializedType<typeof TYPE.REGEX, SerializedRegex> {\n    return serializeType(TYPE.REGEX, val.source);\n}\n\nexport function deserializeRegex(val : string) : RegExp {\n    // eslint-disable-next-line security/detect-non-literal-regexp\n    return new RegExp(val);\n}\n","/* @flow */\n\nimport { serializeType } from '../common';\nimport { TYPE } from '../constants';\nimport type { NativeSerializedType } from '../types';\n\nexport type SerializedDate = string;\n\nexport function serializeDate(val : Date) : NativeSerializedType<typeof TYPE.DATE, SerializedDate> {\n    return serializeType(TYPE.DATE, val.toJSON());\n}\n\nexport function deserializeDate(val : string) : Date {\n    return new Date(val);\n}\n","/* @flow */\n\nexport type SerializedArray<T : mixed = mixed> = $ReadOnlyArray<T>;\n\nexport function serializeArray<T : mixed>(val : $ReadOnlyArray<T>) : SerializedArray<T> {\n    return val;\n}\n\nexport function deserializeArray<T : mixed>(val : SerializedArray<T>) : $ReadOnlyArray<T> {\n    return val;\n}\n","/* @flow */\n\nexport type SerializedObject = Object;\n\nexport function serializeObject(val : Object) : SerializedObject {\n    return val;\n}\n\nexport function deserializeObject(val : SerializedObject) : Object {\n    return val;\n}\n","/* @flow */\n\nexport type SerializedString = string;\n\nexport function serializeString(val : string) : SerializedString {\n    return val;\n}\n\nexport function deserializeString(val : SerializedString) : string {\n    return val;\n}\n","/* @flow */\n\nexport type SerializedNumber = number;\n\nexport function serializeNumber(val : number) : SerializedNumber {\n    return val;\n}\n\nexport function deserializeNumber(val : SerializedNumber) : number {\n    return val;\n}\n","/* @flow */\n\nexport type SerializedBoolean = boolean;\n\nexport function serializeBoolean(val : boolean) : SerializedBoolean {\n    return val;\n}\n\nexport function deserializeBoolean(val : SerializedBoolean) : boolean {\n    return val;\n}\n","/* @flow */\n\nexport type SerializedNull = null;\n\nexport function serializeNull(val : null) : SerializedNull {\n    return val;\n}\n\nexport function deserializeNull(val : SerializedNull) : null {\n    return val;\n}\n","/* @flow */\n\nimport type { NativeSerializedType } from '../types';\nimport { serializeType } from '../common';\nimport { TYPE } from '../constants';\n\nexport type SerializedUndefined = void;\n\nexport function serializeUndefined(val : void) : NativeSerializedType<typeof TYPE.UNDEFINED, SerializedUndefined> {\n    return serializeType(TYPE.UNDEFINED, val);\n}\n\nexport function deserializeUndefined() : void {\n    // pass\n}\n","/* @flow */\n\nimport type { Thenable } from './types';\nimport { TYPE } from './constants';\nimport { determineType, isSerializedType } from './common';\nimport {\n    deserializeFunction,\n    deserializeError, type SerializedError,\n    deserializePromise,\n    deserializeRegex, type SerializedRegex,\n    deserializeDate, type SerializedDate,\n    deserializeArray,\n    deserializeObject,\n    deserializeString,\n    deserializeNumber,\n    deserializeBoolean,\n    deserializeNull,\n    deserializeUndefined\n} from './serializers';\n\ntype Deserializer<V : mixed, S : mixed> = (serializedValue : S, key : string) => V;\ntype PrimitiveDeserializer<V, S = V> = (serializedValue : S, key : string) => V;\n\ntype Deserializers = {\n    function? : Deserializer<Function, *>,\n    error? : Deserializer<Error, SerializedError>,\n    promise? : Deserializer<Thenable, *>,\n    regex? : Deserializer<RegExp, SerializedRegex>,\n    date? : Deserializer<Date, SerializedDate>,\n    array? : PrimitiveDeserializer<$ReadOnlyArray<mixed>>,\n    object? : PrimitiveDeserializer<Object>,\n    string? : PrimitiveDeserializer<string>,\n    number? : PrimitiveDeserializer<number>,\n    boolean? : PrimitiveDeserializer<boolean>,\n    null? : PrimitiveDeserializer<null>,\n    [string] : Deserializer<mixed, *>,\n    undefined? : PrimitiveDeserializer<void>\n};\n\n// $FlowFixMe\nconst DESERIALIZER : Deserializers = {\n    [ TYPE.FUNCTION ]:  deserializeFunction,\n    [ TYPE.ERROR ]:     deserializeError,\n    [ TYPE.PROMISE ]:   deserializePromise,\n    [ TYPE.REGEX ]:     deserializeRegex,\n    [ TYPE.DATE ]:      deserializeDate,\n    [ TYPE.ARRAY ]:     deserializeArray,\n    [ TYPE.OBJECT ]:    deserializeObject,\n    [ TYPE.STRING ]:    deserializeString,\n    [ TYPE.NUMBER ]:    deserializeNumber,\n    [ TYPE.BOOLEAN ]:   deserializeBoolean,\n    [ TYPE.NULL ]:      deserializeNull,\n    [ TYPE.UNDEFINED ]: deserializeUndefined\n};\n\n// $FlowFixMe\nconst defaultDeserializers : Deserializers = {};\n\nexport function deserialize<T : mixed | null | void>(str : string, deserializers : Deserializers = defaultDeserializers) : T {\n    if (str === TYPE.UNDEFINED) {\n        // $FlowFixMe\n        return;\n    }\n\n    function replacer(key, val) : ?mixed {\n        if (isSerializedType(this)) {\n            return val;\n        }\n\n        let type;\n        let value;\n\n        if (isSerializedType(val)) {\n            type = val.__type__;\n            value = val.__val__;\n        } else {\n            type = determineType(val);\n            value = val;\n        }\n\n        if (!type) {\n            return value;\n        }\n\n        // $FlowFixMe\n        const deserializer = deserializers[type] || DESERIALIZER[type];\n\n        if (!deserializer) {\n            return value;\n        }\n\n        return deserializer(value, key);\n    }\n\n    return JSON.parse(str, replacer);\n}\n","/* @flow */\n\nimport { ZalgoPromise } from \"@krakenjs/zalgo-promise/src\";\nimport {\n  getDomain,\n  isSameDomain,\n  isOpener,\n  isSameTopWindow,\n  matchDomain,\n  getUserAgent,\n  getDomainFromUrl,\n  type CrossDomainWindowType,\n} from \"@krakenjs/cross-domain-utils/src\";\nimport { noop } from \"@krakenjs/belter/src\";\n\nimport { BRIDGE_NAME_PREFIX } from \"../conf\";\nimport { windowStore } from \"../global\";\n\nexport function needsBridgeForBrowser(): boolean {\n  if (getUserAgent(window).match(/MSIE|trident|edge\\/12|edge\\/13/i)) {\n    return true;\n  }\n\n  return false;\n}\n\nexport function needsBridgeForWin(win: CrossDomainWindowType): boolean {\n  if (!isSameTopWindow(window, win)) {\n    return true;\n  }\n\n  return false;\n}\n\nexport function needsBridgeForDomain(\n  domain: ?string,\n  win: ?CrossDomainWindowType\n): boolean {\n  if (domain) {\n    if (getDomain() !== getDomainFromUrl(domain)) {\n      return true;\n    }\n  } else if (win) {\n    if (!isSameDomain(win)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexport function needsBridge({\n  win,\n  domain,\n}: {|\n  win?: CrossDomainWindowType,\n  domain?: string,\n|}): boolean {\n  if (!needsBridgeForBrowser()) {\n    return false;\n  }\n\n  if (domain && !needsBridgeForDomain(domain, win)) {\n    return false;\n  }\n\n  if (win && !needsBridgeForWin(win)) {\n    return false;\n  }\n\n  return true;\n}\n\nexport function getBridgeName(domain: string): string {\n  domain = domain || getDomainFromUrl(domain);\n\n  const sanitizedDomain = domain.replace(/[^a-zA-Z0-9]+/g, \"_\");\n\n  const id = `${BRIDGE_NAME_PREFIX}_${sanitizedDomain}`;\n\n  return id;\n}\n\nexport function isBridge(): boolean {\n  return Boolean(window.name && window.name === getBridgeName(getDomain()));\n}\n\nexport const documentBodyReady: ZalgoPromise<HTMLBodyElement> =\n  new ZalgoPromise((resolve) => {\n    if (window.document && window.document.body) {\n      return resolve(window.document.body);\n    }\n\n    const interval = setInterval(() => {\n      if (window.document && window.document.body) {\n        clearInterval(interval);\n        return resolve(window.document.body);\n      }\n    }, 10);\n  });\n\nexport function registerRemoteWindow(win: CrossDomainWindowType) {\n  const remoteWindowPromises = windowStore(\"remoteWindowPromises\");\n  remoteWindowPromises.getOrSet(win, () => new ZalgoPromise());\n}\n\nexport function findRemoteWindow(\n  win: CrossDomainWindowType\n): ZalgoPromise<\n  (\n    remoteWin: CrossDomainWindowType,\n    message: string,\n    remoteDomain: string\n  ) => void\n> {\n  const remoteWindowPromises = windowStore(\"remoteWindowPromises\");\n  const remoteWinPromise = remoteWindowPromises.get(win);\n\n  if (!remoteWinPromise) {\n    throw new Error(`Remote window promise not found`);\n  }\n\n  return remoteWinPromise;\n}\n\ntype SendMessageType = {|\n  (string): void,\n  fireAndForget: (string) => void,\n|};\n\nexport function registerRemoteSendMessage(\n  win: CrossDomainWindowType,\n  domain: string,\n  sendMessage: SendMessageType\n) {\n  const sendMessageWrapper = (\n    remoteWin: CrossDomainWindowType,\n    remoteDomain: string,\n    message: string\n  ) => {\n    if (remoteWin !== win) {\n      throw new Error(`Remote window does not match window`);\n    }\n\n    if (!matchDomain(remoteDomain, domain)) {\n      throw new Error(\n        `Remote domain ${remoteDomain} does not match domain ${domain}`\n      );\n    }\n\n    sendMessage.fireAndForget(message);\n  };\n\n  findRemoteWindow(win).resolve(sendMessageWrapper);\n}\n\nexport function rejectRemoteSendMessage(\n  win: CrossDomainWindowType,\n  err: Error\n) {\n  findRemoteWindow(win).reject(err).catch(noop);\n}\n\nexport function sendBridgeMessage(\n  win: CrossDomainWindowType,\n  domain: string,\n  message: string\n): ZalgoPromise<void> {\n  const messagingChild = isOpener(window, win);\n  const messagingParent = isOpener(win, window);\n\n  if (!messagingChild && !messagingParent) {\n    throw new Error(\n      `Can only send messages to and from parent and popup windows`\n    );\n  }\n\n  return findRemoteWindow(win).then((sendMessage) => {\n    return sendMessage(win, domain, message);\n  });\n}\n","/* @flow */\n\nimport { ZalgoPromise } from \"@krakenjs/zalgo-promise/src\";\nimport {\n  getDomain,\n  getFrameByName,\n  isWindowClosed,\n  getDomainFromUrl,\n  normalizeMockUrl,\n  type CrossDomainWindowType,\n} from \"@krakenjs/cross-domain-utils/src\";\n\nimport { BRIDGE_TIMEOUT, MESSAGE_NAME } from \"../conf\";\nimport { awaitWindowHello } from \"../lib\";\nimport { windowStore, globalStore } from \"../global\";\nimport type { OnType, SendType, ReceiveMessageType } from \"../types\";\n\nimport {\n  getBridgeName,\n  documentBodyReady,\n  registerRemoteSendMessage,\n  registerRemoteWindow,\n} from \"./common\";\n\ntype WinDetails = {|\n  win: CrossDomainWindowType,\n  domain?: ?string,\n  name?: ?string,\n|};\n\nexport function listenForOpenTunnel({\n  on,\n  send,\n  receiveMessage,\n}: {|\n  on: OnType,\n  send: SendType,\n  receiveMessage: ReceiveMessageType,\n|}) {\n  const popupWindowsByName = globalStore(\"popupWindowsByName\");\n\n  on(MESSAGE_NAME.OPEN_TUNNEL, ({ source, origin, data }) => {\n    const bridgePromise = globalStore(\"bridges\").get(origin);\n\n    if (!bridgePromise) {\n      throw new Error(`Can not find bridge promise for domain ${origin}`);\n    }\n\n    return bridgePromise.then((bridge) => {\n      if (source !== bridge) {\n        throw new Error(\n          `Message source does not matched registered bridge for domain ${origin}`\n        );\n      }\n\n      if (!data.name) {\n        throw new Error(`Register window expected to be passed window name`);\n      }\n\n      if (!data.sendMessage) {\n        throw new Error(\n          `Register window expected to be passed sendMessage method`\n        );\n      }\n\n      if (!popupWindowsByName.has(data.name)) {\n        throw new Error(\n          `Window with name ${data.name} does not exist, or was not opened by this window`\n        );\n      }\n\n      const getWindowDetails = (): WinDetails => {\n        const winDetails = popupWindowsByName.get(data.name);\n        // $FlowFixMe\n        return winDetails;\n      };\n\n      if (!getWindowDetails().domain) {\n        throw new Error(\n          `We do not have a registered domain for window ${data.name}`\n        );\n      }\n\n      if (getWindowDetails().domain !== origin) {\n        throw new Error(\n          `Message origin ${origin} does not matched registered window origin ${\n            getWindowDetails().domain || \"unknown\"\n          }`\n        );\n      }\n\n      registerRemoteSendMessage(\n        getWindowDetails().win,\n        origin,\n        data.sendMessage\n      );\n\n      return {\n        sendMessage(message) {\n          if (!window || window.closed) {\n            return;\n          }\n\n          if (!getWindowDetails()) {\n            return;\n          }\n\n          const domain = getWindowDetails().domain;\n\n          if (!domain) {\n            return;\n          }\n\n          try {\n            receiveMessage(\n              {\n                data: message,\n                origin: domain,\n                source: getWindowDetails().win,\n              },\n              { on, send }\n            );\n          } catch (err) {\n            ZalgoPromise.reject(err);\n          }\n        },\n      };\n    });\n  });\n}\n\nfunction openBridgeFrame(name: string, url: string): HTMLIFrameElement {\n  const iframe = document.createElement(`iframe`);\n\n  iframe.setAttribute(`name`, name);\n  iframe.setAttribute(`id`, name);\n\n  iframe.setAttribute(\n    `style`,\n    `display: none; margin: 0; padding: 0; border: 0px none; overflow: hidden;`\n  );\n  iframe.setAttribute(`frameborder`, `0`);\n  iframe.setAttribute(`border`, `0`);\n  iframe.setAttribute(`scrolling`, `no`);\n  iframe.setAttribute(`allowTransparency`, `true`);\n\n  iframe.setAttribute(`tabindex`, `-1`);\n  iframe.setAttribute(`hidden`, `true`);\n  iframe.setAttribute(`title`, ``);\n  iframe.setAttribute(`role`, `presentation`);\n\n  iframe.src = url;\n\n  return iframe;\n}\n\nexport function hasBridge(url: string, domain: string): boolean {\n  const bridges = globalStore(\"bridges\");\n  return bridges.has(domain || getDomainFromUrl(url));\n}\n\nexport function openBridge(\n  url: string,\n  domain: string\n): ZalgoPromise<CrossDomainWindowType> {\n  const bridges = globalStore(\"bridges\");\n  const bridgeFrames = globalStore(\"bridgeFrames\");\n\n  domain = domain || getDomainFromUrl(url);\n\n  return bridges.getOrSet(domain, () =>\n    ZalgoPromise.try(() => {\n      if (getDomain() === domain) {\n        throw new Error(\n          `Can not open bridge on the same domain as current domain: ${domain}`\n        );\n      }\n\n      const name = getBridgeName(domain);\n      const frame = getFrameByName(window, name);\n\n      if (frame) {\n        throw new Error(`Frame with name ${name} already exists on page`);\n      }\n\n      const iframe = openBridgeFrame(name, url);\n      bridgeFrames.set(domain, iframe);\n\n      return documentBodyReady.then((body) => {\n        body.appendChild(iframe);\n        const bridge = iframe.contentWindow;\n\n        return new ZalgoPromise((resolve, reject) => {\n          iframe.addEventListener(\"load\", resolve);\n          iframe.addEventListener(\"error\", reject);\n        })\n          .then(() => {\n            return awaitWindowHello(bridge, BRIDGE_TIMEOUT, `Bridge ${url}`);\n          })\n          .then(() => {\n            return bridge;\n          });\n      });\n    })\n  );\n}\n\nexport function linkWindow({ win, name, domain }: WinDetails): WinDetails {\n  const popupWindowsByName = globalStore(\"popupWindowsByName\");\n  const popupWindowsByWin = windowStore(\"popupWindowsByWin\");\n\n  for (const winName of popupWindowsByName.keys()) {\n    const details = popupWindowsByName.get(winName);\n    if (!details || isWindowClosed(details.win)) {\n      popupWindowsByName.del(winName);\n    }\n  }\n\n  if (isWindowClosed(win)) {\n    return { win, name, domain };\n  }\n\n  const details = popupWindowsByWin.getOrSet(win, (): WinDetails => {\n    if (!name) {\n      return { win };\n    }\n\n    // $FlowFixMe\n    return popupWindowsByName.getOrSet(name, (): WinDetails => {\n      return { win, name };\n    });\n  });\n\n  if (details.win && details.win !== win) {\n    throw new Error(\n      `Different window already linked for window: ${name || \"undefined\"}`\n    );\n  }\n\n  if (name) {\n    details.name = name;\n    popupWindowsByName.set(name, details);\n  }\n\n  if (domain) {\n    details.domain = domain;\n    registerRemoteWindow(win);\n  }\n\n  popupWindowsByWin.set(win, details);\n\n  return details;\n}\n\nexport function linkUrl(win: CrossDomainWindowType, url: string) {\n  linkWindow({ win, domain: getDomainFromUrl(url) });\n}\n\nexport function listenForWindowOpen() {\n  const windowOpen = window.open;\n\n  window.open = function windowOpenWrapper(\n    url: string,\n    name: string,\n    options: string,\n    last: mixed\n  ): mixed {\n    const win = windowOpen.call(\n      this,\n      normalizeMockUrl(url),\n      name,\n      options,\n      last\n    );\n\n    if (!win) {\n      return win;\n    }\n\n    linkWindow({ win, name, domain: url ? getDomainFromUrl(url) : null });\n\n    return win;\n  };\n}\n\nexport function destroyBridges() {\n  const bridges = globalStore(\"bridges\");\n  const bridgeFrames = globalStore(\"bridgeFrames\");\n\n  for (const domain of bridgeFrames.keys()) {\n    const frame = bridgeFrames.get(domain);\n    if (frame && frame.parentNode) {\n      frame.parentNode.removeChild(frame);\n    }\n  }\n  bridgeFrames.reset();\n  bridges.reset();\n}\n","/* @flow */\n\nimport type { OnType, SendType, ReceiveMessageType } from \"../types\";\n\nimport { listenForWindowOpen, listenForOpenTunnel } from \"./parent\";\nimport { setupOpenTunnelToParent } from \"./bridge\";\nimport { openTunnelToOpener } from \"./child\";\n\nexport function setupBridge({\n  on,\n  send,\n  receiveMessage,\n}: {|\n  on: OnType,\n  send: SendType,\n  receiveMessage: ReceiveMessageType,\n|}) {\n  listenForWindowOpen();\n  listenForOpenTunnel({ on, send, receiveMessage });\n  setupOpenTunnelToParent({ send });\n  openTunnelToOpener({ on, send, receiveMessage });\n}\n","/* @flow */\n\nimport { type ZalgoPromise } from \"@krakenjs/zalgo-promise/src\";\nimport {\n  getParent,\n  isWindowClosed,\n  type CrossDomainWindowType,\n} from \"@krakenjs/cross-domain-utils/src\";\nimport { noop, uniqueID } from \"@krakenjs/belter/src\";\n\nimport { MESSAGE_NAME, WILDCARD } from \"../conf\";\nimport { getGlobal, globalStore } from \"../global\";\nimport type { SendType, ResponseMessageEvent } from \"../types\";\n\nfunction cleanTunnelWindows() {\n  const tunnelWindows = globalStore(\"tunnelWindows\");\n\n  for (const key of tunnelWindows.keys()) {\n    const tunnelWindow = tunnelWindows[key];\n\n    try {\n      noop(tunnelWindow.source);\n    } catch (err) {\n      tunnelWindows.del(key);\n      continue;\n    }\n\n    if (isWindowClosed(tunnelWindow.source)) {\n      tunnelWindows.del(key);\n    }\n  }\n}\n\ntype TunnelWindowDataType = {|\n  name: string,\n  source: CrossDomainWindowType,\n  canary: () => void,\n  sendMessage: (message: string) => void,\n|};\n\nfunction addTunnelWindow({\n  name,\n  source,\n  canary,\n  sendMessage,\n}: TunnelWindowDataType): string {\n  cleanTunnelWindows();\n  const id = uniqueID();\n  const tunnelWindows = globalStore(\"tunnelWindows\");\n  tunnelWindows.set(id, { name, source, canary, sendMessage });\n  return id;\n}\n\nexport function setupOpenTunnelToParent({ send }: {| send: SendType |}) {\n  getGlobal(window).openTunnelToParent = function openTunnelToParent({\n    name,\n    source,\n    canary,\n    sendMessage,\n  }: TunnelWindowDataType): ZalgoPromise<ResponseMessageEvent> {\n    const tunnelWindows = globalStore(\"tunnelWindows\");\n    const parentWindow = getParent(window);\n\n    if (!parentWindow) {\n      throw new Error(`No parent window found to open tunnel to`);\n    }\n\n    const id = addTunnelWindow({ name, source, canary, sendMessage });\n\n    return send(\n      parentWindow,\n      MESSAGE_NAME.OPEN_TUNNEL,\n      {\n        name,\n\n        sendMessage() {\n          const tunnelWindow = tunnelWindows.get(id);\n\n          try {\n            // IE gets antsy if you try to even reference a closed window\n            noop(tunnelWindow && tunnelWindow.source);\n          } catch (err) {\n            tunnelWindows.del(id);\n            return;\n          }\n\n          if (\n            !tunnelWindow ||\n            !tunnelWindow.source ||\n            isWindowClosed(tunnelWindow.source)\n          ) {\n            return;\n          }\n\n          try {\n            tunnelWindow.canary();\n          } catch (err) {\n            return;\n          }\n\n          // $FlowFixMe[object-this-reference]\n          tunnelWindow.sendMessage.apply(this, arguments);\n        },\n      },\n      { domain: WILDCARD }\n    );\n  };\n}\n","/* @flow */\n\nimport { ZalgoPromise } from \"@krakenjs/zalgo-promise/src\";\nimport {\n  isSameDomain,\n  getOpener,\n  getDomain,\n  getFrameByName,\n  assertSameDomain,\n  type CrossDomainWindowType,\n} from \"@krakenjs/cross-domain-utils/src\";\nimport { noop } from \"@krakenjs/belter/src\";\n\nimport { getGlobal, windowStore } from \"../global\";\nimport type { OnType, SendType, ReceiveMessageType } from \"../types\";\n\nimport {\n  needsBridge,\n  registerRemoteWindow,\n  rejectRemoteSendMessage,\n  registerRemoteSendMessage,\n  getBridgeName,\n} from \"./common\";\n\nfunction awaitRemoteBridgeForWindow(\n  win: CrossDomainWindowType\n): ZalgoPromise<?CrossDomainWindowType> {\n  return windowStore(\"remoteBridgeAwaiters\").getOrSet(win, () => {\n    return ZalgoPromise.try(() => {\n      const frame = getFrameByName(win, getBridgeName(getDomain()));\n\n      if (!frame) {\n        return;\n      }\n\n      if (isSameDomain(frame) && getGlobal(assertSameDomain(frame))) {\n        return frame;\n      }\n\n      return new ZalgoPromise((resolve) => {\n        let interval;\n        // eslint-disable-next-line prefer-const\n        let timeout;\n\n        // eslint-disable-next-line prefer-const\n        interval = setInterval(() => {\n          if (\n            frame &&\n            isSameDomain(frame) &&\n            getGlobal(assertSameDomain(frame))\n          ) {\n            clearInterval(interval);\n            clearTimeout(timeout);\n            return resolve(frame);\n          }\n        }, 100);\n\n        timeout = setTimeout(() => {\n          clearInterval(interval);\n          return resolve();\n        }, 2000);\n      });\n    });\n  });\n}\n\nexport function openTunnelToOpener({\n  on,\n  send,\n  receiveMessage,\n}: {|\n  on: OnType,\n  send: SendType,\n  receiveMessage: ReceiveMessageType,\n|}): ZalgoPromise<void> {\n  return ZalgoPromise.try(() => {\n    const opener = getOpener(window);\n\n    if (!opener || !needsBridge({ win: opener })) {\n      return;\n    }\n\n    registerRemoteWindow(opener);\n\n    return awaitRemoteBridgeForWindow(opener).then((bridge) => {\n      if (!bridge) {\n        return rejectRemoteSendMessage(\n          opener,\n          new Error(`Can not register with opener: no bridge found in opener`)\n        );\n      }\n\n      if (!window.name) {\n        return rejectRemoteSendMessage(\n          opener,\n          new Error(`Can not register with opener: window does not have a name`)\n        );\n      }\n\n      return getGlobal(assertSameDomain(bridge))\n        .openTunnelToParent({\n          name: window.name,\n\n          source: window,\n\n          canary() {\n            // pass\n          },\n\n          sendMessage(message) {\n            try {\n              noop(window);\n            } catch (err) {\n              return;\n            }\n\n            if (!window || window.closed) {\n              return;\n            }\n\n            try {\n              receiveMessage(\n                {\n                  data: message,\n                  // $FlowFixMe[object-this-reference]\n                  origin: this.origin,\n                  // $FlowFixMe[object-this-reference]\n                  source: this.source,\n                },\n                { on, send }\n              );\n            } catch (err) {\n              ZalgoPromise.reject(err);\n            }\n          },\n        })\n        .then(({ source, origin, data }) => {\n          if (source !== opener) {\n            throw new Error(`Source does not match opener`);\n          }\n\n          registerRemoteSendMessage(source, origin, data.sendMessage);\n        })\n        .catch((err) => {\n          rejectRemoteSendMessage(opener, err);\n          throw err;\n        });\n    });\n  });\n}\n","/* @flow */\n/* eslint no-use-before-define: off */\n\nimport {\n  isSameDomain,\n  isWindowClosed,\n  type CrossDomainWindowType,\n  closeWindow,\n  type DomainMatcher,\n  getOpener,\n  WINDOW_TYPE,\n  isWindow,\n  assertSameDomain,\n  getFrameForWindow,\n} from \"@krakenjs/cross-domain-utils/src\";\nimport { ZalgoPromise } from \"@krakenjs/zalgo-promise/src\";\nimport {\n  uniqueID,\n  memoizePromise,\n  noop,\n  submitForm,\n} from \"@krakenjs/belter/src\";\nimport {\n  serializeType,\n  type CustomSerializedType,\n} from \"@krakenjs/universal-serialize/src\";\n\nimport { SERIALIZATION_TYPE, METHOD } from \"../conf\";\nimport { windowStore, globalStore } from \"../global\";\nimport { getWindowInstanceID } from \"../lib\";\nimport { linkWindow } from \"../bridge\";\nimport type { SendType } from \"../types\";\n\nfunction cleanupProxyWindows() {\n  const idToProxyWindow = globalStore(\"idToProxyWindow\");\n  for (const id of idToProxyWindow.keys()) {\n    // $FlowFixMe\n    if (idToProxyWindow.get(id).shouldClean()) {\n      idToProxyWindow.del(id);\n    }\n  }\n}\n\ntype SetLocationOptions = {|\n  method?: $Values<typeof METHOD>,\n  body?: {|\n    [string]: string | boolean,\n  |},\n|};\n\ntype SerializedWindowType = {|\n  id: string,\n  getType: () => ZalgoPromise<$Values<typeof WINDOW_TYPE>>,\n  close: () => ZalgoPromise<void>,\n  focus: () => ZalgoPromise<void>,\n  isClosed: () => ZalgoPromise<boolean>,\n  setLocation: (url: string, opts?: SetLocationOptions) => ZalgoPromise<void>,\n  getName: () => ZalgoPromise<?string>,\n  setName: (string) => ZalgoPromise<void>,\n  getInstanceID: () => ZalgoPromise<string>,\n|};\n\nfunction getSerializedWindow(\n  winPromise: ZalgoPromise<CrossDomainWindowType>,\n  { send, id = uniqueID() }: {| send: SendType, id?: string |}\n): SerializedWindowType {\n  let windowNamePromise = winPromise.then((win) => {\n    if (isSameDomain(win)) {\n      return assertSameDomain(win).name;\n    }\n  });\n\n  const windowTypePromise = winPromise.then((window) => {\n    if (!isWindowClosed(window)) {\n      return getOpener(window) ? WINDOW_TYPE.POPUP : WINDOW_TYPE.IFRAME;\n    } else {\n      throw new Error(`Window is closed, can not determine type`);\n    }\n  });\n\n  windowNamePromise.catch(noop);\n  windowTypePromise.catch(noop);\n\n  const getName = () =>\n    winPromise.then((win) => {\n      if (isWindowClosed(win)) {\n        return;\n      }\n\n      if (isSameDomain(win)) {\n        return assertSameDomain(win).name;\n      }\n\n      return windowNamePromise;\n    });\n\n  const getDefaultSetLocationOptions = () => {\n    // $FlowFixMe\n    return {};\n  };\n\n  const setLocation = (\n    href: string,\n    opts?: SetLocationOptions = getDefaultSetLocationOptions()\n  ) =>\n    winPromise.then((win) => {\n      const domain = `${window.location.protocol}//${window.location.host}`;\n      const { method = METHOD.GET, body } = opts;\n\n      if (href.indexOf(\"/\") === 0) {\n        href = `${domain}${href}`;\n      } else if (!href.match(/^https?:\\/\\//) && href.indexOf(domain) !== 0) {\n        throw new Error(\n          `Expected url to be http or https url, or absolute path, got ${JSON.stringify(\n            href\n          )}`\n        );\n      }\n\n      if (method === METHOD.POST) {\n        return getName().then((name) => {\n          if (!name) {\n            throw new Error(`Can not post to window without target name`);\n          }\n\n          submitForm({\n            url: href,\n            target: name,\n            method,\n            body,\n          });\n        });\n      } else if (method === METHOD.GET) {\n        if (isSameDomain(win)) {\n          try {\n            if (win.location && typeof win.location.replace === \"function\") {\n              // $FlowFixMe\n              win.location.replace(href);\n              return;\n            }\n          } catch (err) {\n            // pass\n          }\n        }\n\n        win.location = href;\n      } else {\n        throw new Error(`Unsupported method: ${method}`);\n      }\n    });\n\n  return {\n    id,\n    getType: () => {\n      return windowTypePromise;\n    },\n    getInstanceID: memoizePromise(() =>\n      winPromise.then((win) => getWindowInstanceID(win, { send }))\n    ),\n    close: () => winPromise.then(closeWindow),\n    getName,\n    focus: () =>\n      winPromise.then((win) => {\n        win.focus();\n      }),\n    isClosed: () =>\n      winPromise.then((win) => {\n        return isWindowClosed(win);\n      }),\n    setLocation,\n    setName: (name) =>\n      winPromise.then((win) => {\n        if (__POST_ROBOT__.__IE_POPUP_SUPPORT__) {\n          linkWindow({ win, name });\n        }\n\n        const sameDomain = isSameDomain(win);\n        const frame = getFrameForWindow(win);\n\n        if (!sameDomain) {\n          throw new Error(`Can not set name for cross-domain window: ${name}`);\n        }\n\n        assertSameDomain(win).name = name;\n        if (frame) {\n          frame.setAttribute(\"name\", name);\n        }\n\n        windowNamePromise = ZalgoPromise.resolve(name);\n      }),\n  };\n}\n\nexport class ProxyWindow {\n  id: string;\n  isProxyWindow: true = true;\n  serializedWindow: SerializedWindowType;\n  actualWindow: ?CrossDomainWindowType;\n  actualWindowPromise: ZalgoPromise<CrossDomainWindowType>;\n  send: SendType;\n  name: string;\n\n  constructor({\n    send,\n    win,\n    serializedWindow,\n  }: {|\n    win?: CrossDomainWindowType,\n    serializedWindow?: SerializedWindowType,\n    send: SendType,\n  |}) {\n    this.actualWindowPromise = new ZalgoPromise();\n    this.serializedWindow =\n      serializedWindow ||\n      getSerializedWindow(this.actualWindowPromise, { send });\n\n    globalStore(\"idToProxyWindow\").set(this.getID(), this);\n    if (win) {\n      this.setWindow(win, { send });\n    }\n  }\n\n  getID(): string {\n    return this.serializedWindow.id;\n  }\n\n  getType(): ZalgoPromise<$Values<typeof WINDOW_TYPE>> {\n    return this.serializedWindow.getType();\n  }\n\n  isPopup(): ZalgoPromise<boolean> {\n    return this.getType().then((type) => {\n      return type === WINDOW_TYPE.POPUP;\n    });\n  }\n\n  setLocation(\n    href: string,\n    opts?: SetLocationOptions\n  ): ZalgoPromise<ProxyWindow> {\n    return this.serializedWindow.setLocation(href, opts).then(() => this);\n  }\n\n  getName(): ZalgoPromise<?string> {\n    return this.serializedWindow.getName();\n  }\n\n  setName(name: string): ZalgoPromise<ProxyWindow> {\n    return this.serializedWindow.setName(name).then(() => this);\n  }\n\n  close(): ZalgoPromise<ProxyWindow> {\n    return this.serializedWindow.close().then(() => this);\n  }\n\n  focus(): ZalgoPromise<ProxyWindow> {\n    const isPopupPromise = this.isPopup();\n    const getNamePromise = this.getName();\n\n    const reopenPromise = ZalgoPromise.hash({\n      isPopup: isPopupPromise,\n      name: getNamePromise,\n    }).then(({ isPopup, name }) => {\n      if (isPopup && name) {\n        window.open(\"\", name, \"noopener\");\n      }\n    });\n    const focusPromise = this.serializedWindow.focus();\n\n    return ZalgoPromise.all([reopenPromise, focusPromise]).then(() => this);\n  }\n\n  isClosed(): ZalgoPromise<boolean> {\n    return this.serializedWindow.isClosed();\n  }\n\n  getWindow(): ?CrossDomainWindowType {\n    return this.actualWindow;\n  }\n\n  setWindow(win: CrossDomainWindowType, { send }: {| send: SendType |}) {\n    this.actualWindow = win;\n    this.actualWindowPromise.resolve(this.actualWindow);\n    this.serializedWindow = getSerializedWindow(this.actualWindowPromise, {\n      send,\n      id: this.getID(),\n    });\n    windowStore(\"winToProxyWindow\").set(win, this);\n  }\n\n  awaitWindow(): ZalgoPromise<CrossDomainWindowType> {\n    return this.actualWindowPromise;\n  }\n\n  matchWindow(\n    win: CrossDomainWindowType,\n    { send }: {| send: SendType |}\n  ): ZalgoPromise<boolean> {\n    return ZalgoPromise.try(() => {\n      if (this.actualWindow) {\n        return win === this.actualWindow;\n      }\n\n      return ZalgoPromise.hash({\n        proxyInstanceID: this.getInstanceID(),\n        knownWindowInstanceID: getWindowInstanceID(win, { send }),\n      }).then(({ proxyInstanceID, knownWindowInstanceID }) => {\n        const match = proxyInstanceID === knownWindowInstanceID;\n\n        if (match) {\n          this.setWindow(win, { send });\n        }\n\n        return match;\n      });\n    });\n  }\n\n  unwrap(): CrossDomainWindowType | ProxyWindow {\n    return this.actualWindow || this;\n  }\n\n  getInstanceID(): ZalgoPromise<string> {\n    return this.serializedWindow.getInstanceID();\n  }\n\n  shouldClean(): boolean {\n    return Boolean(this.actualWindow && isWindowClosed(this.actualWindow));\n  }\n\n  serialize(): SerializedWindowType {\n    return this.serializedWindow;\n  }\n\n  static unwrap(\n    win: CrossDomainWindowType | ProxyWindow\n  ): CrossDomainWindowType | ProxyWindow {\n    return ProxyWindow.isProxyWindow(win)\n      ? // $FlowFixMe\n        win.unwrap()\n      : win;\n  }\n\n  static serialize(\n    win: CrossDomainWindowType | ProxyWindow,\n    { send }: {| send: SendType |}\n  ): SerializedWindowType {\n    cleanupProxyWindows();\n    return ProxyWindow.toProxyWindow(win, { send }).serialize();\n  }\n\n  static deserialize(\n    serializedWindow: SerializedWindowType,\n    { send }: {| send: SendType |}\n  ): ProxyWindow {\n    cleanupProxyWindows();\n    return (\n      globalStore(\"idToProxyWindow\").get(serializedWindow.id) ||\n      new ProxyWindow({ serializedWindow, send })\n    );\n  }\n\n  static isProxyWindow(obj: CrossDomainWindowType | ProxyWindow): boolean {\n    // $FlowFixMe\n    return Boolean(obj && !isWindow(obj) && obj.isProxyWindow);\n  }\n\n  static toProxyWindow(\n    win: CrossDomainWindowType | ProxyWindow,\n    { send }: {| send: SendType |}\n  ): ProxyWindow {\n    cleanupProxyWindows();\n\n    if (ProxyWindow.isProxyWindow(win)) {\n      // $FlowFixMe\n      return win;\n    }\n\n    // $FlowFixMe\n    const actualWindow: CrossDomainWindowType = win;\n\n    return (\n      windowStore(\"winToProxyWindow\").get(actualWindow) ||\n      new ProxyWindow({ win: actualWindow, send })\n    );\n  }\n}\n\nexport type SerializedWindow = CustomSerializedType<\n  typeof SERIALIZATION_TYPE.CROSS_DOMAIN_WINDOW,\n  SerializedWindowType\n>;\n\nexport function serializeWindow(\n  destination: CrossDomainWindowType | ProxyWindow,\n  domain: DomainMatcher,\n  win: CrossDomainWindowType,\n  { send }: {| send: SendType |}\n): SerializedWindow {\n  return serializeType(\n    SERIALIZATION_TYPE.CROSS_DOMAIN_WINDOW,\n    ProxyWindow.serialize(win, { send })\n  );\n}\n\nexport function deserializeWindow(\n  source: CrossDomainWindowType | ProxyWindow,\n  origin: string,\n  win: SerializedWindowType,\n  { send }: {| send: SendType |}\n): ProxyWindow {\n  return ProxyWindow.deserialize(win, { send });\n}\n","/* @flow */\n\nimport {\n  matchDomain,\n  getDomain,\n  type CrossDomainWindowType,\n  type DomainMatcher,\n} from \"@krakenjs/cross-domain-utils/src\";\nimport { ZalgoPromise } from \"@krakenjs/zalgo-promise/src\";\nimport { uniqueID, isRegex, arrayFrom } from \"@krakenjs/belter/src\";\nimport {\n  serializeType,\n  type CustomSerializedType,\n} from \"@krakenjs/universal-serialize/src\";\n\nimport { MESSAGE_NAME, WILDCARD, SERIALIZATION_TYPE } from \"../conf\";\nimport { windowStore, globalStore } from \"../global\";\nimport type { OnType, SendType, CancelableType } from \"../types\";\n\nimport { ProxyWindow } from \"./window\";\n\ntype StoredMethod = {|\n  name: string,\n  domain: DomainMatcher,\n  val: Function,\n  source: CrossDomainWindowType | ProxyWindow,\n|};\n\nfunction addMethod(\n  id: string,\n  val: Function,\n  name: string,\n  source: CrossDomainWindowType | ProxyWindow,\n  domain: DomainMatcher\n) {\n  const methodStore = windowStore(\"methodStore\");\n  const proxyWindowMethods = globalStore(\"proxyWindowMethods\");\n\n  if (ProxyWindow.isProxyWindow(source)) {\n    proxyWindowMethods.set(id, { val, name, domain, source });\n  } else {\n    proxyWindowMethods.del(id);\n    // $FlowFixMe\n    const methods = methodStore.getOrSet(source, () => ({}));\n    methods[id] = { domain, name, val, source };\n  }\n}\n\nfunction lookupMethod(\n  source: CrossDomainWindowType,\n  id: string\n): ?StoredMethod {\n  const methodStore = windowStore(\"methodStore\");\n  const proxyWindowMethods = globalStore(\"proxyWindowMethods\");\n  const methods = methodStore.getOrSet(source, () => ({}));\n  return methods[id] || proxyWindowMethods.get(id);\n}\n\nfunction stringifyArguments(args: $ReadOnlyArray<mixed> = []): string {\n  return arrayFrom(args)\n    .map((arg) => {\n      if (typeof arg === \"string\") {\n        return `'${arg}'`;\n      }\n      if (arg === undefined) {\n        return \"undefined\";\n      }\n      if (arg === null) {\n        return \"null\";\n      }\n      if (typeof arg === \"boolean\") {\n        return arg.toString();\n      }\n      if (Array.isArray(arg)) {\n        return \"[ ... ]\";\n      }\n      if (typeof arg === \"object\") {\n        return \"{ ... }\";\n      }\n      if (typeof arg === \"function\") {\n        return \"() => { ... }\";\n      }\n      return `<${typeof arg}>`;\n    })\n    .join(\", \");\n}\n\nfunction listenForFunctionCalls({\n  on,\n  send,\n}: {|\n  on: OnType,\n  send: SendType,\n|}): CancelableType {\n  return globalStore(\"builtinListeners\").getOrSet(\"functionCalls\", () => {\n    return on(\n      MESSAGE_NAME.METHOD,\n      { domain: WILDCARD },\n      ({\n        source,\n        origin,\n        data,\n      }: {|\n        source: CrossDomainWindowType,\n        origin: string,\n        data: Object,\n      |}) => {\n        const { id, name } = data;\n\n        const meth = lookupMethod(source, id);\n\n        if (!meth) {\n          throw new Error(\n            `Could not find method '${name}' with id: ${data.id} in ${getDomain(\n              window\n            )}`\n          );\n        }\n\n        const { source: methodSource, domain, val } = meth;\n\n        return ZalgoPromise.try(() => {\n          if (!matchDomain(domain, origin)) {\n            throw new Error(\n              `Method '${data.name}' domain ${JSON.stringify(\n                // $FlowFixMe\n                isRegex(meth.domain) ? meth.domain.source : meth.domain\n              )} does not match origin ${origin} in ${getDomain(window)}`\n            );\n          }\n\n          if (ProxyWindow.isProxyWindow(methodSource)) {\n            // $FlowFixMe\n            return methodSource.matchWindow(source, { send }).then((match) => {\n              if (!match) {\n                throw new Error(\n                  `Method call '${\n                    data.name\n                  }' failed - proxy window does not match source in ${getDomain(\n                    window\n                  )}`\n                );\n              }\n            });\n          }\n        })\n          .then(\n            () => {\n              return val.apply({ source, origin }, data.args);\n            },\n            (err) => {\n              return ZalgoPromise.try(() => {\n                if (val.onError) {\n                  return val.onError(err);\n                }\n              }).then(() => {\n                // $FlowFixMe\n                if (err.stack) {\n                  // $FlowFixMe\n                  err.stack = `Remote call to ${name}(${stringifyArguments(\n                    data.args\n                    // $FlowFixMe\n                  )}) failed\\n\\n${err.stack}`;\n                }\n\n                throw err;\n              });\n            }\n          )\n          .then((result) => {\n            return { result, id, name };\n          });\n      }\n    );\n  });\n}\n\nexport type SerializedFunction = CustomSerializedType<\n  typeof SERIALIZATION_TYPE.CROSS_DOMAIN_FUNCTION,\n  {|\n    id: string,\n    name: string,\n  |}\n>;\n\n// eslint-disable-next-line flowtype/require-exact-type\ntype SerializableFunction<T> = {\n  (): ZalgoPromise<T> | T,\n  __id__?: string,\n  __name__?: string,\n};\n\nexport function serializeFunction<T>(\n  destination: CrossDomainWindowType | ProxyWindow,\n  domain: DomainMatcher,\n  val: SerializableFunction<T>,\n  key: string,\n  { on, send }: {| on: OnType, send: SendType |}\n): SerializedFunction {\n  listenForFunctionCalls({ on, send });\n\n  const id = val.__id__ || uniqueID();\n  destination = ProxyWindow.unwrap(destination);\n  let name = val.__name__ || val.name || key;\n\n  if (\n    typeof name === \"string\" &&\n    typeof name.indexOf === \"function\" &&\n    name.indexOf(\"anonymous::\") === 0\n  ) {\n    name = name.replace(\"anonymous::\", `${key}::`);\n  }\n\n  if (ProxyWindow.isProxyWindow(destination)) {\n    addMethod(id, val, name, destination, domain);\n\n    // $FlowFixMe\n    destination.awaitWindow().then((win) => {\n      addMethod(id, val, name, win, domain);\n    });\n  } else {\n    addMethod(id, val, name, destination, domain);\n  }\n\n  return serializeType(SERIALIZATION_TYPE.CROSS_DOMAIN_FUNCTION, { id, name });\n}\n\nexport function deserializeFunction<T>(\n  source: CrossDomainWindowType | ProxyWindow,\n  origin: string,\n  { id, name }: {| id: string, name: string |},\n  { send }: {| send: SendType |}\n): (...args: $ReadOnlyArray<mixed>) => ZalgoPromise<T> {\n  const getDeserializedFunction = (opts?: Object = {}) => {\n    function crossDomainFunctionWrapper<X: mixed>(): ZalgoPromise<X> {\n      let originalStack;\n\n      if (__DEBUG__) {\n        originalStack = new Error(`Original call to ${name}():`).stack;\n      }\n\n      return ProxyWindow.toProxyWindow(source, { send })\n        .awaitWindow()\n        .then((win) => {\n          const meth = lookupMethod(win, id);\n\n          if (meth && meth.val !== crossDomainFunctionWrapper) {\n            return meth.val.apply(\n              { source: window, origin: getDomain() },\n              arguments\n            );\n          } else {\n            // $FlowFixMe[method-unbinding]\n            const args = Array.prototype.slice.call(arguments);\n\n            if (opts.fireAndForget) {\n              return send(\n                win,\n                MESSAGE_NAME.METHOD,\n                { id, name, args },\n                { domain: origin, fireAndForget: true }\n              );\n            } else {\n              return send(\n                win,\n                MESSAGE_NAME.METHOD,\n                { id, name, args },\n                { domain: origin, fireAndForget: false }\n              ).then((res) => res.data.result);\n            }\n          }\n        })\n        .catch((err) => {\n          // $FlowFixMe\n          if (__DEBUG__ && originalStack && err.stack) {\n            // $FlowFixMe\n            err.stack = `Remote call to ${name}(${stringifyArguments(\n              arguments\n              // $FlowFixMe\n            )}) failed\\n\\n${err.stack}\\n\\n${originalStack}`;\n          }\n          throw err;\n        });\n    }\n\n    crossDomainFunctionWrapper.__name__ = name;\n    crossDomainFunctionWrapper.__origin__ = origin;\n    crossDomainFunctionWrapper.__source__ = source;\n    crossDomainFunctionWrapper.__id__ = id;\n\n    crossDomainFunctionWrapper.origin = origin;\n\n    return crossDomainFunctionWrapper;\n  };\n\n  const crossDomainFunctionWrapper = getDeserializedFunction();\n  crossDomainFunctionWrapper.fireAndForget = getDeserializedFunction({\n    fireAndForget: true,\n  });\n\n  return crossDomainFunctionWrapper;\n}\n","/* @flow */\n\nimport {\n  type CrossDomainWindowType,\n  isWindow,\n  type DomainMatcher,\n} from \"@krakenjs/cross-domain-utils/src\";\nimport {\n  TYPE,\n  serialize,\n  deserialize,\n  type Thenable,\n} from \"@krakenjs/universal-serialize/src\";\n\nimport { SERIALIZATION_TYPE } from \"../conf\";\nimport type { OnType, SendType } from \"../types\";\n\nimport {\n  serializeFunction,\n  deserializeFunction,\n  type SerializedFunction,\n} from \"./function\";\nimport {\n  serializePromise,\n  deserializePromise,\n  type SerializedPromise,\n} from \"./promise\";\nimport {\n  serializeWindow,\n  deserializeWindow,\n  type SerializedWindow,\n  ProxyWindow,\n} from \"./window\";\n\nexport function serializeMessage<T: mixed>(\n  destination: CrossDomainWindowType | ProxyWindow,\n  domain: DomainMatcher,\n  obj: T,\n  { on, send }: {| on: OnType, send: SendType |}\n): string {\n  return serialize(obj, {\n    [TYPE.PROMISE]: (val: Thenable, key: string): SerializedPromise =>\n      serializePromise(destination, domain, val, key, { on, send }),\n    [TYPE.FUNCTION]: (val: Function, key: string): SerializedFunction =>\n      serializeFunction(destination, domain, val, key, { on, send }),\n    [TYPE.OBJECT]: (val: CrossDomainWindowType): Object | SerializedWindow => {\n      return isWindow(val) || ProxyWindow.isProxyWindow(val)\n        ? serializeWindow(destination, domain, val, { send })\n        : val;\n    },\n  });\n}\n\nexport function deserializeMessage<T: mixed>(\n  source: CrossDomainWindowType | ProxyWindow,\n  origin: string,\n  message: string,\n  { send }: {| on: OnType, send: SendType |}\n): T {\n  return deserialize(message, {\n    [SERIALIZATION_TYPE.CROSS_DOMAIN_ZALGO_PROMISE]: (serializedPromise) =>\n      deserializePromise(source, origin, serializedPromise),\n    [SERIALIZATION_TYPE.CROSS_DOMAIN_FUNCTION]: (serializedFunction) =>\n      deserializeFunction(source, origin, serializedFunction, { send }),\n    [SERIALIZATION_TYPE.CROSS_DOMAIN_WINDOW]: (serializedWindow) =>\n      deserializeWindow(source, origin, serializedWindow, { send }),\n  });\n}\n","/* @flow */\n\nimport {\n  type CrossDomainWindowType,\n  type DomainMatcher,\n} from \"@krakenjs/cross-domain-utils/src\";\nimport { ZalgoPromise } from \"@krakenjs/zalgo-promise/src\";\nimport {\n  serializeType,\n  type CustomSerializedType,\n  type Thenable,\n} from \"@krakenjs/universal-serialize/src\";\n\nimport { SERIALIZATION_TYPE } from \"../conf\";\nimport type { OnType, SendType } from \"../types\";\n\nimport { serializeFunction, type SerializedFunction } from \"./function\";\nimport { ProxyWindow } from \"./window\";\n\nexport type SerializedPromise = CustomSerializedType<\n  typeof SERIALIZATION_TYPE.CROSS_DOMAIN_ZALGO_PROMISE,\n  {|\n    then: SerializedFunction,\n  |}\n>;\n\nexport function serializePromise(\n  destination: CrossDomainWindowType | ProxyWindow,\n  domain: DomainMatcher,\n  val: Thenable,\n  key: string,\n  { on, send }: {| on: OnType, send: SendType |}\n): SerializedPromise {\n  return serializeType(SERIALIZATION_TYPE.CROSS_DOMAIN_ZALGO_PROMISE, {\n    then: serializeFunction(\n      destination,\n      domain,\n      (resolve, reject) => val.then(resolve, reject),\n      key,\n      { on, send }\n    ),\n  });\n}\n\nexport function deserializePromise<T>(\n  source: CrossDomainWindowType | ProxyWindow,\n  origin: string,\n  { then }: {| then: Function |}\n): ZalgoPromise<T> {\n  return new ZalgoPromise(then);\n}\n","/* @flow */\n\nimport {\n  isSameDomain,\n  isSameTopWindow,\n  isActuallySameDomain,\n  getActualDomain,\n  getDomain,\n  type CrossDomainWindowType,\n  PROTOCOL,\n} from \"@krakenjs/cross-domain-utils/src\";\n\nimport { SEND_STRATEGY, WILDCARD } from \"../../conf\";\nimport { needsGlobalMessagingForBrowser } from \"../../lib\";\nimport { getGlobal } from \"../../global\";\nimport {\n  sendBridgeMessage,\n  needsBridgeForBrowser,\n  isBridge,\n} from \"../../bridge\";\n\ntype SendStrategies = {|\n  [$Values<typeof SEND_STRATEGY>]: (\n    CrossDomainWindowType,\n    string,\n    string\n  ) => void,\n|};\n\nexport const SEND_MESSAGE_STRATEGIES: SendStrategies = {};\n\nSEND_MESSAGE_STRATEGIES[SEND_STRATEGY.POST_MESSAGE] = (\n  win: CrossDomainWindowType,\n  serializedMessage: string,\n  domain: string\n) => {\n  if (domain.indexOf(PROTOCOL.FILE) === 0) {\n    domain = WILDCARD;\n  }\n\n  if (__TEST__) {\n    if (\n      needsGlobalMessagingForBrowser() &&\n      isSameTopWindow(window, win) === false\n    ) {\n      return;\n    }\n\n    if (domain.indexOf(PROTOCOL.MOCK) === 0) {\n      if (!isActuallySameDomain(win)) {\n        throw new Error(\n          `Attempting to send message to mock domain ${domain}, but window is actually cross-domain`\n        );\n      }\n\n      // $FlowFixMe\n      const windowDomain = getDomain(win);\n\n      if (windowDomain !== domain) {\n        throw new Error(\n          `Mock domain target ${domain} does not match window domain ${windowDomain}`\n        );\n      }\n\n      // $FlowFixMe\n      domain = getActualDomain(win);\n    }\n  }\n\n  win.postMessage(serializedMessage, domain);\n};\n\nif (__POST_ROBOT__.__IE_POPUP_SUPPORT__) {\n  SEND_MESSAGE_STRATEGIES[SEND_STRATEGY.BRIDGE] = (\n    win: CrossDomainWindowType,\n    serializedMessage: string,\n    domain: string\n  ) => {\n    if (!needsBridgeForBrowser() && !isBridge()) {\n      throw new Error(`Bridge not needed for browser`);\n    }\n\n    if (isSameDomain(win)) {\n      throw new Error(\n        `Post message through bridge disabled between same domain windows`\n      );\n    }\n\n    if (isSameTopWindow(window, win) !== false) {\n      throw new Error(\n        `Can only use bridge to communicate between two different windows, not between frames`\n      );\n    }\n\n    sendBridgeMessage(win, domain, serializedMessage);\n  };\n}\n\nif (\n  __POST_ROBOT__.__IE_POPUP_SUPPORT__ ||\n  __POST_ROBOT__.__GLOBAL_MESSAGE_SUPPORT__\n) {\n  SEND_MESSAGE_STRATEGIES[SEND_STRATEGY.GLOBAL] = (\n    win: CrossDomainWindowType,\n    serializedMessage: string\n  ) => {\n    if (!needsGlobalMessagingForBrowser()) {\n      throw new Error(`Global messaging not needed for browser`);\n    }\n\n    if (!isSameDomain(win)) {\n      throw new Error(\n        `Post message through global disabled between different domain windows`\n      );\n    }\n\n    if (isSameTopWindow(window, win) !== false) {\n      throw new Error(\n        `Can only use global to communicate between two different windows, not between frames`\n      );\n    }\n\n    // $FlowFixMe\n    const foreignGlobal = getGlobal(win);\n\n    if (!foreignGlobal) {\n      throw new Error(`Can not find postRobot global on foreign window`);\n    }\n\n    foreignGlobal.receiveMessage({\n      source: window,\n      origin: getDomain(),\n      data: serializedMessage,\n    });\n  };\n}\n","/* @flow */\n\nimport { ZalgoPromise } from \"@krakenjs/zalgo-promise/src\";\nimport {\n  isWindowClosed,\n  type CrossDomainWindowType,\n} from \"@krakenjs/cross-domain-utils/src\";\nimport { stringifyError, noop } from \"@krakenjs/belter/src\";\n\nimport { serializeMessage } from \"../../serialize\";\nimport { windowStore, getGlobalKey } from \"../../global\";\nimport type { Message, PackedMessages } from \"../types\";\nimport type { OnType, SendType } from \"../../types\";\n\nimport { SEND_MESSAGE_STRATEGIES } from \"./strategies\";\n\nfunction packMessages(messages: $ReadOnlyArray<Message>): PackedMessages {\n  return {\n    [getGlobalKey()]: messages,\n  };\n}\n\nexport function sendMessage(\n  win: CrossDomainWindowType,\n  domain: string,\n  message: Message,\n  { on, send }: {| on: OnType, send: SendType |}\n): ZalgoPromise<void> {\n  return ZalgoPromise.try(() => {\n    const messageBuffer = windowStore();\n\n    const domainBuffer = messageBuffer.getOrSet(win, () => ({}));\n\n    domainBuffer.buffer = domainBuffer.buffer || [];\n    domainBuffer.buffer.push(message);\n\n    domainBuffer.flush =\n      domainBuffer.flush ||\n      ZalgoPromise.flush().then(() => {\n        if (isWindowClosed(win)) {\n          throw new Error(\"Window is closed\");\n        }\n\n        const serializedMessage = serializeMessage(\n          win,\n          domain,\n          packMessages(domainBuffer.buffer || []),\n          { on, send }\n        );\n        delete domainBuffer.buffer;\n\n        const strategies = Object.keys(SEND_MESSAGE_STRATEGIES);\n        const errors = [];\n\n        for (const strategyName of strategies) {\n          try {\n            SEND_MESSAGE_STRATEGIES[strategyName](\n              win,\n              serializedMessage,\n              domain\n            );\n          } catch (err) {\n            errors.push(err);\n          }\n        }\n\n        if (errors.length === strategies.length) {\n          throw new Error(\n            `All post-robot messaging strategies failed:\\n\\n${errors\n              .map((err, i) => `${i}. ${stringifyError(err)}`)\n              .join(\"\\n\\n\")}`\n          );\n        }\n      });\n\n    return domainBuffer.flush.then(() => {\n      delete domainBuffer.flush;\n    });\n  }).then(noop);\n}\n","/* @flow */\n\nimport { type ZalgoPromise } from \"@krakenjs/zalgo-promise/src\";\nimport {\n  matchDomain,\n  type CrossDomainWindowType,\n  type DomainMatcher,\n} from \"@krakenjs/cross-domain-utils/src\";\nimport { isRegex, getOrSet, noop } from \"@krakenjs/belter/src\";\n\nimport {\n  getWildcard,\n  type WildCard,\n  globalStore,\n  windowStore,\n} from \"../global\";\nimport { WILDCARD } from \"../conf\";\nimport { ProxyWindow } from \"../serialize/window\";\n\nexport function resetListeners() {\n  const responseListeners = globalStore(\"responseListeners\");\n  const erroredResponseListeners = globalStore(\"erroredResponseListeners\");\n  responseListeners.reset();\n  erroredResponseListeners.reset();\n}\n\nconst __DOMAIN_REGEX__ = \"__domain_regex__\";\n\nexport type RequestListenerType = {|\n  handler: ({|\n    source: CrossDomainWindowType,\n    origin: string,\n    data: mixed,\n  |}) => mixed | ZalgoPromise<mixed>,\n  handleError: (err: mixed) => void,\n|};\n\nexport type ResponseListenerType = {|\n  name: string,\n  win: CrossDomainWindowType,\n  domain: DomainMatcher,\n  promise: ZalgoPromise<*>,\n  ack?: ?boolean,\n  cancelled?: ?boolean,\n|};\n\nexport function addResponseListener(\n  hash: string,\n  listener: ResponseListenerType\n) {\n  const responseListeners = globalStore(\"responseListeners\");\n  responseListeners.set(hash, listener);\n}\n\nexport function getResponseListener(hash: string): ?ResponseListenerType {\n  const responseListeners = globalStore(\"responseListeners\");\n  return responseListeners.get(hash);\n}\n\nexport function deleteResponseListener(hash: string) {\n  const responseListeners = globalStore(\"responseListeners\");\n  responseListeners.del(hash);\n}\n\nexport function cancelResponseListeners() {\n  const responseListeners = globalStore(\"responseListeners\");\n  for (const hash of responseListeners.keys()) {\n    const listener = responseListeners.get(hash);\n    if (listener) {\n      listener.cancelled = true;\n    }\n    responseListeners.del(hash);\n  }\n}\n\nexport function markResponseListenerErrored(hash: string) {\n  const erroredResponseListeners = globalStore(\"erroredResponseListeners\");\n  erroredResponseListeners.set(hash, true);\n}\n\nexport function isResponseListenerErrored(hash: string): boolean {\n  const erroredResponseListeners = globalStore(\"erroredResponseListeners\");\n  return erroredResponseListeners.has(hash);\n}\n\nexport function getRequestListener({\n  name,\n  win,\n  domain,\n}: {|\n  name: string,\n  win: ?(CrossDomainWindowType | WildCard),\n  domain: ?(string | RegExp),\n|}): ?RequestListenerType {\n  const requestListeners = windowStore(\"requestListeners\");\n\n  if (win === WILDCARD) {\n    win = null;\n  }\n\n  if (domain === WILDCARD) {\n    domain = null;\n  }\n\n  if (!name) {\n    throw new Error(`Name required to get request listener`);\n  }\n\n  for (const winQualifier of [win, getWildcard()]) {\n    if (!winQualifier) {\n      continue;\n    }\n\n    const nameListeners = requestListeners.get(winQualifier);\n\n    if (!nameListeners) {\n      continue;\n    }\n\n    const domainListeners = nameListeners[name];\n\n    if (!domainListeners) {\n      continue;\n    }\n\n    if (domain && typeof domain === \"string\") {\n      if (domainListeners[domain]) {\n        return domainListeners[domain];\n      }\n\n      if (domainListeners[__DOMAIN_REGEX__]) {\n        for (const { regex, listener } of domainListeners[__DOMAIN_REGEX__]) {\n          if (matchDomain(regex, domain)) {\n            return listener;\n          }\n        }\n      }\n    }\n\n    if (domainListeners[WILDCARD]) {\n      return domainListeners[WILDCARD];\n    }\n  }\n}\n\n// eslint-disable-next-line complexity\nexport function addRequestListener(\n  {\n    name,\n    win: winCandidate,\n    domain,\n  }: {|\n    name: string,\n    win: ?(CrossDomainWindowType | WildCard | ProxyWindow),\n    domain: ?DomainMatcher,\n  |},\n  listener: RequestListenerType\n): {| cancel: () => void |} {\n  const requestListeners = windowStore(\"requestListeners\");\n\n  if (!name || typeof name !== \"string\") {\n    throw new Error(`Name required to add request listener`);\n  }\n\n  if (\n    winCandidate &&\n    winCandidate !== WILDCARD &&\n    // $FlowFixMe\n    ProxyWindow.isProxyWindow(winCandidate)\n  ) {\n    // $FlowFixMe\n    const proxyWin: ProxyWindow = winCandidate;\n\n    const requestListenerPromise = proxyWin.awaitWindow().then((actualWin) => {\n      return addRequestListener({ name, win: actualWin, domain }, listener);\n    });\n\n    return {\n      cancel: () => {\n        requestListenerPromise.then(\n          (requestListener) => requestListener.cancel(),\n          noop\n        );\n      },\n    };\n  }\n\n  // $FlowFixMe\n  let win: ?(CrossDomainWindowType | WildCard) = winCandidate;\n\n  if (Array.isArray(win)) {\n    const listenersCollection = [];\n\n    for (const item of win) {\n      listenersCollection.push(\n        addRequestListener({ name, domain, win: item }, listener)\n      );\n    }\n\n    return {\n      cancel() {\n        for (const cancelListener of listenersCollection) {\n          cancelListener.cancel();\n        }\n      },\n    };\n  }\n\n  if (Array.isArray(domain)) {\n    const listenersCollection = [];\n\n    for (const item of domain) {\n      listenersCollection.push(\n        addRequestListener({ name, win, domain: item }, listener)\n      );\n    }\n\n    return {\n      cancel() {\n        for (const cancelListener of listenersCollection) {\n          cancelListener.cancel();\n        }\n      },\n    };\n  }\n\n  const existingListener = getRequestListener({ name, win, domain });\n\n  if (!win || win === WILDCARD) {\n    win = getWildcard();\n  }\n\n  domain = domain || WILDCARD;\n  const strDomain = domain.toString();\n\n  if (existingListener) {\n    if (win && domain) {\n      throw new Error(\n        `Request listener already exists for ${name} on domain ${domain.toString()} for ${\n          win === getWildcard() ? \"wildcard\" : \"specified\"\n        } window`\n      );\n    } else if (win) {\n      throw new Error(\n        `Request listener already exists for ${name} for ${\n          win === getWildcard() ? \"wildcard\" : \"specified\"\n        } window`\n      );\n    } else if (domain) {\n      throw new Error(\n        `Request listener already exists for ${name} on domain ${domain.toString()}`\n      );\n    } else {\n      throw new Error(`Request listener already exists for ${name}`);\n    }\n  }\n\n  const winNameListeners = requestListeners.getOrSet(win, () => ({}));\n  const winNameDomainListeners = getOrSet(winNameListeners, name, () => ({}));\n\n  let winNameDomainRegexListeners;\n  let winNameDomainRegexListener;\n\n  if (isRegex(domain)) {\n    winNameDomainRegexListeners = getOrSet(\n      winNameDomainListeners,\n      __DOMAIN_REGEX__,\n      () => []\n    );\n    winNameDomainRegexListener = { regex: domain, listener };\n    winNameDomainRegexListeners.push(winNameDomainRegexListener);\n  } else {\n    winNameDomainListeners[strDomain] = listener;\n  }\n\n  return {\n    cancel() {\n      delete winNameDomainListeners[strDomain];\n\n      if (winNameDomainRegexListener) {\n        winNameDomainRegexListeners.splice(\n          winNameDomainRegexListeners.indexOf(winNameDomainRegexListener, 1)\n        );\n\n        if (!winNameDomainRegexListeners.length) {\n          delete winNameDomainListeners[__DOMAIN_REGEX__];\n        }\n      }\n\n      if (!Object.keys(winNameDomainListeners).length) {\n        delete winNameListeners[name];\n      }\n\n      if (win && !Object.keys(winNameListeners).length) {\n        requestListeners.del(win);\n      }\n    },\n  };\n}\n","/* @flow */\n\nimport { ZalgoPromise } from \"@krakenjs/zalgo-promise/src\";\nimport {\n  isWindowClosed,\n  type CrossDomainWindowType,\n  getDomain,\n  isSameTopWindow,\n  PROTOCOL,\n} from \"@krakenjs/cross-domain-utils/src\";\nimport { addEventListener, noop } from \"@krakenjs/belter/src\";\n\nimport type { Message } from \"../types\";\nimport { MESSAGE_TYPE } from \"../../conf\";\nimport { markWindowKnown, needsGlobalMessagingForBrowser } from \"../../lib\";\nimport { deserializeMessage } from \"../../serialize\";\nimport { getGlobal, globalStore, getGlobalKey } from \"../../global\";\nimport type {\n  OnType,\n  SendType,\n  MessageEvent,\n  CancelableType,\n} from \"../../types\";\n\nimport { handleRequest, handleResponse, handleAck } from \"./types\";\n\nfunction deserializeMessages(\n  message: string,\n  source: CrossDomainWindowType,\n  origin: string,\n  { on, send }: {| on: OnType, send: SendType |}\n): ?$ReadOnlyArray<Message> {\n  let parsedMessage;\n\n  try {\n    parsedMessage = deserializeMessage(source, origin, message, { on, send });\n  } catch (err) {\n    return;\n  }\n\n  if (!parsedMessage) {\n    return;\n  }\n\n  if (typeof parsedMessage !== \"object\" || parsedMessage === null) {\n    return;\n  }\n\n  const parseMessages = parsedMessage[getGlobalKey()];\n\n  if (!Array.isArray(parseMessages)) {\n    return;\n  }\n\n  return parseMessages;\n}\n\nexport function receiveMessage(\n  event: MessageEvent,\n  { on, send }: {| on: OnType, send: SendType |}\n) {\n  const receivedMessages = globalStore(\"receivedMessages\");\n\n  try {\n    if (!window || window.closed || !event.source) {\n      return;\n    }\n  } catch (err) {\n    return;\n  }\n\n  let { source, origin, data } = event;\n\n  if (__TEST__) {\n    if (isWindowClosed(source)) {\n      return;\n    }\n\n    // $FlowFixMe\n    origin = getDomain(source);\n  }\n\n  const messages = deserializeMessages(data, source, origin, { on, send });\n\n  if (!messages) {\n    return;\n  }\n\n  markWindowKnown(source);\n\n  for (const message of messages) {\n    if (receivedMessages.has(message.id)) {\n      return;\n    }\n\n    receivedMessages.set(message.id, true);\n\n    if (isWindowClosed(source) && !message.fireAndForget) {\n      return;\n    }\n\n    if (message.origin.indexOf(PROTOCOL.FILE) === 0) {\n      origin = `${PROTOCOL.FILE}//`;\n    }\n\n    try {\n      if (message.type === MESSAGE_TYPE.REQUEST) {\n        handleRequest(source, origin, message, { on, send });\n      } else if (message.type === MESSAGE_TYPE.RESPONSE) {\n        handleResponse(source, origin, message);\n      } else if (message.type === MESSAGE_TYPE.ACK) {\n        handleAck(source, origin, message);\n      }\n    } catch (err) {\n      setTimeout(() => {\n        throw err;\n      }, 0);\n    }\n  }\n}\n\nexport function setupGlobalReceiveMessage({\n  on,\n  send,\n}: {|\n  on: OnType,\n  send: SendType,\n|}) {\n  const global = getGlobal();\n  global.receiveMessage =\n    global.receiveMessage ||\n    ((message) => receiveMessage(message, { on, send }));\n}\n\ntype ListenerEvent = {|\n  source: CrossDomainWindowType,\n  origin: string,\n  data: string,\n  sourceElement: CrossDomainWindowType,\n  originalEvent?: {| origin: string |},\n|};\n\nexport function messageListener(\n  event: ListenerEvent,\n  { on, send }: {| on: OnType, send: SendType |}\n) {\n  ZalgoPromise.try(() => {\n    try {\n      noop(event.source);\n    } catch (err) {\n      return;\n    }\n\n    const source = event.source || event.sourceElement;\n    let origin =\n      event.origin || (event.originalEvent && event.originalEvent.origin);\n    const data = event.data;\n\n    if (origin === \"null\") {\n      origin = `${PROTOCOL.FILE}//`;\n    }\n\n    if (!source) {\n      return;\n    }\n\n    if (!origin) {\n      throw new Error(`Post message did not have origin domain`);\n    }\n\n    if (__TEST__) {\n      if (\n        needsGlobalMessagingForBrowser() &&\n        isSameTopWindow(source, window) === false\n      ) {\n        return;\n      }\n    }\n\n    receiveMessage({ source, origin, data }, { on, send });\n  });\n}\n\nexport function listenForMessages({\n  on,\n  send,\n}: {|\n  on: OnType,\n  send: SendType,\n|}): CancelableType {\n  return globalStore().getOrSet(\"postMessageListener\", () => {\n    return addEventListener(window, \"message\", (event) => {\n      // $FlowFixMe\n      messageListener(event, { on, send });\n    });\n  });\n}\n\nexport function stopListenForMessages() {\n  const listener = globalStore().get(\"postMessageListener\");\n  if (listener) {\n    listener.cancel();\n  }\n}\n","/* @flow */\n\nimport { ZalgoPromise } from \"@krakenjs/zalgo-promise/src\";\nimport {\n  getDomain,\n  isWindowClosed,\n  matchDomain,\n  stringifyDomainPattern,\n  type CrossDomainWindowType,\n} from \"@krakenjs/cross-domain-utils/src\";\nimport { noop, stringifyError, uniqueID } from \"@krakenjs/belter/src\";\n\nimport { MESSAGE_TYPE, MESSAGE_ACK, MESSAGE_NAME } from \"../../conf\";\nimport { sendMessage } from \"../send\";\nimport {\n  getRequestListener,\n  getResponseListener,\n  deleteResponseListener,\n  isResponseListenerErrored,\n} from \"../listeners\";\nimport type {\n  RequestMessage,\n  AckResponseMessage,\n  ResponseMessage,\n} from \"../types\";\nimport type { OnType, SendType } from \"../../types\";\n\nexport function handleRequest(\n  source: CrossDomainWindowType,\n  origin: string,\n  message: RequestMessage,\n  { on, send }: {| on: OnType, send: SendType |}\n): ZalgoPromise<void> {\n  const options = getRequestListener({\n    name: message.name,\n    win: source,\n    domain: origin,\n  });\n\n  const logName =\n    message.name === MESSAGE_NAME.METHOD &&\n    message.data &&\n    typeof message.data.name === \"string\"\n      ? `${message.data.name}()`\n      : message.name;\n\n  if (__DEBUG__) {\n    // eslint-disable-next-line no-console\n    console.info(\"receive::req\", logName, origin, \"\\n\\n\", message.data);\n  }\n\n  function sendAck(): ZalgoPromise<void> {\n    return ZalgoPromise.flush().then(() => {\n      if (message.fireAndForget || isWindowClosed(source)) {\n        return;\n      }\n\n      try {\n        return sendMessage(\n          source,\n          origin,\n          {\n            id: uniqueID(),\n            origin: getDomain(window),\n            type: MESSAGE_TYPE.ACK,\n            hash: message.hash,\n            name: message.name,\n          },\n          { on, send }\n        );\n      } catch (err) {\n        throw new Error(\n          `Send ack message failed for ${logName} in ${getDomain()}\\n\\n${stringifyError(\n            err\n          )}`\n        );\n      }\n    });\n  }\n\n  function sendResponse(\n    ack: $Values<typeof MESSAGE_ACK>,\n    data: ?Object,\n    error: ?mixed\n  ): ZalgoPromise<void> {\n    return ZalgoPromise.flush().then(() => {\n      if (message.fireAndForget || isWindowClosed(source)) {\n        return;\n      }\n\n      if (__DEBUG__) {\n        if (ack === MESSAGE_ACK.SUCCESS) {\n          console.info(\"respond::res\", logName, origin, \"\\n\\n\", data); // eslint-disable-line no-console\n        } else if (ack === MESSAGE_ACK.ERROR) {\n          console.error(\"respond::err\", logName, origin, \"\\n\\n\", error); // eslint-disable-line no-console\n        }\n      }\n\n      try {\n        return sendMessage(\n          source,\n          origin,\n          {\n            id: uniqueID(),\n            origin: getDomain(window),\n            type: MESSAGE_TYPE.RESPONSE,\n            hash: message.hash,\n            name: message.name,\n            ack,\n            data,\n            error,\n          },\n          { on, send }\n        );\n      } catch (err) {\n        throw new Error(\n          `Send response message failed for ${logName} in ${getDomain()}\\n\\n${stringifyError(\n            err\n          )}`\n        );\n      }\n    });\n  }\n\n  return ZalgoPromise.all([\n    sendAck(),\n\n    ZalgoPromise.try(() => {\n      if (!options) {\n        throw new Error(\n          `No handler found for post message: ${message.name} from ${origin} in ${window.location.protocol}//${window.location.host}${window.location.pathname}`\n        );\n      }\n\n      const data = message.data;\n\n      return options.handler({ source, origin, data });\n    }).then(\n      (data) => {\n        return sendResponse(MESSAGE_ACK.SUCCESS, data);\n      },\n      (error) => {\n        return sendResponse(MESSAGE_ACK.ERROR, null, error);\n      }\n    ),\n  ])\n    .then(noop)\n    .catch((err) => {\n      if (options && options.handleError) {\n        return options.handleError(err);\n      } else {\n        throw err;\n      }\n    });\n}\n\nexport function handleAck(\n  source: CrossDomainWindowType,\n  origin: string,\n  message: AckResponseMessage\n) {\n  if (isResponseListenerErrored(message.hash)) {\n    return;\n  }\n\n  const options = getResponseListener(message.hash);\n\n  if (!options) {\n    throw new Error(\n      `No handler found for post message ack for message: ${message.name} from ${origin} in ${window.location.protocol}//${window.location.host}${window.location.pathname}`\n    );\n  }\n\n  try {\n    if (!matchDomain(options.domain, origin)) {\n      throw new Error(\n        `Ack origin ${origin} does not match domain ${options.domain.toString()}`\n      );\n    }\n\n    if (source !== options.win) {\n      throw new Error(`Ack source does not match registered window`);\n    }\n  } catch (err) {\n    options.promise.reject(err);\n  }\n\n  options.ack = true;\n}\n\nexport function handleResponse(\n  source: CrossDomainWindowType,\n  origin: string,\n  message: ResponseMessage\n): void | ZalgoPromise<void> {\n  if (isResponseListenerErrored(message.hash)) {\n    return;\n  }\n\n  const options = getResponseListener(message.hash);\n\n  if (!options) {\n    throw new Error(\n      `No handler found for post message response for message: ${message.name} from ${origin} in ${window.location.protocol}//${window.location.host}${window.location.pathname}`\n    );\n  }\n\n  if (!matchDomain(options.domain, origin)) {\n    throw new Error(\n      `Response origin ${origin} does not match domain ${stringifyDomainPattern(\n        options.domain\n      )}`\n    );\n  }\n\n  if (source !== options.win) {\n    throw new Error(`Response source does not match registered window`);\n  }\n\n  deleteResponseListener(message.hash);\n\n  const logName =\n    message.name === MESSAGE_NAME.METHOD &&\n    message.data &&\n    typeof message.data.name === \"string\"\n      ? `${message.data.name}()`\n      : message.name;\n\n  if (message.ack === MESSAGE_ACK.ERROR) {\n    if (__DEBUG__) {\n      console.error(\"receive::err\", logName, origin, \"\\n\\n\", message.error); // eslint-disable-line no-console\n    }\n\n    options.promise.reject(message.error);\n  } else if (message.ack === MESSAGE_ACK.SUCCESS) {\n    if (__DEBUG__) {\n      console.info(\"receive::res\", logName, origin, \"\\n\\n\", message.data); // eslint-disable-line no-console\n    }\n\n    options.promise.resolve({ source, origin, data: message.data });\n  }\n}\n","/* @flow */\n\nimport { ZalgoPromise } from \"@krakenjs/zalgo-promise/src\";\n\nimport { addRequestListener } from \"../drivers\";\nimport { WILDCARD } from \"../conf\";\nimport type { ServerOptionsType, HandlerType, CancelableType } from \"../types\";\n\nconst getDefaultServerOptions = (): ServerOptionsType => {\n  // $FlowFixMe\n  return {};\n};\n\nexport function on(\n  name: string,\n  options: ServerOptionsType | HandlerType,\n  handler: ?HandlerType\n): CancelableType {\n  if (!name) {\n    throw new Error(\"Expected name\");\n  }\n\n  options = options || getDefaultServerOptions();\n  if (typeof options === \"function\") {\n    handler = options;\n    options = getDefaultServerOptions();\n  }\n\n  if (!handler) {\n    throw new Error(\"Expected handler\");\n  }\n\n  const winOrProxyWin = options.window;\n  const domain = options.domain || WILDCARD;\n\n  const successHandler = handler || options.handler;\n  const errorHandler =\n    options.errorHandler ||\n    ((err) => {\n      throw err;\n    });\n\n  const requestListener = addRequestListener(\n    { name, win: winOrProxyWin, domain },\n    {\n      handler: successHandler,\n      handleError: errorHandler,\n    }\n  );\n\n  return {\n    cancel() {\n      requestListener.cancel();\n    },\n  };\n}\n\ntype CancelableZalgoPromise<T> = ZalgoPromise<T> & {|\n  cancel: () => void,\n|};\n\nexport function once(\n  name: string,\n  options?: ServerOptionsType | HandlerType,\n  handler?: HandlerType\n): CancelableZalgoPromise<{| source: mixed, origin: string, data: Object |}> {\n  options = options || getDefaultServerOptions();\n  if (typeof options === \"function\") {\n    handler = options;\n    options = getDefaultServerOptions();\n  }\n\n  const promise = new ZalgoPromise();\n  let listener; // eslint-disable-line prefer-const\n\n  options.errorHandler = (err) => {\n    listener.cancel();\n    promise.reject(err);\n  };\n\n  listener = on(name, options, (event) => {\n    listener.cancel();\n    promise.resolve(event);\n    if (handler) {\n      return handler(event);\n    }\n  });\n\n  // $FlowFixMe\n  promise.cancel = listener.cancel;\n\n  // $FlowFixMe\n  return promise;\n}\n","/* @flow */\n\nimport { getUserAgent } from \"@krakenjs/cross-domain-utils/src\";\n\nexport function needsGlobalMessagingForBrowser(): boolean {\n  if (getUserAgent(window).match(/MSIE|rv:11|trident|edge\\/12|edge\\/13/i)) {\n    return true;\n  }\n\n  return false;\n}\n","/* @flow */\n\nimport { ZalgoPromise } from \"@krakenjs/zalgo-promise/src\";\nimport {\n  isAncestor,\n  isWindowClosed,\n  getDomain,\n  matchDomain,\n  type CrossDomainWindowType,\n  type DomainMatcher,\n} from \"@krakenjs/cross-domain-utils/src\";\nimport {\n  uniqueID,\n  isRegex,\n  noop,\n  safeInterval,\n  stringify,\n  stringifyError,\n} from \"@krakenjs/belter/src\";\n\nimport {\n  CHILD_WINDOW_TIMEOUT,\n  MESSAGE_TYPE,\n  WILDCARD,\n  MESSAGE_NAME,\n  ACK_TIMEOUT,\n  RES_TIMEOUT,\n  ACK_TIMEOUT_KNOWN,\n  RESPONSE_CYCLE_TIME,\n} from \"../conf\";\nimport {\n  sendMessage,\n  addResponseListener,\n  deleteResponseListener,\n  markResponseListenerErrored,\n  type ResponseListenerType,\n} from \"../drivers\";\nimport { awaitWindowHello, sayHello, isWindowKnown } from \"../lib\";\nimport { windowStore } from \"../global\";\nimport { ProxyWindow } from \"../serialize/window\";\nimport type { SendType } from \"../types\";\n\nimport { on } from \"./on\";\n\nfunction validateOptions(\n  name: string,\n  win: CrossDomainWindowType,\n  domain: ?DomainMatcher\n) {\n  if (!name) {\n    throw new Error(\"Expected name\");\n  }\n\n  if (domain) {\n    if (\n      typeof domain !== \"string\" &&\n      !Array.isArray(domain) &&\n      !isRegex(domain)\n    ) {\n      throw new TypeError(\n        `Can not send ${name}. Expected domain ${JSON.stringify(\n          domain\n        )} to be a string, array, or regex`\n      );\n    }\n  }\n\n  if (isWindowClosed(win)) {\n    throw new Error(`Can not send ${name}. Target window is closed`);\n  }\n}\n\nfunction normalizeDomain(\n  win: CrossDomainWindowType,\n  targetDomain: DomainMatcher,\n  actualDomain: ?string,\n  { send }: {| send: SendType |}\n): ZalgoPromise<string> {\n  return ZalgoPromise.try(() => {\n    if (typeof targetDomain === \"string\") {\n      return targetDomain;\n    }\n\n    return ZalgoPromise.try(() => {\n      return (\n        actualDomain || sayHello(win, { send }).then(({ domain }) => domain)\n      );\n    }).then((normalizedDomain) => {\n      if (!matchDomain(targetDomain, targetDomain)) {\n        throw new Error(\n          `Domain ${stringify(targetDomain)} does not match ${stringify(\n            targetDomain\n          )}`\n        );\n      }\n\n      return normalizedDomain;\n    });\n  });\n}\n\nexport const send: SendType = (winOrProxyWin, name, data, options) => {\n  options = options || {};\n  const domainMatcher = options.domain || WILDCARD;\n  const responseTimeout = options.timeout || RES_TIMEOUT;\n  const childTimeout = options.timeout || CHILD_WINDOW_TIMEOUT;\n  const fireAndForget = options.fireAndForget || false;\n\n  return ProxyWindow.toProxyWindow(winOrProxyWin, { send })\n    .awaitWindow()\n    .then((win) => {\n      // $FlowFixMe\n      return ZalgoPromise.try(() => {\n        validateOptions(name, win, domainMatcher);\n\n        if (isAncestor(window, win)) {\n          return awaitWindowHello(win, childTimeout);\n        }\n      })\n        .then(({ domain: actualDomain } = {}) => {\n          return normalizeDomain(win, domainMatcher, actualDomain, { send });\n        })\n        .then((targetDomain) => {\n          const domain = targetDomain;\n\n          const logName =\n            name === MESSAGE_NAME.METHOD &&\n            data &&\n            typeof data.name === \"string\"\n              ? `${data.name}()`\n              : name;\n\n          if (__DEBUG__) {\n            console.info(\"send::req\", logName, domain, \"\\n\\n\", data); // eslint-disable-line no-console\n          }\n\n          const promise = new ZalgoPromise();\n          const hash = `${name}_${uniqueID()}`;\n\n          if (!fireAndForget) {\n            const responseListener: ResponseListenerType = {\n              name,\n              win,\n              domain,\n              promise,\n            };\n            addResponseListener(hash, responseListener);\n\n            const reqPromises = windowStore(\"requestPromises\").getOrSet(\n              win,\n              () => []\n            );\n            reqPromises.push(promise);\n\n            promise.catch(() => {\n              markResponseListenerErrored(hash);\n              deleteResponseListener(hash);\n            });\n\n            const totalAckTimeout = isWindowKnown(win)\n              ? ACK_TIMEOUT_KNOWN\n              : ACK_TIMEOUT;\n            const totalResTimeout = responseTimeout;\n\n            let ackTimeout = totalAckTimeout;\n            let resTimeout = totalResTimeout;\n\n            const interval = safeInterval(() => {\n              if (isWindowClosed(win)) {\n                return promise.reject(\n                  new Error(\n                    `Window closed for ${name} before ${\n                      responseListener.ack ? \"response\" : \"ack\"\n                    }`\n                  )\n                );\n              }\n\n              if (responseListener.cancelled) {\n                return promise.reject(\n                  new Error(`Response listener was cancelled for ${name}`)\n                );\n              }\n\n              ackTimeout = Math.max(ackTimeout - RESPONSE_CYCLE_TIME, 0);\n              if (resTimeout !== -1) {\n                resTimeout = Math.max(resTimeout - RESPONSE_CYCLE_TIME, 0);\n              }\n\n              if (!responseListener.ack && ackTimeout === 0) {\n                return promise.reject(\n                  new Error(\n                    `No ack for postMessage ${logName} in ${getDomain()} in ${totalAckTimeout}ms`\n                  )\n                );\n              } else if (resTimeout === 0) {\n                return promise.reject(\n                  new Error(\n                    `No response for postMessage ${logName} in ${getDomain()} in ${totalResTimeout}ms`\n                  )\n                );\n              }\n            }, RESPONSE_CYCLE_TIME);\n\n            promise\n              .finally(() => {\n                interval.cancel();\n                reqPromises.splice(reqPromises.indexOf(promise, 1));\n              })\n              .catch(noop);\n          }\n\n          return sendMessage(\n            win,\n            domain,\n            {\n              id: uniqueID(),\n              origin: getDomain(window),\n              type: MESSAGE_TYPE.REQUEST,\n              hash,\n              name,\n              data,\n              fireAndForget,\n            },\n            { on, send }\n          ).then(\n            () => {\n              return fireAndForget ? promise.resolve() : promise;\n            },\n            (err) => {\n              throw new Error(\n                `Send request message failed for ${logName} in ${getDomain()}\\n\\n${stringifyError(\n                  err\n                )}`\n              );\n            }\n          );\n        });\n    });\n};\n","/* @flow */\n\nexport const BRIDGE_TIMEOUT = 5000;\nexport const CHILD_WINDOW_TIMEOUT = 5000;\n\nexport const ACK_TIMEOUT = 2000;\nexport const ACK_TIMEOUT_KNOWN = 10000;\nexport const RES_TIMEOUT: number = __TEST__ ? 2000 : -1;\nexport const RESPONSE_CYCLE_TIME = 500;\n","/* @flow */\n\nimport type {\n  CrossDomainWindowType,\n  DomainMatcher,\n} from \"@krakenjs/cross-domain-utils/src\";\n\nimport { initHello } from \"./lib\";\nimport {\n  listenForMessages,\n  stopListenForMessages,\n  receiveMessage,\n  setupGlobalReceiveMessage,\n  cancelResponseListeners,\n} from \"./drivers\";\nimport { getGlobal, deleteGlobal } from \"./global\";\nimport { on, send } from \"./public\";\nimport { setupBridge } from \"./bridge\";\nimport {\n  serializeMessage as internalSerializeMessage,\n  deserializeMessage as internalDeserializeMessage,\n  ProxyWindow,\n} from \"./serialize\";\n\nexport function serializeMessage<T>(\n  destination: CrossDomainWindowType | ProxyWindow,\n  domain: DomainMatcher,\n  obj: T\n): string {\n  return internalSerializeMessage(destination, domain, obj, { on, send });\n}\n\nexport function deserializeMessage<T: mixed>(\n  source: CrossDomainWindowType | ProxyWindow,\n  origin: string,\n  message: string\n): T {\n  return internalDeserializeMessage(source, origin, message, { on, send });\n}\n\nexport function createProxyWindow(win?: CrossDomainWindowType): ProxyWindow {\n  return new ProxyWindow({ send, win });\n}\n\nexport function toProxyWindow(\n  win: CrossDomainWindowType | ProxyWindow\n): ProxyWindow {\n  return ProxyWindow.toProxyWindow(win, { send });\n}\n\nexport function setup() {\n  if (!getGlobal().initialized) {\n    getGlobal().initialized = true;\n\n    setupGlobalReceiveMessage({ on, send });\n    listenForMessages({ on, send });\n\n    if (__POST_ROBOT__.__IE_POPUP_SUPPORT__) {\n      setupBridge({ on, send, receiveMessage });\n    }\n\n    initHello({ on, send });\n  }\n}\n\nexport function destroy() {\n  cancelResponseListeners();\n  stopListenForMessages();\n  deleteGlobal();\n}\n","/* @flow */\n\nimport type { ZalgoPromise } from \"@krakenjs/zalgo-promise/src\";\nimport type {\n  CrossDomainWindowType,\n  DomainMatcher,\n} from \"@krakenjs/cross-domain-utils/src\";\n\nimport type { ProxyWindow } from \"./serialize/window\";\n\n// export something to force webpack to see this as an ES module\nexport const TYPES = true;\n\n// eslint-disable-next-line flowtype/require-exact-type\nexport type CancelableType = {\n  cancel: () => void,\n};\n\nexport type ErrorHandlerType = (err: mixed) => void;\n\nexport type HandlerType = ({|\n  source: CrossDomainWindowType,\n  origin: string,\n  data: any, // eslint-disable-line flowtype/no-weak-types\n|}) => void | any | ZalgoPromise<any>; // eslint-disable-line flowtype/no-weak-types\n\nexport type ServerOptionsType = {|\n  handler?: ?HandlerType,\n  errorHandler?: ?ErrorHandlerType,\n  window?: CrossDomainWindowType | ProxyWindow,\n  name?: ?string,\n  domain?: ?DomainMatcher,\n  once?: ?boolean,\n  errorOnClose?: ?boolean,\n|};\n\nexport type OnType = (\n  name: string,\n  options: ServerOptionsType | HandlerType,\n  handler: ?HandlerType\n) => CancelableType;\n\ntype RegularRequestOptionsType = {|\n  domain?: ?DomainMatcher,\n  fireAndForget?: false,\n  timeout?: ?number,\n|};\n\ntype FireAndForgetRequestOptionsType = {|\n  domain?: ?DomainMatcher,\n  fireAndForget: true,\n  timeout?: ?number,\n|};\n\nexport type RequestOptionsType =\n  | RegularRequestOptionsType\n  | FireAndForgetRequestOptionsType;\n\nexport type ResponseMessageEvent = {|\n  source: CrossDomainWindowType,\n  origin: string,\n  data: Object,\n|};\n\ntype RegularSendType = (\n  win: CrossDomainWindowType | ProxyWindow,\n  name: string,\n  data: ?Object,\n  options?: RegularRequestOptionsType\n) => ZalgoPromise<ResponseMessageEvent>;\n\ntype FireAndForgetSendType = (\n  win: CrossDomainWindowType | ProxyWindow,\n  name: string,\n  data: ?Object,\n  options?: FireAndForgetRequestOptionsType\n) => ZalgoPromise<void>;\n\nexport type SendType = RegularSendType & FireAndForgetSendType;\n\nexport type MessageEvent = {|\n  source: CrossDomainWindowType,\n  origin: string,\n  data: string,\n|};\n\n// eslint-disable-next-line flowtype/require-exact-type\nexport type CrossDomainFunctionType<A, R> = {\n  (...args: A): ZalgoPromise<R>,\n  fireAndForget: (...args: A) => ZalgoPromise<void>,\n  __id__?: string,\n  __name__?: string,\n};\n\nexport type ReceiveMessageType = (\n  MessageEvent,\n  {| on: OnType, send: SendType |}\n) => void;\n","/* @flow */\n\nimport { setup } from \"./setup\";\nimport {\n  setupBridge,\n  openBridge,\n  linkWindow,\n  linkUrl,\n  isBridge,\n  needsBridge,\n  needsBridgeForBrowser,\n  hasBridge,\n  needsBridgeForWin,\n  needsBridgeForDomain,\n  destroyBridges,\n} from \"./bridge\";\n\nexport { ZalgoPromise as Promise } from \"@krakenjs/zalgo-promise/src\";\n\nexport * from \"./types\";\nexport { ProxyWindow } from \"./serialize\";\nexport {\n  setup,\n  destroy,\n  serializeMessage,\n  deserializeMessage,\n  createProxyWindow,\n  toProxyWindow,\n} from \"./setup\";\nexport { on, once, send } from \"./public\";\nexport { markWindowKnown } from \"./lib\";\nexport { cleanUpWindow } from \"./clean\";\n\n// $FlowFixMe\nexport let bridge;\n\nif (__POST_ROBOT__.__IE_POPUP_SUPPORT__) {\n  bridge = {\n    setupBridge,\n    openBridge,\n    linkWindow,\n    linkUrl,\n    isBridge,\n    needsBridge,\n    needsBridgeForBrowser,\n    hasBridge,\n    needsBridgeForWin,\n    needsBridgeForDomain,\n    destroyBridges,\n  };\n}\n\nif (__POST_ROBOT__.__AUTO_SETUP__) {\n  setup();\n}\n","/* @flow */\n\nimport {\n  type CrossDomainWindowType,\n  isWindowClosed,\n} from \"@krakenjs/cross-domain-utils/src\";\nimport { noop } from \"@krakenjs/belter/src\";\n\nimport { windowStore } from \"./global\";\n\nexport function cleanUpWindow(win: CrossDomainWindowType) {\n  const requestPromises = windowStore(\"requestPromises\");\n  for (const promise of requestPromises.get(win, [])) {\n    promise\n      .reject(\n        new Error(\n          `Window ${\n            isWindowClosed(win) ? \"closed\" : \"cleaned up\"\n          } before response`\n        )\n      )\n      .catch(noop);\n  }\n}\n"],"sourceRoot":""}