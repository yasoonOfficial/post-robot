{"version":3,"sources":["webpack://postRobot/webpack/universalModuleDefinition","webpack://postRobot/webpack/bootstrap","webpack://postRobot/./node_modules/@krakenjs/cross-domain-utils/src/util.js","webpack://postRobot/./node_modules/@krakenjs/cross-domain-utils/src/constants.js","webpack://postRobot/./node_modules/@krakenjs/cross-domain-utils/src/utils.js","webpack://postRobot/./node_modules/@krakenjs/zalgo-promise/src/utils.js","webpack://postRobot/./node_modules/@krakenjs/zalgo-promise/src/exceptions.js","webpack://postRobot/./node_modules/@krakenjs/zalgo-promise/src/flush.js","webpack://postRobot/./node_modules/@krakenjs/zalgo-promise/src/promise.js","webpack://postRobot/./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js","webpack://postRobot/./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js","webpack://postRobot/./node_modules/@krakenjs/cross-domain-safe-weakmap/src/util.js","webpack://postRobot/./node_modules/@krakenjs/cross-domain-safe-weakmap/src/weakmap.js","webpack://postRobot/./node_modules/@krakenjs/belter/src/util.js","webpack://postRobot/./node_modules/@krakenjs/cross-domain-safe-weakmap/src/native.js","webpack://postRobot/./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","webpack://postRobot/./node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js","webpack://postRobot/./node_modules/@babel/runtime/helpers/esm/construct.js","webpack://postRobot/./node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js","webpack://postRobot/./node_modules/@babel/runtime/helpers/esm/isNativeFunction.js","webpack://postRobot/./node_modules/@krakenjs/belter/src/dom.js","webpack://postRobot/./src/global.js","webpack://postRobot/./node_modules/@krakenjs/belter/src/constants.js","webpack://postRobot/./src/lib/hello.js","webpack://postRobot/./src/conf/constants.js","webpack://postRobot/./src/lib/windows.js","webpack://postRobot/./node_modules/@krakenjs/universal-serialize/src/common.js","webpack://postRobot/./node_modules/@krakenjs/universal-serialize/src/constants.js","webpack://postRobot/./node_modules/@krakenjs/universal-serialize/src/serialize.js","webpack://postRobot/./node_modules/@krakenjs/universal-serialize/src/serializers/function.js","webpack://postRobot/./node_modules/@krakenjs/universal-serialize/src/serializers/error.js","webpack://postRobot/./node_modules/@krakenjs/universal-serialize/src/serializers/promise.js","webpack://postRobot/./node_modules/@krakenjs/universal-serialize/src/serializers/regex.js","webpack://postRobot/./node_modules/@krakenjs/universal-serialize/src/serializers/date.js","webpack://postRobot/./node_modules/@krakenjs/universal-serialize/src/serializers/array.js","webpack://postRobot/./node_modules/@krakenjs/universal-serialize/src/serializers/object.js","webpack://postRobot/./node_modules/@krakenjs/universal-serialize/src/serializers/string.js","webpack://postRobot/./node_modules/@krakenjs/universal-serialize/src/serializers/number.js","webpack://postRobot/./node_modules/@krakenjs/universal-serialize/src/serializers/boolean.js","webpack://postRobot/./node_modules/@krakenjs/universal-serialize/src/serializers/null.js","webpack://postRobot/./node_modules/@krakenjs/universal-serialize/src/serializers/undefined.js","webpack://postRobot/./node_modules/@krakenjs/universal-serialize/src/deserialize.js","webpack://postRobot/./src/serialize/window.js","webpack://postRobot/./src/bridge/common.js","webpack://postRobot/./src/serialize/function.js","webpack://postRobot/./src/serialize/serialize.js","webpack://postRobot/./src/serialize/promise.js","webpack://postRobot/./src/drivers/send/strategies.js","webpack://postRobot/./src/drivers/send/index.js","webpack://postRobot/./src/drivers/listeners.js","webpack://postRobot/./src/drivers/receive/index.js","webpack://postRobot/./src/drivers/receive/types.js","webpack://postRobot/./src/public/on.js","webpack://postRobot/./src/public/send.js","webpack://postRobot/./src/conf/config.js","webpack://postRobot/./src/setup.js","webpack://postRobot/./src/types.js","webpack://postRobot/./src/clean.js","webpack://postRobot/./src/index.js"],"names":["root","factory","exports","module","define","amd","self","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","hasOwnProperty","p","s","isRegex","item","toString","IE_WIN_ACCESS_ERROR","getActualProtocol","win","window","location","protocol","getProtocol","mockDomain","split","isAboutProtocol","getParent","parent","err","getOpener","opener","canReadFromWindow","getActualDomain","Error","PROTOCOL","host","getDomain","domain","indexOf","isSameDomain","desc","getOwnPropertyDescriptor","isMockProtocol","isActuallySameDomain","assertSameDomain","isAncestorParent","child","childParent","result","push","getParents","getFrames","frames","len","length","frame","iframeWindows","iframeFrames","isWindowClosed","allowMock","closed","message","mockclosed","top","iframeIndex","collection","safeIndexOf","contentWindow","parentNode","doc","ownerDocument","documentElement","contains","isFrameWindowClosed","getAncestor","matchDomain","pattern","origin","Array","isArray","Boolean","match","JSON","stringify","some","subpattern","isWindow","obj","Window","__cross_domain_utils_window_check__","getFrameForWindow","frameElement","_i21","_document$querySelect2","document","querySelectorAll","closeWindow","isIframe","parentElement","removeChild","close","isPromise","Promise","constructor","then","flushPromise","dispatchedErrors","possiblyUnhandledPromiseHandlers","activeCount","flushActive","promise","resolve","startActive","endActive","ZalgoPromise","handler","_this","resolved","rejected","errorHandled","error","handlers","dispatching","stack","isAsync","res","reject","_proto","prototype","dispatch","_this2","setTimeout","j","dispatchPossiblyUnhandledError","asyncReject","chain","firstPromise","secondPromise","_handlers$i","onSuccess","onError","promiseResult","catch","undefined","finally","onFinally","try","timeout","time","_this3","clearTimeout","toPromise","TypeError","lazy","all","promises","count","results","slice","prom","hash","awaitPromises","_loop","map","items","method","onPossiblyUnhandledException","cancel","splice","context","args","apply","delay","flush","_setPrototypeOf","setPrototypeOf","__proto__","_inheritsLoose","subClass","superClass","objectIDs","CrossDomainSafeWeakMap","weakmap","keys","values","Math","random","WeakMap","freeze","testWeakMap","testKey","set","hasNativeWeakMap","_cleanupClosedWindows","delete","isSafeToReadWrite","entry","writable","index","has","getOrSet","_getPrototypeOf","getPrototypeOf","_isNativeReflectConstruct","Reflect","construct","sham","Proxy","Date","e","_construct","Parent","Class","isNativeReflectConstruct","a","instance","Function","arguments","_wrapNativeSuper","_cache","Map","Wrapper","configurable","getFunctionName","fn","__name__","displayName","setFunctionName","uniqueID","chars","replace","charAt","floor","str","btoa","encodeURIComponent","p1","String","fromCharCode","parseInt","Buffer","from","base64encode","toISOString","toLowerCase","serializeArgs","subkey","val","uid","getObjectID","element","passed","Element","nodeType","style","_","isElement","getEmptyObject","memoizeGlobalIndex","memoizeGlobalIndexValidFrom","memoize","options","simpleCache","thisCache","_options$thisNamespac","thisNamespace","cacheTime","memoizeIndex","memoizedFunction","_len","_key","cache","cacheKey","_unused","cacheResult","now","reset","memoizePromise","memoizedPromiseFunction","_arguments","_len2","_key2","noop","stringifyError","level","newErr","clear","_ExtendableError","ExtendableError","_Error","_this6","captureStackTrace","getBody","body","isDocumentReady","readyState","isDocumentInteractive","interval","setInterval","clearInterval","currentScript","getCurrentScript","getStackTrace","stackDetails","exec","scriptLocation","_i22","_Array$prototype$slic2","getElementsByTagName","reverse","script","src","inferCurrentScript","currentUID","getGlobal","globalKey","__POST_ROBOT__","getAttribute","ATTRIBUTES","hashedString","total","charCodeAt","abs","strHashStr","dataset","setAttribute","getObj","globalStore","defStore","store","storeKey","defVal","del","WildCard","getWildcard","global","WINDOW_WILDCARD","windowStore","winStore","getStore","getInstanceID","resolveHelloPromise","_ref","helloPromises","existingPromise","newPromise","sayHello","_ref4","send","instanceID","_ref5","data","getWindowInstanceID","_ref6","_ref7","markWindowKnown","isSerializedType","__type__","determineType","serializeType","type","__val__","SERIALIZER","_SERIALIZER","code","source","toJSON","defaultSerializers","DESERIALIZER","_DESERIALIZER","_ref2","RegExp","defaultDeserializers","cleanupProxyWindows","idToProxyWindow","_i2","_idToProxyWindow$keys2","id","shouldClean","getSerializedWindow","winPromise","_ref$id","windowNamePromise","windowTypePromise","getName","getType","focus","isClosed","setLocation","href","opts","_opts$method","_ref3","url","target","_ref3$method","form","createElement","display","_i24","_Object$keys4","_body$key","input","appendChild","submit","submitForm","setName","sameDomain","ProxyWindow","serializedWindow","isProxyWindow","actualWindow","actualWindowPromise","getID","setWindow","isPopup","_this4","isPopupPromise","getNamePromise","reopenPromise","open","focusPromise","getWindow","awaitWindow","matchWindow","_this5","proxyInstanceID","knownWindowInstanceID","unwrap","serialize","toProxyWindow","deserialize","_ref8","_ref9","addMethod","methodStore","proxyWindowMethods","lookupMethod","serializeFunction","destination","on","meth","methodSource","arg","join","__id__","serializeMessage","_serialize","serializers","serializer","serializePromise","deserializeMessage","_deserialize","deserializers","parse","deserializer","serializedPromise","deserializePromise","serializedFunction","getDeserializedFunction","crossDomainFunctionWrapper","fireAndForget","__origin__","__source__","deserializeFunction","SEND_MESSAGE_STRATEGIES","sendMessage","domainBuffer","buffer","serializedMessage","strategies","errors","strategyName","getResponseListener","deleteResponseListener","isResponseListenerErrored","getRequestListener","requestListeners","_i4","winQualifier","nameListeners","domainListeners","_i6","_domainListeners$__DO2","_domainListeners$__DO3","listener","regex","receiveMessage","event","receivedMessages","messages","parsedMessage","parseMessages","deserializeMessages","_ret","v","logName","sendResponse","ack","pathname","handleError","handleRequest","handleResponse","handleAck","requestListener","addRequestListener","winCandidate","requestListenerPromise","actualWin","listenersCollection","_i8","_win2","_i10","_i12","_domain2","_i14","existingListener","strDomain","winNameDomainRegexListeners","winNameDomainRegexListener","winNameListeners","winNameDomainListeners","errorHandler","once","postMessage","winOrProxyWin","domainMatcher","responseTimeout","childTimeout","validateOptions","actualParent","_i7","_getAllChildFrames4","getAllChildFrames","_i3","_getFrames2","_i5","_getAllChildFrames2","getTop","_i15","_getFrames8","isAncestor","getHelloPromise","awaitWindowHello","_temp","targetDomain","actualDomain","normalizedDomain","normalizeDomain","responseListener","addResponseListener","reqPromises","markResponseListenerErrored","totalAckTimeout","isWindowKnown","totalResTimeout","ackTimeout","resTimeout","cancelled","max","loop","internalSerializeMessage","internalDeserializeMessage","createProxyWindow","setup","initialized","addEventListener","sourceElement","originalEvent","messageListener","removeEventListener","listenForMessages","initHello","destroy","responseListeners","_responseListeners$ke2","cancelResponseListeners","TYPES","cleanUpWindow","_requestPromises$get2"],"mappings":"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","file":"post-robot.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"postRobot\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"postRobot\"] = factory();\n\telse\n\t\troot[\"postRobot\"] = factory();\n})((typeof self !== 'undefined' ? self : this), function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","/* @flow */\n\nexport function isRegex(item: mixed): boolean {\n  // $FlowFixMe method-unbinding\n  return Object.prototype.toString.call(item) === \"[object RegExp]\";\n}\n\n// eslint-disable-next-line no-unused-vars\nexport function noop(...args: $ReadOnlyArray<mixed>) {\n  // pass\n}\n","/* @flow */\n\nexport const PROTOCOL = {\n  MOCK: (\"mock:\": \"mock:\"),\n  FILE: (\"file:\": \"file:\"),\n  ABOUT: (\"about:\": \"about:\"),\n};\n\nexport const WILDCARD = \"*\";\n\nexport const WINDOW_TYPE = {\n  IFRAME: (\"iframe\": \"iframe\"),\n  POPUP: (\"popup\": \"popup\"),\n};\n","/* @flow */\n/* eslint max-lines: 0 */\n\nimport { isRegex, noop } from \"./util\";\nimport type {\n  CrossDomainWindowType,\n  SameDomainWindowType,\n  DomainMatcher,\n} from \"./types\";\nimport { PROTOCOL, WILDCARD } from \"./constants\";\n\nconst IE_WIN_ACCESS_ERROR = \"Call was rejected by callee.\\r\\n\";\n\nexport function getActualProtocol(win: SameDomainWindowType = window): ?string {\n  return win.location.protocol;\n}\n\nexport function getProtocol(win: SameDomainWindowType = window): ?string {\n  if (win.mockDomain) {\n    const protocol = win.mockDomain.split(\"//\")[0];\n\n    if (protocol) {\n      return protocol;\n    }\n  }\n\n  return getActualProtocol(win);\n}\n\nexport function isFileProtocol(win: SameDomainWindowType = window): boolean {\n  return getProtocol(win) === PROTOCOL.FILE;\n}\n\nexport function isAboutProtocol(win: SameDomainWindowType = window): boolean {\n  return getProtocol(win) === PROTOCOL.ABOUT;\n}\n\nexport function isMockProtocol(win: SameDomainWindowType = window): boolean {\n  return getProtocol(win) === PROTOCOL.MOCK;\n}\n\nexport function getParent(\n  win?: CrossDomainWindowType = window\n): ?CrossDomainWindowType {\n  if (!win) {\n    return;\n  }\n\n  try {\n    if (win.parent && win.parent !== win) {\n      return win.parent;\n    }\n  } catch (err) {\n    // pass\n  }\n}\n\nexport function getOpener(\n  win?: CrossDomainWindowType = window\n): ?CrossDomainWindowType {\n  if (!win) {\n    return;\n  }\n\n  // Make sure we're not actually an iframe which has had window.open() called on us\n  if (getParent(win)) {\n    return;\n  }\n\n  try {\n    return win.opener;\n  } catch (err) {\n    // pass\n  }\n}\n\nexport function canReadFromWindow(\n  win: CrossDomainWindowType | SameDomainWindowType\n): boolean {\n  try {\n    // $FlowFixMe\n    noop(win && win.location && win.location.href);\n    return true;\n  } catch (err) {\n    // pass\n  }\n\n  return false;\n}\n\nexport function getActualDomain(win?: SameDomainWindowType = window): string {\n  const location = win.location;\n\n  if (!location) {\n    throw new Error(`Can not read window location`);\n  }\n\n  const protocol = getActualProtocol(win);\n\n  if (!protocol) {\n    throw new Error(`Can not read window protocol`);\n  }\n\n  if (protocol === PROTOCOL.FILE) {\n    return `${PROTOCOL.FILE}//`;\n  }\n\n  if (protocol === PROTOCOL.ABOUT) {\n    const parent = getParent(win);\n    if (parent && canReadFromWindow(parent)) {\n      // $FlowFixMe\n      return getActualDomain(parent);\n    }\n\n    return `${PROTOCOL.ABOUT}//`;\n  }\n\n  const host = location.host;\n\n  if (!host) {\n    throw new Error(`Can not read window host`);\n  }\n\n  return `${protocol}//${host}`;\n}\n\nexport function getDomain(win?: SameDomainWindowType = window): string {\n  const domain = getActualDomain(win);\n\n  if (domain && win.mockDomain && win.mockDomain.indexOf(PROTOCOL.MOCK) === 0) {\n    return win.mockDomain;\n  }\n\n  return domain;\n}\n\nexport function isBlankDomain(win: CrossDomainWindowType): boolean {\n  try {\n    // $FlowFixMe\n    if (!win.location.href) {\n      return true;\n    }\n\n    if (win.location.href === \"about:blank\") {\n      return true;\n    }\n  } catch (err) {\n    // pass\n  }\n\n  return false;\n}\n\nexport function isActuallySameDomain(win: CrossDomainWindowType): boolean {\n  try {\n    if (win === window) {\n      return true;\n    }\n  } catch (err) {\n    // pass\n  }\n\n  try {\n    const desc = Object.getOwnPropertyDescriptor(win, \"location\");\n\n    if (desc && desc.enumerable === false) {\n      return false;\n    }\n  } catch (err) {\n    // pass\n  }\n\n  try {\n    // $FlowFixMe\n    if (isAboutProtocol(win) && canReadFromWindow(win)) {\n      return true;\n    }\n  } catch (err) {\n    // pass\n  }\n\n  try {\n    // $FlowFixMe\n    if (isMockProtocol(win) && canReadFromWindow(win)) {\n      return true;\n    }\n  } catch (err) {\n    // pass\n  }\n\n  try {\n    // $FlowFixMe\n    if (getActualDomain(win) === getActualDomain(window)) {\n      return true;\n    }\n  } catch (err) {\n    // pass\n  }\n\n  return false;\n}\n\nexport function isSameDomain(\n  win: CrossDomainWindowType | SameDomainWindowType\n): boolean {\n  if (!isActuallySameDomain(win)) {\n    return false;\n  }\n\n  try {\n    if (win === window) {\n      return true;\n    }\n\n    // $FlowFixMe\n    if (isAboutProtocol(win) && canReadFromWindow(win)) {\n      return true;\n    }\n\n    // $FlowFixMe\n    if (getDomain(window) === getDomain(win)) {\n      return true;\n    }\n  } catch (err) {\n    // pass\n  }\n\n  return false;\n}\n\nexport function assertSameDomain(\n  win: CrossDomainWindowType | SameDomainWindowType\n): SameDomainWindowType {\n  if (!isSameDomain(win)) {\n    throw new Error(`Expected window to be same domain`);\n  }\n\n  // $FlowFixMe\n  return win;\n}\n\nexport function getParents(\n  win: CrossDomainWindowType\n): $ReadOnlyArray<CrossDomainWindowType> {\n  const result = [];\n\n  try {\n    while (win.parent !== win) {\n      result.push(win.parent);\n      win = win.parent;\n    }\n  } catch (err) {\n    // pass\n  }\n\n  return result;\n}\n\nexport function isAncestorParent(\n  parent: CrossDomainWindowType,\n  child: CrossDomainWindowType\n): boolean {\n  if (!parent || !child) {\n    return false;\n  }\n\n  const childParent = getParent(child);\n\n  if (childParent) {\n    return childParent === parent;\n  }\n\n  if (getParents(child).indexOf(parent) !== -1) {\n    return true;\n  }\n\n  return false;\n}\n\nexport function getFrames(\n  win: CrossDomainWindowType\n): $ReadOnlyArray<CrossDomainWindowType> {\n  const result = [];\n\n  let frames;\n\n  try {\n    frames = win.frames;\n  } catch (err) {\n    frames = win;\n  }\n\n  let len;\n\n  try {\n    len = frames.length;\n  } catch (err) {\n    // pass\n  }\n\n  if (len === 0) {\n    return result;\n  }\n\n  if (len) {\n    for (let i = 0; i < len; i++) {\n      let frame;\n\n      try {\n        frame = frames[i];\n      } catch (err) {\n        continue;\n      }\n\n      result.push(frame);\n    }\n\n    return result;\n  }\n\n  for (let i = 0; i < 100; i++) {\n    let frame;\n\n    try {\n      frame = frames[i];\n    } catch (err) {\n      return result;\n    }\n\n    if (!frame) {\n      return result;\n    }\n\n    result.push(frame);\n  }\n\n  return result;\n}\n\nexport function getAllChildFrames(\n  win: CrossDomainWindowType\n): $ReadOnlyArray<CrossDomainWindowType> {\n  const result = [];\n\n  for (const frame of getFrames(win)) {\n    result.push(frame);\n\n    for (const childFrame of getAllChildFrames(frame)) {\n      result.push(childFrame);\n    }\n  }\n\n  return result;\n}\n\nexport function getTop(\n  win?: CrossDomainWindowType = window\n): ?CrossDomainWindowType {\n  try {\n    if (win.top) {\n      return win.top;\n    }\n  } catch (err) {\n    // pass\n  }\n\n  if (getParent(win) === win) {\n    return win;\n  }\n\n  try {\n    if (isAncestorParent(window, win) && window.top) {\n      return window.top;\n    }\n  } catch (err) {\n    // pass\n  }\n\n  try {\n    if (isAncestorParent(win, window) && window.top) {\n      return window.top;\n    }\n  } catch (err) {\n    // pass\n  }\n\n  for (const frame of getAllChildFrames(win)) {\n    try {\n      if (frame.top) {\n        return frame.top;\n      }\n    } catch (err) {\n      // pass\n    }\n\n    if (getParent(frame) === frame) {\n      return frame;\n    }\n  }\n}\n\nexport function getNextOpener(\n  win?: CrossDomainWindowType = window\n): ?CrossDomainWindowType {\n  return getOpener(getTop(win) || win);\n}\n\nexport function getUltimateTop(\n  win?: CrossDomainWindowType = window\n): CrossDomainWindowType {\n  const opener = getNextOpener(win);\n\n  if (opener) {\n    return getUltimateTop(opener);\n  }\n\n  return top;\n}\n\nexport function getAllFramesInWindow(\n  win: CrossDomainWindowType\n): $ReadOnlyArray<CrossDomainWindowType> {\n  const top = getTop(win);\n\n  if (!top) {\n    throw new Error(`Can not determine top window`);\n  }\n\n  let result = [...getAllChildFrames(top), top];\n\n  // Win may be in shadow dom\n  if (result.indexOf(win) === -1) {\n    result = [...result, win, ...getAllChildFrames(win)];\n  }\n\n  return result;\n}\n\nexport function getAllWindows(\n  win?: CrossDomainWindowType = window\n): $ReadOnlyArray<CrossDomainWindowType> {\n  const frames = getAllFramesInWindow(win);\n  const opener = getNextOpener(win);\n\n  if (opener) {\n    return [...getAllWindows(opener), ...frames];\n  } else {\n    return frames;\n  }\n}\n\nexport function isTop(win: CrossDomainWindowType): boolean {\n  return win === getTop(win);\n}\n\nexport function isFrameWindowClosed(frame: HTMLIFrameElement): boolean {\n  if (!frame.contentWindow) {\n    return true;\n  }\n\n  if (!frame.parentNode) {\n    return true;\n  }\n\n  const doc = frame.ownerDocument;\n\n  if (doc && doc.documentElement && !doc.documentElement.contains(frame)) {\n    let parent = frame;\n\n    while (parent.parentNode && parent.parentNode !== parent) {\n      parent = parent.parentNode;\n    }\n\n    // $FlowFixMe\n    if (!parent.host || !doc.documentElement.contains(parent.host)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction safeIndexOf<T>(collection: $ReadOnlyArray<T>, item: T): number {\n  for (let i = 0; i < collection.length; i++) {\n    try {\n      if (collection[i] === item) {\n        return i;\n      }\n    } catch (err) {\n      // pass\n    }\n  }\n\n  return -1;\n}\n\nconst iframeWindows = [];\nconst iframeFrames = [];\n\nexport function isWindowClosed(\n  win: CrossDomainWindowType,\n  allowMock: boolean = true\n): boolean {\n  try {\n    if (win === window) {\n      return false;\n    }\n  } catch (err) {\n    return true;\n  }\n\n  try {\n    if (!win) {\n      return true;\n    }\n  } catch (err) {\n    return true;\n  }\n\n  try {\n    if (win.closed) {\n      return true;\n    }\n  } catch (err) {\n    // I love you so much IE\n\n    if (err && err.message === IE_WIN_ACCESS_ERROR) {\n      return false;\n    }\n\n    return true;\n  }\n\n  if (allowMock && isSameDomain(win)) {\n    try {\n      // $FlowFixMe\n      if (win.mockclosed) {\n        return true;\n      }\n    } catch (err) {\n      // pass\n    }\n  }\n\n  // Mobile safari\n\n  try {\n    if (!win.parent || !win.top) {\n      return true;\n    }\n  } catch (err) {\n    // pass\n  }\n\n  // Yes, this actually happens in IE. win === win errors out when the window\n  // is from an iframe, and the iframe was removed from the page.\n\n  try {\n    noop(win === win); // eslint-disable-line no-self-compare\n  } catch (err) {\n    return true;\n  }\n\n  // IE orphaned frame\n\n  const iframeIndex = safeIndexOf(iframeWindows, win);\n\n  if (iframeIndex !== -1) {\n    const frame = iframeFrames[iframeIndex];\n\n    if (frame && isFrameWindowClosed(frame)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction cleanIframes() {\n  for (let i = 0; i < iframeWindows.length; i++) {\n    let closed = false;\n\n    try {\n      closed = iframeWindows[i].closed;\n    } catch (err) {\n      // pass\n    }\n\n    if (closed) {\n      iframeFrames.splice(i, 1);\n      iframeWindows.splice(i, 1);\n    }\n  }\n}\n\nexport function linkFrameWindow(frame: HTMLIFrameElement) {\n  cleanIframes();\n\n  if (frame && frame.contentWindow) {\n    try {\n      iframeWindows.push(frame.contentWindow);\n      iframeFrames.push(frame);\n    } catch (err) {\n      // pass\n    }\n  }\n}\n\nexport function getUserAgent(win: ?SameDomainWindowType): string {\n  win = win || window;\n  return win.navigator.mockUserAgent || win.navigator.userAgent;\n}\n\nexport function getFrameByName(\n  win: CrossDomainWindowType,\n  name: string\n): ?CrossDomainWindowType {\n  const winFrames = getFrames(win);\n\n  for (const childFrame of winFrames) {\n    try {\n      if (\n        isSameDomain(childFrame) &&\n        // $FlowFixMe\n        childFrame.name === name &&\n        winFrames.indexOf(childFrame) !== -1\n      ) {\n        return childFrame;\n      }\n    } catch (err) {\n      // pass\n    }\n  }\n\n  try {\n    // $FlowFixMe\n    if (winFrames.indexOf(win.frames[name]) !== -1) {\n      // $FlowFixMe\n      return win.frames[name];\n    }\n  } catch (err) {\n    // pass\n  }\n\n  try {\n    if (winFrames.indexOf(win[name]) !== -1) {\n      return win[name];\n    }\n  } catch (err) {\n    // pass\n  }\n}\n\nexport function findChildFrameByName(\n  win: CrossDomainWindowType,\n  name: string\n): ?CrossDomainWindowType {\n  const frame = getFrameByName(win, name);\n\n  if (frame) {\n    return frame;\n  }\n\n  for (const childFrame of getFrames(win)) {\n    const namedFrame = findChildFrameByName(childFrame, name);\n\n    if (namedFrame) {\n      return namedFrame;\n    }\n  }\n}\n\nexport function findFrameByName(\n  win: CrossDomainWindowType,\n  name: string\n): ?CrossDomainWindowType {\n  const frame = getFrameByName(win, name);\n\n  if (frame) {\n    return frame;\n  }\n\n  const top = getTop(win) || win;\n\n  return findChildFrameByName(top, name);\n}\n\nexport function isParent(\n  win: CrossDomainWindowType,\n  frame: CrossDomainWindowType\n): boolean {\n  const frameParent = getParent(frame);\n\n  if (frameParent) {\n    return frameParent === win;\n  }\n\n  for (const childFrame of getFrames(win)) {\n    if (childFrame === frame) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexport function isOpener(\n  parent: CrossDomainWindowType,\n  child: CrossDomainWindowType\n): boolean {\n  return parent === getOpener(child);\n}\n\nexport function getAncestor(\n  win?: CrossDomainWindowType = window\n): ?CrossDomainWindowType {\n  win = win || window;\n\n  const opener = getOpener(win);\n\n  if (opener) {\n    return opener;\n  }\n\n  const parent = getParent(win);\n\n  if (parent) {\n    return parent;\n  }\n}\n\nexport function getAncestors(\n  win: CrossDomainWindowType\n): $ReadOnlyArray<CrossDomainWindowType> {\n  const results = [];\n\n  let ancestor = win;\n\n  while (ancestor) {\n    ancestor = getAncestor(ancestor);\n    if (ancestor) {\n      results.push(ancestor);\n    }\n  }\n\n  return results;\n}\n\nexport function isAncestor(\n  parent: CrossDomainWindowType,\n  child: CrossDomainWindowType\n): boolean {\n  const actualParent = getAncestor(child);\n\n  if (actualParent) {\n    if (actualParent === parent) {\n      return true;\n    }\n\n    return false;\n  }\n\n  if (child === parent) {\n    return false;\n  }\n\n  if (getTop(child) === child) {\n    return false;\n  }\n\n  for (const frame of getFrames(parent)) {\n    if (frame === child) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexport function isPopup(win?: CrossDomainWindowType = window): boolean {\n  return Boolean(getOpener(win));\n}\n\nexport function isIframe(win?: CrossDomainWindowType = window): boolean {\n  return Boolean(getParent(win));\n}\n\nexport function isFullpage(win?: CrossDomainWindowType = window): boolean {\n  return Boolean(!isIframe(win) && !isPopup(win));\n}\n\nfunction anyMatch(collection1, collection2): boolean {\n  for (const item1 of collection1) {\n    for (const item2 of collection2) {\n      if (item1 === item2) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\nexport function getDistanceFromTop(\n  win: CrossDomainWindowType = window\n): number {\n  let distance = 0;\n  let parent = win;\n\n  while (parent) {\n    parent = getParent(parent);\n    if (parent) {\n      distance += 1;\n    }\n  }\n\n  return distance;\n}\n\nexport function getNthParent(\n  win: CrossDomainWindowType,\n  n: number = 1\n): ?CrossDomainWindowType {\n  let parent = win;\n\n  for (let i = 0; i < n; i++) {\n    if (!parent) {\n      return;\n    }\n\n    parent = getParent(parent);\n  }\n\n  return parent;\n}\n\nexport function getNthParentFromTop(\n  win: CrossDomainWindowType,\n  n: number = 1\n): ?CrossDomainWindowType {\n  return getNthParent(win, getDistanceFromTop(win) - n);\n}\n\nexport function isSameTopWindow(\n  win1: CrossDomainWindowType,\n  win2: CrossDomainWindowType\n): boolean {\n  const top1 = getTop(win1) || win1;\n  const top2 = getTop(win2) || win2;\n\n  try {\n    if (top1 && top2) {\n      if (top1 === top2) {\n        return true;\n      }\n\n      return false;\n    }\n  } catch (err) {\n    // pass\n  }\n\n  const allFrames1 = getAllFramesInWindow(win1);\n  const allFrames2 = getAllFramesInWindow(win2);\n\n  if (anyMatch(allFrames1, allFrames2)) {\n    return true;\n  }\n\n  const opener1 = getOpener(top1);\n  const opener2 = getOpener(top2);\n\n  if (opener1 && anyMatch(getAllFramesInWindow(opener1), allFrames2)) {\n    return false;\n  }\n\n  if (opener2 && anyMatch(getAllFramesInWindow(opener2), allFrames1)) {\n    return false;\n  }\n\n  return false;\n}\n\nexport function matchDomain(\n  pattern: DomainMatcher,\n  origin: DomainMatcher\n): boolean {\n  if (typeof pattern === \"string\") {\n    if (typeof origin === \"string\") {\n      return pattern === WILDCARD || origin === pattern;\n    }\n\n    if (isRegex(origin)) {\n      return false;\n    }\n\n    if (Array.isArray(origin)) {\n      return false;\n    }\n  }\n\n  if (isRegex(pattern)) {\n    if (isRegex(origin)) {\n      return pattern.toString() === origin.toString();\n    }\n\n    if (Array.isArray(origin)) {\n      return false;\n    }\n\n    // $FlowFixMe\n    return Boolean(origin.match(pattern));\n  }\n\n  if (Array.isArray(pattern)) {\n    if (Array.isArray(origin)) {\n      return JSON.stringify(pattern) === JSON.stringify(origin);\n    }\n\n    if (isRegex(origin)) {\n      return false;\n    }\n\n    return pattern.some((subpattern) => matchDomain(subpattern, origin));\n  }\n\n  return false;\n}\n\nexport function stringifyDomainPattern(pattern: DomainMatcher): string {\n  if (Array.isArray(pattern)) {\n    return `(${pattern.join(\" | \")})`;\n  } else if (isRegex(pattern)) {\n    return `RegExp(${pattern.toString()})`;\n  } else {\n    return pattern.toString();\n  }\n}\n\nexport function getDomainFromUrl(url: string): string {\n  let domain;\n\n  if (url.match(/^(https?|mock|file):\\/\\//)) {\n    domain = url;\n  } else {\n    return getDomain();\n  }\n\n  domain = domain.split(\"/\").slice(0, 3).join(\"/\");\n\n  return domain;\n}\n\nexport function onCloseWindow(\n  win: CrossDomainWindowType,\n  callback: Function,\n  delay: number = 1000,\n  maxtime: number = Infinity\n): {| cancel: () => void |} {\n  let timeout;\n\n  const check = () => {\n    if (isWindowClosed(win)) {\n      if (timeout) {\n        clearTimeout(timeout);\n      }\n\n      return callback();\n    }\n\n    if (maxtime <= 0) {\n      clearTimeout(timeout);\n    } else {\n      maxtime -= delay;\n      timeout = setTimeout(check, delay);\n    }\n  };\n\n  check();\n\n  return {\n    cancel() {\n      if (timeout) {\n        clearTimeout(timeout);\n      }\n    },\n  };\n}\n\n// eslint-disable-next-line complexity\nexport function isWindow(obj: Object): boolean {\n  try {\n    if (obj === window) {\n      return true;\n    }\n  } catch (err) {\n    if (err && err.message === IE_WIN_ACCESS_ERROR) {\n      return true;\n    }\n  }\n\n  try {\n    // $FlowFixMe method-unbinding\n    if (Object.prototype.toString.call(obj) === \"[object Window]\") {\n      return true;\n    }\n  } catch (err) {\n    if (err && err.message === IE_WIN_ACCESS_ERROR) {\n      return true;\n    }\n  }\n\n  try {\n    if (window.Window && obj instanceof window.Window) {\n      return true;\n    }\n  } catch (err) {\n    if (err && err.message === IE_WIN_ACCESS_ERROR) {\n      return true;\n    }\n  }\n\n  try {\n    if (obj && obj.self === obj) {\n      return true;\n    }\n  } catch (err) {\n    if (err && err.message === IE_WIN_ACCESS_ERROR) {\n      return true;\n    }\n  }\n\n  try {\n    if (obj && obj.parent === obj) {\n      return true;\n    }\n  } catch (err) {\n    if (err && err.message === IE_WIN_ACCESS_ERROR) {\n      return true;\n    }\n  }\n\n  try {\n    if (obj && obj.top === obj) {\n      return true;\n    }\n  } catch (err) {\n    if (err && err.message === IE_WIN_ACCESS_ERROR) {\n      return true;\n    }\n  }\n\n  try {\n    // eslint-disable-next-line no-self-compare\n    if (noop(obj === obj) === \"__unlikely_value__\") {\n      return false;\n    }\n  } catch (err) {\n    return true;\n  }\n\n  try {\n    if (\n      obj &&\n      obj.__cross_domain_utils_window_check__ === \"__unlikely_value__\"\n    ) {\n      return false;\n    }\n  } catch (err) {\n    return true;\n  }\n\n  try {\n    if (\"postMessage\" in obj && \"self\" in obj && \"location\" in obj) {\n      return true;\n    }\n  } catch (err) {\n    // pass\n  }\n\n  return false;\n}\n\nexport function isBrowser(): boolean {\n  return (\n    typeof window !== \"undefined\" && typeof window.location !== \"undefined\"\n  );\n}\n\nexport function isCurrentDomain(domain: string): boolean {\n  if (!isBrowser()) {\n    return false;\n  }\n\n  return getDomain() === domain;\n}\n\nexport function isMockDomain(domain: string): boolean {\n  return domain.indexOf(PROTOCOL.MOCK) === 0;\n}\n\nexport function normalizeMockUrl(url: string): string {\n  if (!isMockDomain(getDomainFromUrl(url))) {\n    return url;\n  }\n\n  if (!__TEST__) {\n    throw new Error(`Mock urls not supported out of test mode`);\n  }\n\n  return url.replace(/^mock:\\/\\/[^/]+/, getActualDomain(window));\n}\n\nexport function getFrameForWindow(win: CrossDomainWindowType): ?HTMLElement {\n  if (isSameDomain(win)) {\n    return assertSameDomain(win).frameElement;\n  }\n\n  for (const frame of document.querySelectorAll(\"iframe\")) {\n    if (frame && frame.contentWindow && frame.contentWindow === win) {\n      return frame;\n    }\n  }\n}\n\nexport function closeWindow(win: CrossDomainWindowType) {\n  if (isIframe(win)) {\n    const frame = getFrameForWindow(win);\n    if (frame && frame.parentElement) {\n      frame.parentElement.removeChild(frame);\n      return;\n    }\n  }\n\n  try {\n    win.close();\n  } catch (err) {\n    // pass\n  }\n}\n","/* @flow */\n\nexport function isPromise(item : mixed) : boolean {\n    try {\n        if (!item) {\n            return false;\n        }\n\n        if (typeof Promise !== 'undefined' && item instanceof Promise) {\n            return true;\n        }\n\n        if (typeof window !== 'undefined' && typeof window.Window === 'function' && item instanceof window.Window) {\n            return false;\n        }\n\n        if (typeof window !== 'undefined' && typeof window.constructor === 'function' && item instanceof window.constructor) {\n            return false;\n        }\n\n        const toString = ({}).toString;\n\n        if (toString) {\n            const name = toString.call(item);\n\n            if (name === '[object Window]' || name === '[object global]' || name === '[object DOMWindow]') {\n                return false;\n            }\n        }\n\n        if (typeof item.then === 'function') {\n            return true;\n        }\n    } catch (err) {\n        return false;\n    }\n\n    return false;\n}\n","/* @flow */\n\nimport type { ZalgoPromise } from './promise';\n\nconst dispatchedErrors = [];\nconst possiblyUnhandledPromiseHandlers : Array<(mixed, promise? : ZalgoPromise<mixed>) => void> = [];\n\nexport function dispatchPossiblyUnhandledError<T>(err : mixed, promise : ZalgoPromise<T>) {\n\n    if (dispatchedErrors.indexOf(err) !== -1) {\n        return;\n    }\n\n    dispatchedErrors.push(err);\n\n    setTimeout(() => {\n        if (__DEBUG__) {\n            // $FlowFixMe\n            throw new Error(`${ err.stack || err.toString() }\\n\\nFrom promise:\\n\\n${ promise.stack }`);\n        }\n\n        throw err;\n    }, 1);\n\n    for (let j = 0; j < possiblyUnhandledPromiseHandlers.length; j++) {\n        // $FlowFixMe\n        possiblyUnhandledPromiseHandlers[j](err, promise);\n    }\n}\n\nexport function onPossiblyUnhandledException(handler : (mixed, promise? : ZalgoPromise<mixed>) => void) : {| cancel : () => void |} {\n    possiblyUnhandledPromiseHandlers.push(handler);\n\n    return {\n        cancel() {\n            possiblyUnhandledPromiseHandlers.splice(possiblyUnhandledPromiseHandlers.indexOf(handler), 1);\n        }\n    };\n}\n","/* @flow */\n\nimport type { ZalgoPromise } from './promise';\n\nlet activeCount = 0;\nlet flushPromise;\n\nfunction flushActive() {\n    if (!activeCount && flushPromise) {\n        const promise = flushPromise;\n        flushPromise = null;\n        promise.resolve();\n    }\n}\n\nexport function startActive() {\n    activeCount += 1;\n}\n\nexport function endActive() {\n    activeCount -= 1;\n    flushActive();\n}\n\nexport function awaitActive(Zalgo : Class<ZalgoPromise<*>>) : ZalgoPromise<void> { // eslint-disable-line no-undef\n    const promise = flushPromise = flushPromise || new Zalgo();\n    flushActive();\n    return promise;\n}\n","/* @flow */\n/* eslint no-use-before-define: off */\n\nimport { isPromise } from './utils';\nimport { onPossiblyUnhandledException, dispatchPossiblyUnhandledError } from './exceptions';\nimport { startActive, endActive, awaitActive } from './flush';\n\nexport class ZalgoPromise<R : mixed> {\n\n    resolved : boolean;\n    rejected : boolean;\n    errorHandled : boolean;\n    value : R;\n    error : mixed;\n    // eslint-disable-next-line flowtype/no-mutable-array\n    handlers : Array<{|\n        promise : ZalgoPromise<*>,\n        onSuccess : void | (result : R) => mixed,\n        onError : void | (error : mixed) => mixed\n    |}>;\n    dispatching : boolean;\n    stack : string;\n\n    constructor(handler : ?(resolve : (result : R) => void, reject : (error : mixed) => void) => void) {\n\n        this.resolved = false;\n        this.rejected = false;\n        this.errorHandled = false;\n\n        this.handlers = [];\n\n        if (handler) {\n\n            let result;\n            let error;\n            let resolved = false;\n            let rejected = false;\n            let isAsync = false;\n\n            startActive();\n\n            try {\n                handler(res => {\n                    if (isAsync) {\n                        this.resolve(res);\n                    } else {\n                        resolved = true;\n                        result = res;\n                    }\n\n                }, err => {\n                    if (isAsync) {\n                        this.reject(err);\n                    } else {\n                        rejected = true;\n                        error = err;\n                    }\n                });\n\n            } catch (err) {\n                endActive();\n                this.reject(err);\n                return;\n            }\n\n            endActive();\n\n            isAsync = true;\n\n            if (resolved) {\n                // $FlowFixMe\n                this.resolve(result);\n            } else if (rejected) {\n                this.reject(error);\n            }\n        }\n\n        if (__DEBUG__) {\n            try {\n                throw new Error(`ZalgoPromise`);\n            } catch (err) {\n                this.stack = err.stack;\n            }\n        }\n    }\n\n    resolve(result : R) : ZalgoPromise<R> {\n        if (this.resolved || this.rejected) {\n            return this;\n        }\n\n        if (isPromise(result)) {\n            throw new Error('Can not resolve promise with another promise');\n        }\n\n        this.resolved = true;\n        this.value = result;\n        this.dispatch();\n\n        return this;\n    }\n\n    reject(error : mixed) : ZalgoPromise<R> {\n        if (this.resolved || this.rejected) {\n            return this;\n        }\n\n        if (isPromise(error)) {\n            throw new Error('Can not reject promise with another promise');\n        }\n\n        if (!error) {\n            // $FlowFixMe\n            const err = (error && typeof error.toString === 'function' ? error.toString() : Object.prototype.toString.call(error));\n            error = new Error(`Expected reject to be called with Error, got ${ err }`);\n        }\n\n        this.rejected = true;\n        this.error = error;\n\n        if (!this.errorHandled) {\n            setTimeout(() => {\n                if (!this.errorHandled) {\n                    dispatchPossiblyUnhandledError(error, this);\n                }\n            }, 1);\n        }\n\n        this.dispatch();\n\n        return this;\n    }\n\n    asyncReject(error : mixed) : ZalgoPromise<R> {\n        this.errorHandled = true;\n        this.reject(error);\n        return this;\n    }\n\n    dispatch() {\n\n        const { dispatching, resolved, rejected, handlers } = this;\n\n        if (dispatching) {\n            return;\n        }\n\n        if (!resolved && !rejected) {\n            return;\n        }\n\n        this.dispatching = true;\n        startActive();\n\n        const chain = <T>(firstPromise : ZalgoPromise<T>, secondPromise : ZalgoPromise<T>) => {\n            return firstPromise.then(res => {\n                secondPromise.resolve(res);\n            }, err => {\n                secondPromise.reject(err);\n            });\n        };\n\n        for (let i = 0; i < handlers.length; i++) {\n\n            const { onSuccess, onError, promise } = handlers[i];\n\n            let result;\n\n            if (resolved) {\n\n                try {\n                    result = onSuccess ? onSuccess(this.value) : this.value;\n                } catch (err) {\n                    promise.reject(err);\n                    continue;\n                }\n\n            } else if (rejected) {\n\n                if (!onError) {\n                    promise.reject(this.error);\n                    continue;\n                }\n\n                try {\n                    result = onError(this.error);\n                } catch (err) {\n                    promise.reject(err);\n                    continue;\n                }\n            }\n\n            if (result instanceof ZalgoPromise && (result.resolved || result.rejected)) {\n                const promiseResult : ZalgoPromise<*> = result;\n\n                if (promiseResult.resolved) {\n                    promise.resolve(promiseResult.value);\n                } else {\n                    promise.reject(promiseResult.error);\n                }\n\n                promiseResult.errorHandled = true;\n\n            } else if (isPromise(result)) {\n\n                if (result instanceof ZalgoPromise && (result.resolved || result.rejected)) {\n                    if (result.resolved) {\n                        promise.resolve(result.value);\n                    } else {\n                        promise.reject(result.error);\n                    }\n\n                } else {\n                    // $FlowFixMe\n                    chain(result, promise);\n                }\n\n            } else {\n\n                promise.resolve(result);\n            }\n        }\n\n        handlers.length = 0;\n        this.dispatching = false;\n        endActive();\n    }\n\n    then<X, Y>(onSuccess : void | (result : R) => (ZalgoPromise<X> | Y), onError : void | (error : mixed) => (ZalgoPromise<X> | Y)) : ZalgoPromise<X | Y> {\n\n        if (onSuccess && typeof onSuccess !== 'function' && !onSuccess.call) {\n            throw new Error('Promise.then expected a function for success handler');\n        }\n\n        if (onError && typeof onError !== 'function' && !onError.call) {\n            throw new Error('Promise.then expected a function for error handler');\n        }\n\n        const promise = new ZalgoPromise();\n\n        this.handlers.push({\n            promise,\n            onSuccess,\n            onError\n        });\n\n        this.errorHandled = true;\n\n        this.dispatch();\n\n        return promise;\n    }\n\n    catch<X, Y>(onError : (error : mixed) => ZalgoPromise<X> | Y) : ZalgoPromise<X | Y> {\n        // $FlowFixMe incompatible-call\n        const resultPromise : ZalgoPromise<X | Y> = this.then(undefined, onError);\n        return resultPromise;\n    }\n\n    finally(onFinally : () => mixed) : ZalgoPromise<R> {\n\n        if (onFinally && typeof onFinally !== 'function' && !onFinally.call) {\n            throw new Error('Promise.finally expected a function');\n        }\n\n        return this.then((result) => {\n            return ZalgoPromise.try(onFinally)\n                .then(() => {\n                    return result;\n                });\n        }, (err) => {\n            return ZalgoPromise.try(onFinally)\n                .then(() => {\n                    throw err;\n                });\n        });\n    }\n\n    timeout(time : number, err : ?Error) : ZalgoPromise<R> {\n\n        if (this.resolved || this.rejected) {\n            return this;\n        }\n\n        const timeout = setTimeout(() => {\n\n            if (this.resolved || this.rejected) {\n                return;\n            }\n\n            this.reject(err || new Error(`Promise timed out after ${ time }ms`));\n\n        }, time);\n\n        return this.then(result => {\n            clearTimeout(timeout);\n            return result;\n        });\n    }\n\n    // $FlowFixMe\n    toPromise() : Promise<R> {\n        // $FlowFixMe\n        if (typeof Promise === 'undefined') {\n            throw new TypeError(`Could not find Promise`);\n        }\n        // $FlowFixMe\n        return Promise.resolve(this); // eslint-disable-line compat/compat\n    }\n\n    lazy() : ZalgoPromise<R> {\n        this.errorHandled = true;\n        return this;\n    }\n\n    static resolve<X, Y>(value : ZalgoPromise<X> | Y) : ZalgoPromise<X | Y> {\n\n        if (value instanceof ZalgoPromise) {\n            // $FlowFixMe incompatible-type-arg\n            const result : ZalgoPromise<X | Y> = value;\n            return result;\n        }\n\n        if (isPromise(value)) {\n            // $FlowFixMe\n            return new ZalgoPromise((resolve, reject) => value.then(resolve, reject));\n        }\n\n        return new ZalgoPromise().resolve(value);\n    }\n\n    static reject(error : mixed) : ZalgoPromise<R> {\n        return new ZalgoPromise().reject(error);\n    }\n\n    static asyncReject(error : mixed) : ZalgoPromise<R> {\n        return new ZalgoPromise().asyncReject(error);\n    }\n\n    static all<X : $ReadOnlyArray<mixed>>(promises : X) : ZalgoPromise<$TupleMap<X, <Y>(ZalgoPromise<Y> | Y) => Y>> { // eslint-disable-line no-undef\n\n        const promise = new ZalgoPromise();\n        let count = promises.length;\n        // eslint-disable-next-line no-undef, unicorn/prefer-spread\n        const results = ([] : $TupleMap<X, <Y>(ZalgoPromise<Y> | Y) => Y>).slice();\n\n        if (!count) {\n            promise.resolve(results);\n            return promise;\n        }\n\n        const chain = <T>(i : number, firstPromise : ZalgoPromise<T>, secondPromise : ZalgoPromise<T>) => {\n            return firstPromise.then(res => {\n                results[i] = res;\n                count -= 1;\n                if (count === 0) {\n                    promise.resolve(results);\n                }\n            }, err => {\n                secondPromise.reject(err);\n            });\n        };\n\n        for (let i = 0; i < promises.length; i++) {\n            const prom = promises[i];\n\n            if (prom instanceof ZalgoPromise) {\n                if (prom.resolved) {\n                    results[i] = prom.value;\n                    count -= 1;\n                    continue;\n                }\n            } else if (!isPromise(prom)) {\n                results[i] = prom;\n                count -= 1;\n                continue;\n            }\n\n            chain(i, ZalgoPromise.resolve(prom), promise);\n        }\n\n        if (count === 0) {\n            promise.resolve(results);\n        }\n\n        return promise;\n    }\n\n    static hash<O : Object>(promises : O) : ZalgoPromise<$ObjMap<O, <Y>(ZalgoPromise<Y> | Y) => Y>> { // eslint-disable-line no-undef\n        const result = {};\n        const awaitPromises = [];\n\n        for (const key in promises) {\n            if (promises.hasOwnProperty(key)) {\n                const value = promises[key];\n\n                if (isPromise(value)) {\n                    awaitPromises.push(value.then(res => {\n                        result[key] = res;\n                    }));\n                } else {\n                    result[key] = value;\n                }\n            }\n        }\n\n        return ZalgoPromise.all(awaitPromises).then(() => result);\n    }\n\n    static map<T, X>(items : $ReadOnlyArray<T>, method : (T) => (ZalgoPromise<X> | X)) : ZalgoPromise<$ReadOnlyArray<X>> {\n        // $FlowFixMe\n        return ZalgoPromise.all(items.map(method));\n    }\n\n    static onPossiblyUnhandledException(handler : (err : mixed) => void) : {| cancel : () => void |} {\n        return onPossiblyUnhandledException(handler);\n    }\n\n    static try<X, Y, C : mixed, A : $ReadOnlyArray<mixed>>(method : (...args : $ReadOnlyArray<mixed>) => (ZalgoPromise<X> | Y), context? : C, args? : A) : ZalgoPromise<X | Y> {\n\n        if (method && typeof method !== 'function' && !method.call) {\n            throw new Error('Promise.try expected a function');\n        }\n\n        let result : ZalgoPromise<X> | Y;\n\n        startActive();\n\n        try {\n            result = method.apply(context, args || []);\n        } catch (err) {\n            endActive();\n            return ZalgoPromise.reject(err);\n        }\n\n        endActive();\n\n        // $FlowFixMe incompatible-call\n        const resultPromise = ZalgoPromise.resolve(result);\n\n        return resultPromise;\n    }\n\n    static delay(delay : number) : ZalgoPromise<void> {\n        return new ZalgoPromise(resolve => {\n            setTimeout(resolve, delay);\n        });\n    }\n\n    static isPromise(value : mixed) : boolean {\n\n        if (value && value instanceof ZalgoPromise) {\n            return true;\n        }\n\n        return isPromise(value);\n    }\n\n    static flush() : ZalgoPromise<void> {\n        return awaitActive(ZalgoPromise);\n    }\n}\n","export default function _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}","import setPrototypeOf from \"@babel/runtime/helpers/esm/setPrototypeOf\";\nexport default function _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  setPrototypeOf(subClass, superClass);\n}","/* @flow */\n\nexport function safeIndexOf<T>(collection : $ReadOnlyArray<T>, item : T) : number {\n    for (let i = 0; i < collection.length; i++) {\n\n        try {\n            if (collection[i] === item) {\n                return i;\n            }\n        } catch (err) {\n            // pass\n        }\n    }\n\n    return -1;\n}\n\n// eslint-disable-next-line no-unused-vars\nexport function noop(...args : $ReadOnlyArray<mixed>) {\n    // pass\n}\n","/* @flow */\n\nimport { isWindow, isWindowClosed } from '@krakenjs/cross-domain-utils/src';\n\nimport { hasNativeWeakMap } from './native';\nimport { noop, safeIndexOf } from './util';\n\nexport class CrossDomainSafeWeakMap<K : Object, V : mixed> {\n\n    name : string;\n    weakmap : ?WeakMap<K, V>;\n    // eslint-disable-next-line flowtype/no-mutable-array\n    keys : Array<K>;\n    // eslint-disable-next-line flowtype/no-mutable-array\n    values : Array<V>;\n\n    constructor() {\n        // eslint-disable-next-line no-bitwise\n        this.name = `__weakmap_${ Math.random() * 1e9 >>> 0 }__`;\n\n        if (hasNativeWeakMap()) {\n            try {\n                this.weakmap = new WeakMap();\n            } catch (err) {\n                // pass\n            }\n        }\n\n        this.keys  = [];\n        this.values = [];\n    }\n\n    _cleanupClosedWindows() {\n\n        const weakmap = this.weakmap;\n        const keys = this.keys;\n\n        for (let i = 0; i < keys.length; i++) {\n            const value = keys[i];\n\n            if (isWindow(value) && isWindowClosed(value)) {\n\n                if (weakmap) {\n                    try {\n                        weakmap.delete(value);\n                    } catch (err) {\n                        // pass\n                    }\n                }\n\n                keys.splice(i, 1);\n                this.values.splice(i, 1);\n\n                i -= 1;\n            }\n        }\n    }\n\n    isSafeToReadWrite(key : K) : boolean {\n\n        if (isWindow(key)) {\n            return false;\n        }\n\n        try {\n            noop(key && key.self);\n            noop(key && key[this.name]);\n        } catch (err) {\n            return false;\n        }\n\n        return true;\n    }\n\n    set(key : K, value : V) {\n\n        if (!key) {\n            throw new Error(`WeakMap expected key`);\n        }\n\n        const weakmap = this.weakmap;\n\n        if (weakmap) {\n            try {\n                weakmap.set(key, value);\n            } catch (err) {\n                delete this.weakmap;\n            }\n        }\n\n        if (this.isSafeToReadWrite(key)) {\n            try {\n                const name = this.name;\n                const entry = key[name];\n\n                if (entry && entry[0] === key) {\n                    entry[1] = value;\n                } else {\n                    Object.defineProperty(key, name, {\n                        value:    [ key, value ],\n                        writable: true\n                    });\n                }\n\n                return;\n\n            } catch (err) {\n                // pass\n            }\n        }\n\n        this._cleanupClosedWindows();\n\n        const keys = this.keys;\n        const values = this.values;\n        const index = safeIndexOf(keys, key);\n\n        if (index === -1) {\n            keys.push(key);\n            values.push(value);\n        } else {\n            values[index] = value;\n        }\n    }\n\n    get(key : K) : V | void {\n\n        if (!key) {\n            throw new Error(`WeakMap expected key`);\n        }\n\n        const weakmap = this.weakmap;\n\n        if (weakmap) {\n            try {\n                if (weakmap.has(key)) {\n                    return weakmap.get(key);\n                }\n\n            } catch (err) {\n                delete this.weakmap;\n            }\n        }\n\n        if (this.isSafeToReadWrite(key)) {\n            try {\n                const entry = key[this.name];\n\n                if (entry && entry[0] === key) {\n                    return entry[1];\n                }\n\n                return;\n            } catch (err) {\n                // pass\n            }\n        }\n\n        this._cleanupClosedWindows();\n\n        const keys = this.keys;\n        const index = safeIndexOf(keys, key);\n\n        if (index === -1) {\n            return;\n        }\n\n        return this.values[index];\n    }\n\n    delete(key : K) {\n\n        if (!key) {\n            throw new Error(`WeakMap expected key`);\n        }\n\n        const weakmap = this.weakmap;\n\n        if (weakmap) {\n            try {\n                weakmap.delete(key);\n            } catch (err) {\n                delete this.weakmap;\n            }\n        }\n\n        if (this.isSafeToReadWrite(key)) {\n            try {\n                const entry = key[this.name];\n\n                if (entry && entry[0] === key) {\n                    entry[0] = entry[1] = undefined;\n                }\n            } catch (err) {\n                // pass\n            }\n        }\n\n        this._cleanupClosedWindows();\n\n        const keys = this.keys;\n        const index = safeIndexOf(keys, key);\n\n        if (index !== -1) {\n            keys.splice(index, 1);\n            this.values.splice(index, 1);\n        }\n    }\n\n    has(key : K) : boolean {\n\n        if (!key) {\n            throw new Error(`WeakMap expected key`);\n        }\n\n        const weakmap = this.weakmap;\n\n        if (weakmap) {\n            try {\n                if (weakmap.has(key)) {\n                    return true;\n                }\n            } catch (err) {\n                delete this.weakmap;\n            }\n        }\n\n        if (this.isSafeToReadWrite(key)) {\n            try {\n                const entry = key[this.name];\n\n                if (entry && entry[0] === key) {\n                    return true;\n                }\n\n                return false;\n            } catch (err) {\n                // pass\n            }\n        }\n\n        this._cleanupClosedWindows();\n\n        const index = safeIndexOf(this.keys, key);\n        return index !== -1;\n    }\n\n    getOrSet(key : K, getter : () => V) : V {\n        if (this.has(key)) {\n            // $FlowFixMe\n            return this.get(key);\n        }\n\n        const value = getter();\n        this.set(key, value);\n        return value;\n    }\n}\n","/* @flow */\n/* eslint max-lines: 0 */\nimport { ZalgoPromise } from \"@krakenjs/zalgo-promise/src\";\nimport { WeakMap } from \"@krakenjs/cross-domain-safe-weakmap/src\";\n\nimport {\n  BLANK_URL,\n  ctrlCharactersRegex,\n  htmlCtrlEntityRegex,\n  htmlEntitiesRegex,\n  invalidProtocolRegex,\n  relativeFirstCharacters,\n  urlSchemeRegex,\n} from \"./constants\";\nimport type { CancelableType } from \"./types\";\n\nexport function isElement(element: mixed): boolean {\n  let passed = false;\n\n  try {\n    if (element instanceof window.Element) {\n      passed = true;\n    } else if (\n      element !== null &&\n      typeof element === \"object\" &&\n      element.nodeType === 1 &&\n      typeof element.style === \"object\" &&\n      typeof element.ownerDocument === \"object\"\n    ) {\n      passed = true;\n    }\n  } catch (_) {\n    // we don't have an element\n  }\n\n  return passed;\n}\n\nexport function getFunctionName<T: Function>(fn: T): string {\n  return fn.name || fn.__name__ || fn.displayName || \"anonymous\";\n}\n\nexport function setFunctionName<T: Function>(fn: T, name: string): T {\n  try {\n    delete fn.name;\n    fn.name = name;\n  } catch (err) {\n    // pass\n  }\n\n  fn.__name__ = fn.displayName = name;\n  return fn;\n}\n\nexport function base64encode(str: string): string {\n  if (typeof btoa === \"function\") {\n    return btoa(\n      encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, (m, p1) => {\n        return String.fromCharCode(parseInt(p1, 16));\n      })\n    ).replace(/[=]/g, \"\");\n  }\n\n  if (typeof Buffer !== \"undefined\") {\n    return Buffer.from(str, \"utf8\").toString(\"base64\").replace(/[=]/g, \"\");\n  }\n\n  throw new Error(`Can not find window.btoa or Buffer`);\n}\n\nexport function base64decode(str: string): string {\n  if (typeof atob === \"function\") {\n    return decodeURIComponent(\n      // $FlowFixMe[method-unbinding]\n      Array.prototype.map\n        .call(atob(str), (c) => {\n          // eslint-disable-next-line prefer-template\n          return \"%\" + (\"00\" + c.charCodeAt(0).toString(16)).slice(-2);\n        })\n        .join(\"\")\n    );\n  }\n\n  if (typeof Buffer !== \"undefined\") {\n    return Buffer.from(str, \"base64\").toString(\"utf8\");\n  }\n\n  throw new Error(`Can not find window.atob or Buffer`);\n}\n\nexport function uniqueID(): string {\n  const chars = \"0123456789abcdef\";\n\n  const randomID = \"xxxxxxxxxx\".replace(/./g, () => {\n    return chars.charAt(Math.floor(Math.random() * chars.length));\n  });\n\n  const timeID = base64encode(\n    new Date().toISOString().slice(11, 19).replace(\"T\", \".\")\n  )\n    .replace(/[^a-zA-Z0-9]/g, \"\")\n    .toLowerCase();\n\n  return `uid_${randomID}_${timeID}`;\n}\n\nexport function getGlobal(): Object {\n  if (typeof window !== \"undefined\") {\n    return window;\n  }\n  if (typeof global !== \"undefined\") {\n    return global;\n  }\n  if (typeof __GLOBAL__ !== \"undefined\") {\n    return __GLOBAL__;\n  }\n  throw new Error(`No global found`);\n}\n\nlet objectIDs;\n\nexport function getObjectID(obj: Object): string {\n  objectIDs = objectIDs || new WeakMap();\n\n  if (\n    obj === null ||\n    obj === undefined ||\n    (typeof obj !== \"object\" && typeof obj !== \"function\")\n  ) {\n    throw new Error(`Invalid object`);\n  }\n\n  let uid = objectIDs.get(obj);\n\n  if (!uid) {\n    uid = `${typeof obj}:${uniqueID()}`;\n    objectIDs.set(obj, uid);\n  }\n\n  return uid;\n}\n\nfunction serializeArgs<T>(args: $ReadOnlyArray<T>): string {\n  try {\n    // $FlowFixMe[method-unbinding]\n    return JSON.stringify(Array.prototype.slice.call(args), (subkey, val) => {\n      // Treat each distinct function as unique for purposes of memoization\n      // e.g. even if someFunction.stringify() is the same, we may use a different memoize cache\n      // if the actual function is different.\n      if (typeof val === \"function\") {\n        return `memoize[${getObjectID(val)}]`;\n      }\n\n      // By default JSON.stringify(domElement) returns '{}'. This ensures that stays true even for non-standard\n      // elements (e.g. React-rendered dom elements) with custom properties\n      if (isElement(val)) {\n        return {};\n      }\n\n      return val;\n    });\n  } catch (err) {\n    throw new Error(`Arguments not serializable -- can not be used to memoize`);\n  }\n}\n\nexport function getEmptyObject(): {||} {\n  // $FlowFixMe\n  return {};\n}\n\ntype MemoizeOptions = {|\n  name?: string,\n  time?: number,\n  thisNamespace?: boolean,\n|};\n\nconst getDefaultMemoizeOptions = (): MemoizeOptions => {\n  // $FlowFixMe\n  return {};\n};\n\nexport type Memoized<F> = F & {| reset: () => void |};\n\nlet memoizeGlobalIndex = 0;\nlet memoizeGlobalIndexValidFrom = 0;\n\nexport function memoize<F: Function>(\n  method: F,\n  options?: MemoizeOptions = getDefaultMemoizeOptions()\n): Memoized<F> {\n  const { thisNamespace = false, time: cacheTime } = options;\n\n  let simpleCache;\n  let thisCache;\n\n  let memoizeIndex = memoizeGlobalIndex;\n  memoizeGlobalIndex += 1;\n\n  const memoizedFunction = function memoizedFunction(...args): mixed {\n    if (memoizeIndex < memoizeGlobalIndexValidFrom) {\n      simpleCache = null;\n      thisCache = null;\n      memoizeIndex = memoizeGlobalIndex;\n      memoizeGlobalIndex += 1;\n    }\n\n    let cache;\n\n    if (thisNamespace) {\n      thisCache = thisCache || new WeakMap();\n      cache = thisCache.getOrSet(this, getEmptyObject);\n    } else {\n      cache = simpleCache = simpleCache || {};\n    }\n\n    let cacheKey;\n\n    try {\n      cacheKey = serializeArgs(args);\n    } catch {\n      return method.apply(this, arguments);\n    }\n\n    let cacheResult = cache[cacheKey];\n\n    if (cacheResult && cacheTime && Date.now() - cacheResult.time < cacheTime) {\n      delete cache[cacheKey];\n      cacheResult = null;\n    }\n\n    if (cacheResult) {\n      return cacheResult.value;\n    }\n\n    const time = Date.now();\n    const value = method.apply(this, arguments);\n\n    cache[cacheKey] = { time, value };\n\n    return value;\n  };\n\n  memoizedFunction.reset = () => {\n    simpleCache = null;\n    thisCache = null;\n  };\n\n  // $FlowFixMe\n  const result: F = memoizedFunction;\n\n  return setFunctionName(\n    result,\n    `${options.name || getFunctionName(method)}::memoized`\n  );\n}\n\nmemoize.clear = () => {\n  memoizeGlobalIndexValidFrom = memoizeGlobalIndex;\n};\n\nexport function promiseIdentity<T: mixed>(\n  item: ZalgoPromise<T> | T\n): ZalgoPromise<T> {\n  // $FlowFixMe\n  return ZalgoPromise.resolve(item);\n}\n\nexport function memoizePromise<R>(\n  // eslint-disable-next-line flowtype/no-weak-types\n  method: (...args: $ReadOnlyArray<any>) => ZalgoPromise<R>\n  // eslint-disable-next-line flowtype/no-weak-types\n): (...args: $ReadOnlyArray<any>) => ZalgoPromise<R> {\n  let cache = {};\n\n  function memoizedPromiseFunction(\n    // eslint-disable-next-line flowtype/no-weak-types\n    ...args: $ReadOnlyArray<any>\n  ): ZalgoPromise<R> {\n    const key: string = serializeArgs(args);\n\n    if (cache.hasOwnProperty(key)) {\n      return cache[key];\n    }\n\n    cache[key] = ZalgoPromise.try(() => method.apply(this, arguments)).finally(\n      () => {\n        delete cache[key];\n      }\n    );\n\n    return cache[key];\n  }\n\n  memoizedPromiseFunction.reset = () => {\n    cache = {};\n  };\n\n  return setFunctionName(\n    memoizedPromiseFunction,\n    `${getFunctionName(method)}::promiseMemoized`\n  );\n}\n\ntype PromisifyOptions = {|\n  name?: string,\n|};\n\nconst getDefaultPromisifyOptions = (): PromisifyOptions => {\n  // $FlowFixMe\n  return {};\n};\n\nexport function promisify<R>(\n  // eslint-disable-next-line flowtype/no-weak-types\n  method: (...args: $ReadOnlyArray<any>) => R,\n  options: PromisifyOptions = getDefaultPromisifyOptions()\n  // eslint-disable-next-line flowtype/no-weak-types\n): (...args: $ReadOnlyArray<any>) => ZalgoPromise<R> {\n  function promisifiedFunction(): ZalgoPromise<R> {\n    return ZalgoPromise.try(method, this, arguments);\n  }\n\n  if (options.name) {\n    promisifiedFunction.displayName = `${options.name}:promisified`;\n  }\n\n  return setFunctionName(\n    promisifiedFunction,\n    `${getFunctionName(method)}::promisified`\n  );\n}\n\nexport function inlineMemoize<R>(\n  // eslint-disable-next-line flowtype/no-weak-types\n  method: (...args: $ReadOnlyArray<any>) => R,\n  // eslint-disable-next-line flowtype/no-weak-types\n  logic: (...args: $ReadOnlyArray<any>) => R,\n  // eslint-disable-next-line flowtype/no-weak-types\n  args: $ReadOnlyArray<any> = []\n): R {\n  // $FlowFixMe\n  const cache: {| [string]: R |} = (method.__inline_memoize_cache__ =\n    // $FlowFixMe\n    method.__inline_memoize_cache__ || {});\n  const key = serializeArgs(args);\n\n  if (cache.hasOwnProperty(key)) {\n    return cache[key];\n  }\n\n  const result = (cache[key] = logic(...args));\n\n  return result;\n}\n\n// eslint-disable-next-line no-unused-vars\nexport function noop(...args: $ReadOnlyArray<mixed>) {\n  // pass\n}\n\nexport function once(method: Function): Function {\n  let called = false;\n\n  const onceFunction = function (): mixed {\n    if (!called) {\n      called = true;\n      return method.apply(this, arguments);\n    }\n  };\n\n  return setFunctionName(onceFunction, `${getFunctionName(method)}::once`);\n}\n\nexport function hashStr(str: string): number {\n  let hash = 0;\n  for (let i = 0; i < str.length; i++) {\n    hash += str[i].charCodeAt(0) * Math.pow((i % 10) + 1, 5);\n  }\n  return Math.floor(Math.pow(Math.sqrt(hash), 5));\n}\n\nexport function strHashStr(str: string): string {\n  let hash = \"\";\n\n  for (let i = 0; i < str.length; i++) {\n    let total = str[i].charCodeAt(0) * i;\n\n    if (str[i + 1]) {\n      total += str[i + 1].charCodeAt(0) * (i - 1);\n    }\n\n    hash += String.fromCharCode(97 + (Math.abs(total) % 26));\n  }\n\n  return hash;\n}\n\nexport function match(str: string, pattern: RegExp): ?string {\n  const regmatch = str.match(pattern);\n  if (regmatch) {\n    return regmatch[1];\n  }\n}\n\nexport function awaitKey<T: mixed>(obj: Object, key: string): ZalgoPromise<T> {\n  return new ZalgoPromise((resolve) => {\n    let value = obj[key];\n\n    if (value) {\n      return resolve(value);\n    }\n\n    delete obj[key];\n\n    Object.defineProperty(obj, key, {\n      configurable: true,\n\n      set(item) {\n        value = item;\n\n        if (value) {\n          resolve(value);\n        }\n      },\n\n      get(): T {\n        return value;\n      },\n    });\n  });\n}\n\nexport function stringifyError(err: mixed, level: number = 1): string {\n  if (level >= 3) {\n    return \"stringifyError stack overflow\";\n  }\n\n  try {\n    if (!err) {\n      // $FlowFixMe[method-unbinding]\n      return `<unknown error: ${Object.prototype.toString.call(err)}>`;\n    }\n\n    if (typeof err === \"string\") {\n      return err;\n    }\n\n    if (err instanceof Error) {\n      const stack = err && err.stack;\n      const message = err && err.message;\n\n      if (stack && message) {\n        if (stack.indexOf(message) !== -1) {\n          return stack;\n        } else {\n          return `${message}\\n${stack}`;\n        }\n      } else if (stack) {\n        return stack;\n      } else if (message) {\n        return message;\n      }\n    }\n\n    if (err && err.toString && typeof err.toString === \"function\") {\n      // $FlowFixMe\n      return err.toString();\n    }\n\n    // $FlowFixMe[method-unbinding]\n    return Object.prototype.toString.call(err);\n  } catch (newErr) {\n    return `Error while stringifying error: ${stringifyError(\n      newErr,\n      level + 1\n    )}`;\n  }\n}\n\nexport function stringifyErrorMessage(err: mixed): string {\n  // $FlowFixMe[method-unbinding]\n  const defaultMessage = `<unknown error: ${Object.prototype.toString.call(\n    err\n  )}>`;\n\n  if (!err) {\n    return defaultMessage;\n  }\n\n  if (err instanceof Error) {\n    return err.message || defaultMessage;\n  }\n\n  if (typeof err.message === \"string\") {\n    return err.message || defaultMessage;\n  }\n\n  return defaultMessage;\n}\n\nexport function stringify(item: mixed): string {\n  if (typeof item === \"string\") {\n    return item;\n  }\n\n  if (item && item.toString && typeof item.toString === \"function\") {\n    // $FlowFixMe\n    return item.toString();\n  }\n\n  // $FlowFixMe[method-unbinding]\n  return Object.prototype.toString.call(item);\n}\n\nexport function domainMatches(hostname: string, domain: string): boolean {\n  hostname = hostname.split(\"://\")[1];\n  const index = hostname.indexOf(domain);\n  return index !== -1 && hostname.slice(index) === domain;\n}\n\nexport function patchMethod(obj: Object, name: string, handler: Function) {\n  const original = obj[name];\n\n  obj[name] = function patchedMethod(): mixed {\n    return handler({\n      context: this,\n      // $FlowFixMe[method-unbinding]\n      args: Array.prototype.slice.call(arguments),\n      original,\n      callOriginal: () => original.apply(this, arguments),\n    });\n  };\n}\n\nexport function extend<T: Object | Function>(obj: T, source: Object): T {\n  if (!source) {\n    return obj;\n  }\n\n  if (Object.assign) {\n    return Object.assign(obj, source);\n  }\n\n  for (const key in source) {\n    if (source.hasOwnProperty(key)) {\n      obj[key] = source[key];\n    }\n  }\n\n  return obj;\n}\n\nexport function values<T>(obj: { [string]: T }): $ReadOnlyArray<T> {\n  if (Object.values) {\n    // $FlowFixMe\n    return Object.values(obj);\n  }\n\n  const result: Array<T> = [];\n  for (const key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      // $FlowFixMe[escaped-generic]\n      result.push(obj[key]);\n    }\n  }\n\n  // $FlowFixMe\n  return result;\n}\n\n// eslint-disable-next-line no-undef\nexport const memoizedValues: <T>({ [string]: T }) => $ReadOnlyArray<T> =\n  memoize(values);\n\nexport function perc(pixels: number, percentage: number): number {\n  return Math.round((pixels * percentage) / 100);\n}\n\nexport function min(...args: $ReadOnlyArray<number>): number {\n  return Math.min(...args);\n}\n\nexport function max(...args: $ReadOnlyArray<number>): number {\n  return Math.max(...args);\n}\n\nexport function roundUp(num: number, nearest: number): number {\n  const remainder = num % nearest;\n  return remainder ? num - remainder + nearest : num;\n}\n\nexport function regexMap<T>(\n  str: string,\n  regexp: RegExp,\n  handler: () => T\n): $ReadOnlyArray<T> {\n  const results = [];\n\n  // $FlowFixMe\n  str.replace(regexp, function regexMapMatcher(item) {\n    results.push(handler ? handler.apply(null, arguments) : item);\n  });\n\n  // $FlowFixMe\n  return results;\n}\n\nexport function svgToBase64(svg: string): string {\n  return `data:image/svg+xml;base64,${base64encode(svg)}`;\n}\n\nexport function objFilter<T, R>(\n  obj: { [string]: T },\n  filter?: (T, ?string) => mixed = Boolean\n): { [string]: R } {\n  const result = {};\n\n  for (const key in obj) {\n    if (!obj.hasOwnProperty(key) || !filter(obj[key], key)) {\n      continue;\n    }\n\n    result[key] = obj[key];\n  }\n\n  return result;\n}\n\nexport function identity<T>(item: T): T {\n  return item;\n}\n\nexport function regexTokenize(\n  text: string,\n  regexp: RegExp\n): $ReadOnlyArray<string> {\n  const result = [];\n  text.replace(regexp, (token) => {\n    result.push(token);\n    return \"\";\n  });\n  return result;\n}\n\nexport function promiseDebounce<T>(\n  method: () => ZalgoPromise<T> | T,\n  delay: number = 50\n): () => ZalgoPromise<T> {\n  let promise;\n  let timeout;\n\n  const promiseDebounced = function (): ZalgoPromise<T> {\n    if (timeout) {\n      clearTimeout(timeout);\n    }\n\n    const localPromise = (promise = promise || new ZalgoPromise());\n\n    timeout = setTimeout(() => {\n      promise = null;\n      timeout = null;\n\n      ZalgoPromise.try(method).then(\n        (result) => {\n          localPromise.resolve(result);\n        },\n        (err) => {\n          localPromise.reject(err);\n        }\n      );\n    }, delay);\n\n    return localPromise;\n  };\n\n  return setFunctionName(\n    promiseDebounced,\n    `${getFunctionName(method)}::promiseDebounced`\n  );\n}\n\nexport function safeInterval(\n  method: Function,\n  time: number\n): {| cancel: () => void |} {\n  let timeout;\n\n  function loop() {\n    timeout = setTimeout(() => {\n      method();\n      loop();\n    }, time);\n  }\n\n  loop();\n\n  return {\n    cancel() {\n      clearTimeout(timeout);\n    },\n  };\n}\n\nexport function isInteger(str: string): boolean {\n  return Boolean(str.match(/^[0-9]+$/));\n}\n\nexport function isFloat(str: string): boolean {\n  return Boolean(str.match(/^[0-9]+\\.[0-9]+$/));\n}\n\nexport function serializePrimitive(value: string | number | boolean): string {\n  return value.toString();\n}\n\nexport function deserializePrimitive(value: string): string | number | boolean {\n  if (value === \"true\") {\n    return true;\n  } else if (value === \"false\") {\n    return false;\n  } else if (isInteger(value)) {\n    return parseInt(value, 10);\n  } else if (isFloat(value)) {\n    return parseFloat(value);\n  } else {\n    return value;\n  }\n}\n\nexport function dotify(\n  obj: Object,\n  prefix: string = \"\",\n  newobj: Object = {}\n): { [string]: string } {\n  prefix = prefix ? `${prefix}.` : prefix;\n  for (const key in obj) {\n    if (\n      !obj.hasOwnProperty(key) ||\n      obj[key] === undefined ||\n      obj[key] === null ||\n      typeof obj[key] === \"function\"\n    ) {\n      continue;\n    } else if (\n      obj[key] &&\n      Array.isArray(obj[key]) &&\n      obj[key].length &&\n      obj[key].every((val) => typeof val !== \"object\")\n    ) {\n      newobj[`${prefix}${key}[]`] = obj[key].join(\",\");\n    } else if (obj[key] && typeof obj[key] === \"object\") {\n      newobj = dotify(obj[key], `${prefix}${key}`, newobj);\n    } else {\n      newobj[`${prefix}${key}`] = serializePrimitive(obj[key]);\n    }\n  }\n  return newobj;\n}\n\nexport function undotify(obj: { [string]: string }): Object {\n  const result = {};\n\n  for (let key in obj) {\n    if (!obj.hasOwnProperty(key) || typeof obj[key] !== \"string\") {\n      continue;\n    }\n\n    let value = obj[key];\n\n    if (key.match(/^.+\\[\\]$/)) {\n      key = key.slice(0, -2);\n      value = value.split(\",\").map(deserializePrimitive);\n    } else {\n      value = deserializePrimitive(value);\n    }\n\n    let keyResult = result;\n    const parts = key.split(\".\");\n    for (let i = 0; i < parts.length; i++) {\n      const part = parts[i];\n      const isLast = i + 1 === parts.length;\n      const isIndex = !isLast && isInteger(parts[i + 1]);\n\n      if (\n        part === \"constructor\" ||\n        part === \"prototype\" ||\n        part === \"__proto__\"\n      ) {\n        throw new Error(`Disallowed key: ${part}`);\n      }\n\n      if (isLast) {\n        // $FlowFixMe\n        keyResult[part] = value;\n      } else {\n        // $FlowFixMe\n        keyResult = keyResult[part] = keyResult[part] || (isIndex ? [] : {});\n      }\n    }\n  }\n\n  return result;\n}\n\nexport type EventEmitterType = {|\n  on: (eventName: string, handler: Function) => CancelableType,\n  once: (eventName: string, handler: Function) => CancelableType,\n  trigger: (\n    eventName: string,\n    ...args: $ReadOnlyArray<mixed>\n  ) => ZalgoPromise<void>,\n  triggerOnce: (\n    eventName: string,\n    ...args: $ReadOnlyArray<mixed>\n  ) => ZalgoPromise<void>,\n  reset: () => void,\n|};\n\nexport function eventEmitter(): EventEmitterType {\n  const triggered = {};\n  let handlers = {};\n\n  const emitter = {\n    on(eventName: string, handler: Function): CancelableType {\n      const handlerList = (handlers[eventName] = handlers[eventName] || []);\n\n      handlerList.push(handler);\n\n      let cancelled = false;\n\n      return {\n        cancel() {\n          if (!cancelled) {\n            cancelled = true;\n            handlerList.splice(handlerList.indexOf(handler), 1);\n          }\n        },\n      };\n    },\n\n    once(eventName: string, handler: Function): CancelableType {\n      const listener = emitter.on(eventName, () => {\n        listener.cancel();\n        handler();\n      });\n\n      return listener;\n    },\n\n    trigger(\n      eventName: string,\n      ...args: $ReadOnlyArray<mixed>\n    ): ZalgoPromise<void> {\n      const handlerList = handlers[eventName];\n      const promises = [];\n\n      if (handlerList) {\n        for (const handler of handlerList) {\n          promises.push(ZalgoPromise.try(() => handler(...args)));\n        }\n      }\n\n      return ZalgoPromise.all(promises).then(noop);\n    },\n\n    triggerOnce(\n      eventName: string,\n      ...args: $ReadOnlyArray<mixed>\n    ): ZalgoPromise<void> {\n      if (triggered[eventName]) {\n        return ZalgoPromise.resolve();\n      }\n\n      triggered[eventName] = true;\n      return emitter.trigger(eventName, ...args);\n    },\n\n    reset() {\n      handlers = {};\n    },\n  };\n\n  return emitter;\n}\n\nexport function camelToDasherize(string: string): string {\n  return string.replace(/([A-Z])/g, (g) => {\n    return `-${g.toLowerCase()}`;\n  });\n}\n\nexport function dasherizeToCamel(string: string): string {\n  return string.replace(/-([a-z])/g, (g) => {\n    return g[1].toUpperCase();\n  });\n}\n\nexport function capitalizeFirstLetter(string: string): string {\n  return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();\n}\n\nexport function get(item: Object, path: string, def: mixed): mixed {\n  if (!path) {\n    return def;\n  }\n\n  const pathParts = path.split(\".\");\n\n  // Loop through each section of our key path\n\n  for (let i = 0; i < pathParts.length; i++) {\n    // If we have an object, we can get the key\n    if (typeof item === \"object\" && item !== null) {\n      item = item[pathParts[i]];\n\n      // Otherwise, we should return the default (undefined if not provided)\n    } else {\n      return def;\n    }\n  }\n\n  // If our final result is undefined, we should return the default\n\n  return item === undefined ? def : item;\n}\n\nexport function safeTimeout(method: Function, time: number) {\n  const interval = safeInterval(() => {\n    time -= 100;\n    if (time <= 0) {\n      interval.cancel();\n      method();\n    }\n  }, 100);\n}\n\nexport function defineLazyProp<T>(\n  obj: Object | $ReadOnlyArray<mixed>,\n  key: string | number,\n  getter: () => T\n) {\n  if (Array.isArray(obj)) {\n    if (typeof key !== \"number\") {\n      throw new TypeError(`Array key must be number`);\n    }\n  } else if (typeof obj === \"object\" && obj !== null) {\n    if (typeof key !== \"string\") {\n      throw new TypeError(`Object key must be string`);\n    }\n  }\n\n  Object.defineProperty(obj, key, {\n    configurable: true,\n    enumerable: true,\n    get: () => {\n      // $FlowFixMe\n      delete obj[key];\n      const value = getter();\n      // $FlowFixMe\n      obj[key] = value;\n      return value;\n    },\n    set: (value: T) => {\n      // $FlowFixMe\n      delete obj[key];\n      // $FlowFixMe\n      obj[key] = value;\n    },\n  });\n}\n\n// eslint-disable-next-line no-undef\nexport function arrayFrom<T>(item: Iterable<T>): $ReadOnlyArray<T> {\n  // $FlowFixMe[method-unbinding]\n  return Array.prototype.slice.call(item);\n}\n\nexport function isObject(item: mixed): boolean {\n  return typeof item === \"object\" && item !== null;\n}\n\nexport function isObjectObject(obj: mixed): boolean {\n  return (\n    // $FlowFixMe[method-unbinding]\n    isObject(obj) && Object.prototype.toString.call(obj) === \"[object Object]\"\n  );\n}\n\nexport function isPlainObject(obj: mixed): boolean {\n  if (!isObjectObject(obj)) {\n    return false;\n  }\n\n  // $FlowFixMe\n  const constructor = obj.constructor;\n\n  if (typeof constructor !== \"function\") {\n    return false;\n  }\n\n  const prototype = constructor.prototype;\n\n  if (!isObjectObject(prototype)) {\n    return false;\n  }\n\n  if (!prototype.hasOwnProperty(\"isPrototypeOf\")) {\n    return false;\n  }\n\n  return true;\n}\n\nexport function replaceObject<T: $ReadOnlyArray<mixed> | Object>(\n  item: T,\n  replacer: (mixed, string | number, string) => mixed,\n  fullKey: string = \"\"\n): T {\n  if (Array.isArray(item)) {\n    const length = item.length;\n    const result: Array<mixed> = [];\n\n    for (let i = 0; i < length; i++) {\n      defineLazyProp(result, i, () => {\n        const itemKey = fullKey ? `${fullKey}.${i}` : `${i}`;\n        const el = item[i];\n\n        let child = replacer(el, i, itemKey);\n\n        if (isPlainObject(child) || Array.isArray(child)) {\n          // $FlowFixMe\n          child = replaceObject(child, replacer, itemKey);\n        }\n\n        return child;\n      });\n    }\n\n    // $FlowFixMe\n    return result;\n  } else if (isPlainObject(item)) {\n    const result = {};\n\n    for (const key in item) {\n      if (!item.hasOwnProperty(key)) {\n        continue;\n      }\n\n      defineLazyProp(result, key, () => {\n        const itemKey = fullKey ? `${fullKey}.${key}` : `${key}`;\n        // $FlowFixMe\n        const el = item[key];\n\n        let child = replacer(el, key, itemKey);\n\n        if (isPlainObject(child) || Array.isArray(child)) {\n          // $FlowFixMe\n          child = replaceObject(child, replacer, itemKey);\n        }\n\n        return child;\n      });\n    }\n\n    // $FlowFixMe\n    return result;\n  } else {\n    throw new Error(`Pass an object or array`);\n  }\n}\n\nexport function copyProp(\n  source: Object,\n  target: Object,\n  name: string,\n  def: mixed\n) {\n  if (source.hasOwnProperty(name)) {\n    const descriptor = Object.getOwnPropertyDescriptor(source, name);\n    // $FlowFixMe\n    Object.defineProperty(target, name, descriptor);\n  } else {\n    target[name] = def;\n  }\n}\n\ntype RegexResultType = {|\n  text: string,\n  groups: $ReadOnlyArray<string>,\n  start: number,\n  end: number,\n  length: number,\n  replace: (text: string) => string,\n|};\n\nexport function regex(\n  pattern: string | RegExp,\n  string: string,\n  start: number = 0\n): ?RegexResultType {\n  if (typeof pattern === \"string\") {\n    // eslint-disable-next-line security/detect-non-literal-regexp\n    pattern = new RegExp(pattern);\n  }\n\n  const result = string.slice(start).match(pattern);\n\n  if (!result) {\n    return;\n  }\n\n  // $FlowFixMe\n  const index: number = result.index;\n  const regmatch = result[0];\n\n  return {\n    text: regmatch,\n    groups: result.slice(1),\n    start: start + index,\n    end: start + index + regmatch.length,\n    length: regmatch.length,\n\n    replace(text: string): string {\n      if (!regmatch) {\n        return \"\";\n      }\n\n      return `${regmatch.slice(0, start + index)}${text}${regmatch.slice(\n        index + regmatch.length\n      )}`;\n    },\n  };\n}\n\nexport function regexAll(\n  pattern: string | RegExp,\n  string: string\n): $ReadOnlyArray<RegexResultType> {\n  const matches = [];\n  let start = 0;\n\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    const regmatch = regex(pattern, string, start);\n\n    if (!regmatch) {\n      break;\n    }\n\n    matches.push(regmatch);\n    start = match.end;\n  }\n\n  return matches;\n}\n\nexport function isDefined(value: ?mixed): boolean {\n  return value !== null && value !== undefined;\n}\n\nexport function cycle(method: Function): ZalgoPromise<void> {\n  return ZalgoPromise.try(method).then(() => cycle(method));\n}\n\nexport function debounce<T>(\n  method: (...args: $ReadOnlyArray<mixed>) => T,\n  time: number = 100\n): (...args: $ReadOnlyArray<mixed>) => void {\n  let timeout;\n\n  const debounceWrapper = function () {\n    clearTimeout(timeout);\n\n    timeout = setTimeout(() => {\n      return method.apply(this, arguments);\n    }, time);\n  };\n\n  return setFunctionName(\n    debounceWrapper,\n    `${getFunctionName(method)}::debounced`\n  );\n}\n\nexport function isRegex(item: mixed): boolean {\n  // $FlowFixMe[method-unbinding]\n  return Object.prototype.toString.call(item) === \"[object RegExp]\";\n}\n\ntype FunctionProxy<T: Function> = (method: T) => T;\n\nexport const weakMapMemoize: FunctionProxy<*> = <R: mixed>(\n  // eslint-disable-next-line flowtype/no-weak-types\n  method: (arg: any) => R\n  // eslint-disable-next-line flowtype/no-weak-types\n): ((...args: $ReadOnlyArray<any>) => R) => {\n  const weakmap = new WeakMap();\n\n  // eslint-disable-next-line flowtype/no-weak-types\n  return function weakmapMemoized(arg: any): R {\n    return weakmap.getOrSet(arg, () => method.call(this, arg));\n  };\n};\n\ntype FunctionPromiseProxy<\n  R: mixed,\n  T: (...args: $ReadOnlyArray<mixed>) => ZalgoPromise<R>\n> = (T) => T;\n\nexport const weakMapMemoizePromise: FunctionPromiseProxy<*, *> = <R: mixed>(\n  // eslint-disable-next-line flowtype/no-weak-types\n  method: (arg: any) => ZalgoPromise<R>\n  // eslint-disable-next-line flowtype/no-weak-types\n): ((...args: $ReadOnlyArray<any>) => ZalgoPromise<R>) => {\n  const weakmap = new WeakMap();\n\n  // eslint-disable-next-line flowtype/no-weak-types\n  return function weakmapMemoizedPromise(arg: any): ZalgoPromise<R> {\n    return weakmap.getOrSet(arg, () =>\n      method.call(this, arg).finally(() => {\n        weakmap.delete(arg);\n      })\n    );\n  };\n};\n\nexport function getOrSet<O: Object, T: mixed>(\n  obj: O,\n  key: string,\n  getter: () => T\n): T {\n  if (obj.hasOwnProperty(key)) {\n    return obj[key];\n  }\n\n  const val = getter();\n  obj[key] = val;\n  return val;\n}\n\nexport type CleanupType = {|\n  set: <T: mixed>(string, T) => T, // eslint-disable-line no-undef\n  register: (Function) => {| cancel: () => void |},\n  all: (err?: mixed) => ZalgoPromise<void>,\n|};\n\nexport function cleanup(obj: Object): CleanupType {\n  const tasks = [];\n  let cleaned = false;\n  let cleanErr;\n\n  const cleaner = {\n    set<T: mixed>(name: string, item: T): T {\n      if (!cleaned) {\n        obj[name] = item;\n        cleaner.register(() => {\n          delete obj[name];\n        });\n      }\n      return item;\n    },\n\n    register(method: Function): {| cancel: () => void |} {\n      const task = once(() => method(cleanErr));\n\n      if (cleaned) {\n        method(cleanErr);\n      } else {\n        tasks.push(task);\n      }\n\n      return {\n        cancel: () => {\n          const index = tasks.indexOf(task);\n          if (index !== -1) {\n            tasks.splice(index, 1);\n          }\n        },\n      };\n    },\n\n    all(err?: mixed): ZalgoPromise<void> {\n      cleanErr = err;\n\n      const results = [];\n      cleaned = true;\n\n      while (tasks.length) {\n        const task = tasks.shift();\n        results.push(task());\n      }\n\n      return ZalgoPromise.all(results).then(noop);\n    },\n  };\n\n  return cleaner;\n}\n\nexport function tryCatch<T>(\n  fn: () => T\n): {| result: T, error: void |} | {| result: void, error: mixed |} {\n  let result;\n  let error;\n\n  try {\n    result = fn();\n  } catch (err) {\n    error = err;\n  }\n\n  // $FlowFixMe\n  return { result, error };\n}\n\n// eslint-disable-next-line flowtype/no-mutable-array\nexport function removeFromArray<X, T: Array<X>>(arr: T, item: X) {\n  const index = arr.indexOf(item);\n  if (index !== -1) {\n    arr.splice(index, 1);\n  }\n}\n\nexport function assertExists<T>(name: string, thing: void | null | T): T {\n  if (thing === null || typeof thing === \"undefined\") {\n    throw new Error(`Expected ${name} to be present`);\n  }\n\n  return thing;\n}\n\nexport function unique(arr: $ReadOnlyArray<string>): $ReadOnlyArray<string> {\n  const result = {};\n  for (const item of arr) {\n    result[item] = true;\n  }\n  return Object.keys(result);\n}\n\nexport const constHas = <X: string | boolean | number, T: { [string]: X }>(\n  constant: T,\n  value: X\n): boolean => {\n  return memoizedValues(constant).indexOf(value) !== -1;\n};\n\nexport function dedupeErrors<T>(handler: (mixed) => T): (mixed) => T | void {\n  const seenErrors = [];\n  const seenStringifiedErrors = {};\n\n  return (err) => {\n    if (seenErrors.indexOf(err) !== -1) {\n      return;\n    }\n\n    seenErrors.push(err);\n\n    const stringifiedError = stringifyError(err);\n    if (seenStringifiedErrors[stringifiedError]) {\n      return;\n    }\n\n    seenStringifiedErrors[stringifiedError] = true;\n    return handler(err);\n  };\n}\n\nexport class ExtendableError extends Error {\n  constructor(message: string) {\n    super(message);\n    // eslint-disable-next-line unicorn/custom-error-definition\n    this.name = this.constructor.name;\n    if (typeof Error.captureStackTrace === \"function\") {\n      Error.captureStackTrace(this, this.constructor);\n    } else {\n      this.stack = new Error(message).stack;\n    }\n  }\n}\n\nfunction isRelativeUrlWithoutProtocol(url: string): boolean {\n  return relativeFirstCharacters.indexOf(url[0]) > -1;\n}\n\nfunction decodeHtmlCharacters(str: string): string {\n  const removedNullByte: string = str.replace(ctrlCharactersRegex, \"\");\n  return removedNullByte.replace(htmlEntitiesRegex, (matchRegex, dec) => {\n    return String.fromCharCode(dec);\n  });\n}\n\nexport function sanitizeUrl(url?: string): string {\n  if (!url) {\n    return BLANK_URL;\n  }\n\n  const sanitizedUrl = decodeHtmlCharacters(url)\n    .replace(htmlCtrlEntityRegex, \"\")\n    .replace(ctrlCharactersRegex, \"\")\n    .trim();\n\n  if (!sanitizedUrl) {\n    return BLANK_URL;\n  }\n\n  if (isRelativeUrlWithoutProtocol(sanitizedUrl)) {\n    return sanitizedUrl;\n  }\n\n  const urlSchemeParseResults = sanitizedUrl.match(urlSchemeRegex);\n\n  if (!urlSchemeParseResults) {\n    return sanitizedUrl;\n  }\n\n  const urlScheme = urlSchemeParseResults[0];\n\n  if (invalidProtocolRegex.test(urlScheme)) {\n    return BLANK_URL;\n  }\n\n  return sanitizedUrl;\n}\n","/* @flow */\n\nexport function hasNativeWeakMap() : boolean {\n\n    if (typeof WeakMap === 'undefined') {\n        return false;\n    }\n\n    if (typeof Object.freeze === 'undefined') {\n        return false;\n    }\n\n    try {\n\n        const testWeakMap = new WeakMap();\n        const testKey = {};\n        const testValue = '__testvalue__';\n\n        Object.freeze(testKey);\n\n        testWeakMap.set(testKey, testValue);\n\n        if (testWeakMap.get(testKey) === testValue) {\n            return true;\n        }\n\n        return false;\n\n    } catch (err) {\n\n        return false;\n    }\n}\n","export default function _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}","export default function _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}","import setPrototypeOf from \"@babel/runtime/helpers/esm/setPrototypeOf\";\nimport isNativeReflectConstruct from \"@babel/runtime/helpers/esm/isNativeReflectConstruct\";\nexport default function _construct(Parent, args, Class) {\n  if (isNativeReflectConstruct()) {\n    _construct = Reflect.construct;\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n\n  return _construct.apply(null, arguments);\n}","import getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport setPrototypeOf from \"@babel/runtime/helpers/esm/setPrototypeOf\";\nimport isNativeFunction from \"@babel/runtime/helpers/esm/isNativeFunction\";\nimport construct from \"@babel/runtime/helpers/esm/construct\";\nexport default function _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n\n  _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !isNativeFunction(Class)) return Class;\n\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n\n      _cache.set(Class, Wrapper);\n    }\n\n    function Wrapper() {\n      return construct(Class, arguments, getPrototypeOf(this).constructor);\n    }\n\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return setPrototypeOf(Wrapper, Class);\n  };\n\n  return _wrapNativeSuper(Class);\n}","export default function _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}","/* @flow */\n/* eslint max-lines: off */\nimport { ZalgoPromise } from \"@krakenjs/zalgo-promise/src\";\nimport {\n  linkFrameWindow,\n  isWindowClosed,\n  assertSameDomain,\n  type SameDomainWindowType,\n  type CrossDomainWindowType,\n} from \"@krakenjs/cross-domain-utils/src\";\nimport { WeakMap } from \"@krakenjs/cross-domain-safe-weakmap/src\";\n\nimport {\n  isElement,\n  inlineMemoize,\n  memoize,\n  noop,\n  stringify,\n  capitalizeFirstLetter,\n  once,\n  extend,\n  safeInterval,\n  uniqueID,\n  arrayFrom,\n  ExtendableError,\n  strHashStr,\n} from \"./util\";\nimport { isDevice } from \"./device\";\nimport { KEY_CODES, ATTRIBUTES, UID_HASH_LENGTH } from \"./constants\";\nimport type { CancelableType } from \"./types\";\n\ntype ElementRefType = string | HTMLElement;\n\nexport function getBody(): HTMLBodyElement {\n  // eslint-disable-next-line compat/compat\n  const body = document.body;\n\n  if (!body) {\n    throw new Error(`Body element not found`);\n  }\n\n  return body;\n}\n\nexport function isDocumentReady(): boolean {\n  // eslint-disable-next-line compat/compat\n  return Boolean(document.body) && document.readyState === \"complete\";\n}\n\nexport function isDocumentInteractive(): boolean {\n  // eslint-disable-next-line compat/compat\n  return Boolean(document.body) && document.readyState === \"interactive\";\n}\n\nexport function urlEncode(str: string): string {\n  return encodeURIComponent(str);\n}\n\nexport function waitForWindowReady(): ZalgoPromise<void> {\n  return inlineMemoize(waitForWindowReady, (): ZalgoPromise<void> => {\n    return new ZalgoPromise((resolve) => {\n      if (isDocumentReady()) {\n        resolve();\n      }\n\n      window.addEventListener(\"load\", () => resolve());\n    });\n  });\n}\n\ntype WaitForDocumentReady = () => ZalgoPromise<void>;\n\nexport const waitForDocumentReady: WaitForDocumentReady = memoize(() => {\n  return new ZalgoPromise((resolve) => {\n    if (isDocumentReady() || isDocumentInteractive()) {\n      return resolve();\n    }\n\n    const interval = setInterval(() => {\n      if (isDocumentReady() || isDocumentInteractive()) {\n        clearInterval(interval);\n        return resolve();\n      }\n    }, 10);\n  });\n});\n\nexport function waitForDocumentBody(): ZalgoPromise<HTMLBodyElement> {\n  return ZalgoPromise.try(() => {\n    if (document.body) {\n      return document.body;\n    }\n\n    return waitForDocumentReady().then(() => {\n      if (document.body) {\n        return document.body;\n      }\n\n      throw new Error(\"Document ready but document.body not present\");\n    });\n  });\n}\n\nexport function parseQuery(queryString: string): Object {\n  return inlineMemoize(\n    parseQuery,\n    (): Object => {\n      const params = {};\n\n      if (!queryString) {\n        return params;\n      }\n\n      if (queryString.indexOf(\"=\") === -1) {\n        return params;\n      }\n\n      for (let pair of queryString.split(\"&\")) {\n        pair = pair.split(\"=\");\n\n        if (pair[0] && pair[1]) {\n          params[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);\n        }\n      }\n\n      return params;\n    },\n    [queryString]\n  );\n}\n\nexport function getQueryParam(name: string): string {\n  return parseQuery(window.location.search.slice(1))[name];\n}\n\nexport function urlWillRedirectPage(url: string): boolean {\n  if (url.indexOf(\"#\") === -1) {\n    return true;\n  }\n\n  if (url.indexOf(\"#\") === 0) {\n    return false;\n  }\n\n  if (url.split(\"#\")[0] === window.location.href.split(\"#\")[0]) {\n    return false;\n  }\n\n  return true;\n}\n\nexport type Query = {\n  [string]: boolean | string,\n};\n\nexport function formatQuery(obj: Query = {}): string {\n  return Object.keys(obj)\n    .filter((key) => {\n      return typeof obj[key] === \"string\" || typeof obj[key] === \"boolean\";\n    })\n    .map((key) => {\n      const val = obj[key];\n\n      if (typeof val !== \"string\" && typeof val !== \"boolean\") {\n        throw new TypeError(`Invalid type for query`);\n      }\n\n      return `${urlEncode(key)}=${urlEncode(val.toString())}`;\n    })\n    .join(\"&\");\n}\n\nexport function extendQuery(originalQuery: string, props: Query = {}): string {\n  if (!props || !Object.keys(props).length) {\n    return originalQuery;\n  }\n\n  return formatQuery({\n    ...parseQuery(originalQuery),\n    ...props,\n  });\n}\n\nexport function extendUrl(\n  url: string,\n  options: {| query?: Query, hash?: Query |}\n): string {\n  const query = options.query || {};\n  const hash = options.hash || {};\n\n  let originalUrl;\n  let originalQuery;\n  let originalHash;\n\n  [originalUrl, originalHash] = url.split(\"#\");\n  [originalUrl, originalQuery] = originalUrl.split(\"?\");\n\n  const queryString = extendQuery(originalQuery, query);\n  const hashString = extendQuery(originalHash, hash);\n\n  if (queryString) {\n    originalUrl = `${originalUrl}?${queryString}`;\n  }\n\n  if (hashString) {\n    originalUrl = `${originalUrl}#${hashString}`;\n  }\n\n  return originalUrl;\n}\n\nexport function redirect(\n  url: string,\n  win: CrossDomainWindowType = window\n): ZalgoPromise<void> {\n  return new ZalgoPromise((resolve) => {\n    win.location = url;\n    if (!urlWillRedirectPage(url)) {\n      resolve();\n    }\n  });\n}\n\nexport function hasMetaViewPort(): boolean {\n  const meta = document.querySelector(\"meta[name=viewport]\");\n\n  if (isDevice() && window.screen.width < 660 && !meta) {\n    return false;\n  }\n\n  return true;\n}\n\nexport function isElementVisible(el: HTMLElement): boolean {\n  return Boolean(\n    el.offsetWidth || el.offsetHeight || el.getClientRects().length\n  );\n}\n\nexport function getPerformance(): ?Performance {\n  return inlineMemoize(getPerformance, (): ?Performance => {\n    const performance = window.performance;\n\n    if (\n      performance &&\n      performance.now &&\n      performance.timing &&\n      performance.timing.connectEnd &&\n      performance.timing.navigationStart &&\n      Math.abs(performance.now() - Date.now()) > 1000 &&\n      performance.now() -\n        (performance.timing.connectEnd - performance.timing.navigationStart) >\n        0\n    ) {\n      return performance;\n    }\n  });\n}\n\nexport function enablePerformance(): boolean {\n  return Boolean(getPerformance());\n}\n\nexport function getPageRenderTime(): ZalgoPromise<?number> {\n  return waitForDocumentReady().then(() => {\n    const performance = getPerformance();\n\n    if (!performance) {\n      return;\n    }\n\n    const timing = performance.timing;\n\n    if (timing.connectEnd && timing.domInteractive) {\n      return timing.domInteractive - timing.connectEnd;\n    }\n  });\n}\n\nexport function htmlEncode(html: string = \"\"): string {\n  return html\n    .toString()\n    .replace(/&/g, \"&amp;\")\n    .replace(/</g, \"&lt;\")\n    .replace(/>/g, \"&gt;\")\n    .replace(/\"/g, \"&quot;\")\n    .replace(/'/g, \"&#39;\")\n    .replace(/\\//g, \"&#x2F;\");\n}\n\nexport function isBrowser(): boolean {\n  return typeof window !== \"undefined\" && window.location !== undefined;\n}\n\nexport function querySelectorAll(\n  selector: string,\n  doc: HTMLElement = window.document\n): $ReadOnlyArray<HTMLElement> {\n  // $FlowFixMe[method-unbinding]\n  return Array.prototype.slice.call(doc.querySelectorAll(selector));\n}\n\n/**\n * Sets up event handlers for click events and\n * enter/space keypresses.\n * @callback handler\n * @param {HTMLElement} element\n * @param {handler} handler\n */\nexport function onClick(element: HTMLElement, handler: (Event) => void) {\n  element.addEventListener(\"touchstart\", noop, { passive: true });\n  element.addEventListener(\"click\", handler);\n  element.addEventListener(\"keypress\", (event: Event) => {\n    if (\n      // $FlowFixMe\n      event.keyCode === KEY_CODES.ENTER ||\n      // $FlowFixMe\n      event.keyCode === KEY_CODES.SPACE\n    ) {\n      return handler(event);\n    }\n  });\n}\n\nexport function getScript({\n  host = window.location.host,\n  path,\n  reverse = false,\n}: {|\n  host?: string,\n  path: string,\n  reverse?: boolean,\n|}): ?HTMLScriptElement {\n  return inlineMemoize(\n    getScript,\n    (): ?HTMLScriptElement => {\n      const url = `${host}${path}`;\n      // $FlowFixMe[method-unbinding]\n      const scripts = Array.prototype.slice.call(\n        document.getElementsByTagName(\"script\")\n      );\n\n      if (reverse) {\n        scripts.reverse();\n      }\n\n      for (const script of scripts) {\n        if (!script.src) {\n          continue;\n        }\n\n        const src = script.src.replace(/^https?:\\/\\//, \"\").split(\"?\")[0];\n\n        if (src === url) {\n          return script;\n        }\n      }\n    },\n    [path]\n  );\n}\n\nexport function isLocalStorageEnabled(): boolean {\n  return inlineMemoize(isLocalStorageEnabled, () => {\n    try {\n      if (typeof window === \"undefined\") {\n        return false;\n      }\n\n      if (window.localStorage) {\n        const value = Math.random().toString();\n        window.localStorage.setItem(\"__test__localStorage__\", value);\n        const result = window.localStorage.getItem(\"__test__localStorage__\");\n        window.localStorage.removeItem(\"__test__localStorage__\");\n        if (value === result) {\n          return true;\n        }\n      }\n    } catch (err) {\n      // pass\n    }\n    return false;\n  });\n}\n\nexport function getBrowserLocales(): $ReadOnlyArray<{|\n  country?: string,\n  lang: string,\n|}> {\n  const nav = window.navigator;\n\n  const locales = nav.languages ? [...nav.languages] : [];\n\n  if (nav.language) {\n    locales.push(nav.language);\n  }\n\n  if (nav.userLanguage) {\n    locales.push(nav.userLanguage);\n  }\n\n  return locales\n    .map((locale) => {\n      if (locale && locale.match(/^[a-z]{2}[-_][A-Z]{2}$/)) {\n        const [lang, country] = locale.split(/[-_]/);\n        return { country, lang };\n      }\n\n      if (locale && locale.match(/^[a-z]{2}$/)) {\n        return { lang: locale };\n      }\n\n      return null;\n    })\n    .filter(Boolean);\n}\n\nexport function appendChild(container: HTMLElement, child: HTMLElement | Text) {\n  container.appendChild(child);\n}\n\nexport function getElementSafe(\n  id: ElementRefType,\n  doc: Document | HTMLElement = document\n): ?HTMLElement {\n  if (isElement(id)) {\n    // $FlowFixMe\n    return id;\n  }\n\n  if (typeof id === \"string\") {\n    return doc.querySelector(id);\n  }\n}\n\nexport function getElement(\n  id: ElementRefType,\n  doc: Document | HTMLElement = document\n): HTMLElement {\n  const element = getElementSafe(id, doc);\n\n  if (element) {\n    return element;\n  }\n\n  throw new Error(`Can not find element: ${stringify(id)}`);\n}\n\nexport function elementReady(id: ElementRefType): ZalgoPromise<HTMLElement> {\n  return new ZalgoPromise((resolve, reject) => {\n    const name = stringify(id);\n    let el = getElementSafe(id);\n\n    if (el) {\n      return resolve(el);\n    }\n\n    if (isDocumentReady()) {\n      return reject(\n        new Error(`Document is ready and element ${name} does not exist`)\n      );\n    }\n\n    const interval = setInterval(() => {\n      el = getElementSafe(id);\n\n      if (el) {\n        resolve(el);\n        clearInterval(interval);\n        return;\n      }\n\n      if (isDocumentReady()) {\n        clearInterval(interval);\n        return reject(\n          new Error(`Document is ready and element ${name} does not exist`)\n        );\n      }\n    }, 10);\n  });\n}\n\n// eslint-disable-next-line unicorn/custom-error-definition\nexport class PopupOpenError extends ExtendableError {}\n\ntype PopupOptions = {|\n  name?: string,\n  width?: number,\n  height?: number,\n  top?: number,\n  left?: number,\n  status?: 0 | 1,\n  resizable?: 0 | 1,\n  toolbar?: 0 | 1,\n  menubar?: 0 | 1,\n  scrollbars?: 0 | 1,\n  closeOnUnload?: 0 | 1,\n|};\n\nexport function popup(\n  url: string,\n  options?: PopupOptions\n): CrossDomainWindowType {\n  // $FlowFixMe\n  options = options || {};\n\n  const { closeOnUnload = 1, name = \"\", width, height } = options;\n\n  let top = 0;\n  let left = 0;\n\n  if (width) {\n    if (window.outerWidth) {\n      left = Math.round((window.outerWidth - width) / 2) + window.screenX;\n    } else if (window.screen.width) {\n      left = Math.round((window.screen.width - width) / 2);\n    }\n  }\n\n  if (height) {\n    if (window.outerHeight) {\n      top = Math.round((window.outerHeight - height) / 2) + window.screenY;\n    } else if (window.screen.height) {\n      top = Math.round((window.screen.height - height) / 2);\n    }\n  }\n\n  delete options.closeOnUnload;\n  delete options.name;\n\n  if (width && height) {\n    // $FlowFixMe\n    options = {\n      top,\n      left,\n      width,\n      height,\n      status: 1,\n      toolbar: 0,\n      menubar: 0,\n      resizable: 1,\n      scrollbars: 1,\n      ...options,\n    };\n  }\n\n  const params = Object.keys(options)\n    // eslint-disable-next-line array-callback-return\n    .map((key) => {\n      // $FlowFixMe\n      if (options[key] !== null && options[key] !== undefined) {\n        return `${key}=${stringify(options[key])}`;\n      }\n    })\n    .filter(Boolean)\n    .join(\",\");\n\n  let win;\n\n  try {\n    win = window.open(url, name, params);\n  } catch (err) {\n    throw new PopupOpenError(\n      `Can not open popup window - ${err.stack || err.message}`\n    );\n  }\n\n  if (isWindowClosed(win)) {\n    const err = new PopupOpenError(`Can not open popup window - blocked`);\n    throw err;\n  }\n\n  if (closeOnUnload) {\n    window.addEventListener(\"unload\", () => win.close());\n  }\n\n  return win;\n}\n\nexport function writeToWindow(win: SameDomainWindowType, html: string) {\n  try {\n    win.document.open();\n    win.document.write(html);\n    win.document.close();\n  } catch (err) {\n    try {\n      win.location = `javascript: document.open(); document.write(${JSON.stringify(\n        html\n      )}); document.close();`;\n    } catch (err2) {\n      // pass\n    }\n  }\n}\n\nexport function writeElementToWindow(\n  win: SameDomainWindowType,\n  el: HTMLElement\n) {\n  const tag = el.tagName.toLowerCase();\n\n  if (tag !== \"html\") {\n    throw new Error(`Expected element to be html, got ${tag}`);\n  }\n\n  const documentElement = win.document.documentElement;\n\n  for (const child of arrayFrom(documentElement.children)) {\n    documentElement.removeChild(child);\n  }\n\n  for (const child of arrayFrom(el.children)) {\n    documentElement.appendChild(child);\n  }\n}\n\nexport function setStyle(\n  el: HTMLElement,\n  styleText: string,\n  doc: Document = window.document\n) {\n  // $FlowFixMe\n  if (el.styleSheet) {\n    // $FlowFixMe\n    el.styleSheet.cssText = styleText;\n  } else {\n    el.appendChild(doc.createTextNode(styleText));\n  }\n}\n\nexport type ElementOptionsType = {|\n  style?: { [string]: string },\n  id?: string,\n  class?: ?$ReadOnlyArray<string>,\n  attributes?: { [string]: string },\n  styleSheet?: ?string,\n  html?: ?string,\n|};\n\nlet awaitFrameLoadPromises: WeakMap<\n  HTMLIFrameElement,\n  ZalgoPromise<HTMLIFrameElement>\n>;\n\nexport function awaitFrameLoad(\n  frame: HTMLIFrameElement\n): ZalgoPromise<HTMLIFrameElement> {\n  awaitFrameLoadPromises = awaitFrameLoadPromises || new WeakMap();\n\n  if (awaitFrameLoadPromises.has(frame)) {\n    const promise = awaitFrameLoadPromises.get(frame);\n    if (promise) {\n      return promise;\n    }\n  }\n\n  const promise = new ZalgoPromise((resolve, reject) => {\n    frame.addEventListener(\"load\", () => {\n      linkFrameWindow(frame);\n      resolve(frame);\n    });\n\n    frame.addEventListener(\"error\", (err: Event) => {\n      if (frame.contentWindow) {\n        resolve(frame);\n      } else {\n        reject(err);\n      }\n    });\n  });\n\n  awaitFrameLoadPromises.set(frame, promise);\n\n  return promise;\n}\n\nexport function awaitFrameWindow(\n  frame: HTMLIFrameElement\n): ZalgoPromise<CrossDomainWindowType> {\n  return awaitFrameLoad(frame).then((loadedFrame) => {\n    if (!loadedFrame.contentWindow) {\n      throw new Error(`Could not find window in iframe`);\n    }\n\n    return loadedFrame.contentWindow;\n  });\n}\n\nconst getDefaultCreateElementOptions = (): ElementOptionsType => {\n  // $FlowFixMe\n  return {};\n};\n\nexport function createElement(\n  tag: string = \"div\",\n  options: ElementOptionsType = getDefaultCreateElementOptions(),\n  container: ?HTMLElement\n): HTMLElement {\n  tag = tag.toLowerCase();\n  const element = document.createElement(tag);\n\n  if (options.style) {\n    extend(element.style, options.style);\n  }\n\n  if (options.class) {\n    element.className = options.class.join(\" \");\n  }\n\n  if (options.id) {\n    element.setAttribute(\"id\", options.id);\n  }\n\n  if (options.attributes) {\n    for (const key of Object.keys(options.attributes)) {\n      element.setAttribute(key, options.attributes[key]);\n    }\n  }\n\n  if (options.styleSheet) {\n    setStyle(element, options.styleSheet);\n  }\n\n  if (container) {\n    appendChild(container, element);\n  }\n\n  if (options.html) {\n    if (tag === \"iframe\") {\n      // $FlowFixMe\n      if (!container || !element.contentWindow) {\n        throw new Error(\n          `Iframe html can not be written unless container provided and iframe in DOM`\n        );\n      }\n\n      // $FlowFixMe\n      writeToWindow(element.contentWindow, options.html);\n    } else {\n      element.innerHTML = options.html;\n    }\n  }\n\n  return element;\n}\n\ntype StringMap = {|\n  [string]: string,\n|};\n\nexport type IframeElementOptionsType = {|\n  style?: StringMap,\n  class?: ?$ReadOnlyArray<string>,\n  attributes?: StringMap,\n  styleSheet?: ?string,\n  html?: ?string,\n  url?: ?string,\n|};\n\nconst getDefaultIframeOptions = (): IframeElementOptionsType => {\n  // $FlowFixMe\n  return {};\n};\n\nconst getDefaultStringMap = (): StringMap => {\n  // $FlowFixMe\n  return {};\n};\n\nexport function iframe(\n  options: IframeElementOptionsType = getDefaultIframeOptions(),\n  container: ?HTMLElement\n): HTMLIFrameElement {\n  const attributes = options.attributes || getDefaultStringMap();\n  const style = options.style || getDefaultStringMap();\n\n  // $FlowFixMe\n  const newAttributes = {\n    allowTransparency: \"true\",\n    ...attributes,\n  };\n\n  // $FlowFixMe\n  const newStyle = {\n    backgroundColor: \"transparent\",\n    border: \"none\",\n    ...style,\n  };\n\n  const frame = createElement(\"iframe\", {\n    attributes: newAttributes,\n    style: newStyle,\n    html: options.html,\n    class: options.class,\n  });\n\n  const isIE = window.navigator.userAgent.match(/MSIE|Edge/i);\n\n  if (!frame.hasAttribute(\"id\")) {\n    frame.setAttribute(\"id\", uniqueID());\n  }\n\n  // $FlowFixMe\n  awaitFrameLoad(frame);\n\n  if (container) {\n    const el = getElement(container);\n    el.appendChild(frame);\n  }\n\n  if (options.url || isIE) {\n    frame.setAttribute(\"src\", options.url || \"about:blank\");\n  }\n\n  // $FlowFixMe\n  return frame;\n}\n\nexport function addEventListener(\n  obj: HTMLElement,\n  event: string,\n  handler: (event: Event) => void\n): CancelableType {\n  obj.addEventListener(event, handler);\n  return {\n    cancel() {\n      obj.removeEventListener(event, handler);\n    },\n  };\n}\n\nexport function bindEvents(\n  element: HTMLElement,\n  eventNames: $ReadOnlyArray<string>,\n  handler: (event: Event) => void\n): CancelableType {\n  handler = once(handler);\n\n  for (const eventName of eventNames) {\n    element.addEventListener(eventName, handler);\n  }\n\n  return {\n    cancel: once(() => {\n      for (const eventName of eventNames) {\n        element.removeEventListener(eventName, handler);\n      }\n    }),\n  };\n}\n\nconst VENDOR_PREFIXES = [\"webkit\", \"moz\", \"ms\", \"o\"];\n\nexport function setVendorCSS(\n  element: HTMLElement,\n  name: string,\n  value: string\n) {\n  // $FlowFixMe\n  element.style[name] = value;\n\n  const capitalizedName = capitalizeFirstLetter(name);\n\n  for (const prefix of VENDOR_PREFIXES) {\n    // $FlowFixMe\n    element.style[`${prefix}${capitalizedName}`] = value;\n  }\n}\n\nconst ANIMATION_START_EVENTS = [\n  \"animationstart\",\n  \"webkitAnimationStart\",\n  \"oAnimationStart\",\n  \"MSAnimationStart\",\n];\nconst ANIMATION_END_EVENTS = [\n  \"animationend\",\n  \"webkitAnimationEnd\",\n  \"oAnimationEnd\",\n  \"MSAnimationEnd\",\n];\n\nexport function animate(\n  element: ElementRefType,\n  name: string,\n  clean: (Function) => void,\n  timeout: number = 1000\n): ZalgoPromise<void> {\n  return new ZalgoPromise((resolve, reject) => {\n    const el = getElement(element);\n\n    if (!el) {\n      return resolve();\n    }\n\n    let hasStarted = false;\n\n    // eslint-disable-next-line prefer-const\n    let startTimeout;\n    let endTimeout;\n    // eslint-disable-next-line prefer-const\n    let startEvent;\n    // eslint-disable-next-line prefer-const\n    let endEvent;\n\n    function cleanUp() {\n      clearTimeout(startTimeout);\n      clearTimeout(endTimeout);\n      startEvent.cancel();\n      endEvent.cancel();\n    }\n\n    startEvent = bindEvents(el, ANIMATION_START_EVENTS, (event) => {\n      // $FlowFixMe\n      if (event.target !== el || event.animationName !== name) {\n        return;\n      }\n\n      clearTimeout(startTimeout);\n\n      event.stopPropagation();\n\n      startEvent.cancel();\n      hasStarted = true;\n\n      endTimeout = setTimeout(() => {\n        cleanUp();\n        resolve();\n      }, timeout);\n    });\n\n    endEvent = bindEvents(el, ANIMATION_END_EVENTS, (event) => {\n      // $FlowFixMe\n      if (event.target !== el || event.animationName !== name) {\n        return;\n      }\n\n      cleanUp();\n\n      if (\n        // $FlowFixMe\n        typeof event.animationName === \"string\" &&\n        event.animationName !== name\n      ) {\n        return reject(\n          `Expected animation name to be ${name}, found ${event.animationName}`\n        );\n      }\n\n      return resolve();\n    });\n\n    setVendorCSS(el, \"animationName\", name);\n\n    startTimeout = setTimeout(() => {\n      if (!hasStarted) {\n        cleanUp();\n        return resolve();\n      }\n    }, 200);\n\n    if (clean) {\n      clean(cleanUp);\n    }\n  });\n}\n\nexport function makeElementVisible(element: HTMLElement) {\n  element.style.setProperty(\"visibility\", \"\");\n}\n\nexport function makeElementInvisible(element: HTMLElement) {\n  element.style.setProperty(\"visibility\", \"hidden\", \"important\");\n}\n\nexport function showElement(element: HTMLElement) {\n  element.style.setProperty(\"display\", \"\");\n}\n\nexport function hideElement(element: HTMLElement) {\n  element.style.setProperty(\"display\", \"none\", \"important\");\n}\n\nexport function destroyElement(element: HTMLElement) {\n  if (element && element.parentNode) {\n    element.parentNode.removeChild(element);\n  }\n}\n\nexport function showAndAnimate(\n  element: HTMLElement,\n  name: string,\n  clean: (Function) => void\n): ZalgoPromise<void> {\n  const animation = animate(element, name, clean);\n  showElement(element);\n  return animation;\n}\n\nexport function animateAndHide(\n  element: HTMLElement,\n  name: string,\n  clean: (Function) => void\n): ZalgoPromise<void> {\n  return animate(element, name, clean).then(() => {\n    hideElement(element);\n  });\n}\n\nexport function addClass(element: HTMLElement, name: string) {\n  element.classList.add(name);\n}\n\nexport function removeClass(element: HTMLElement, name: string) {\n  element.classList.remove(name);\n}\n\nexport function isElementClosed(el: HTMLElement): boolean {\n  if (\n    !el ||\n    !el.parentNode ||\n    !el.ownerDocument ||\n    !el.ownerDocument.documentElement ||\n    !el.ownerDocument.documentElement.contains(el)\n  ) {\n    return true;\n  }\n  return false;\n}\n\nexport function watchElementForClose(\n  element: HTMLElement,\n  handler: () => mixed\n): CancelableType {\n  handler = once(handler);\n\n  let cancelled = false;\n  const mutationObservers = [];\n  // eslint-disable-next-line prefer-const\n  let interval;\n  // eslint-disable-next-line prefer-const\n  let sacrificialFrame;\n  let sacrificialFrameWin;\n\n  const cancel = () => {\n    cancelled = true;\n    for (const observer of mutationObservers) {\n      observer.disconnect();\n    }\n    if (interval) {\n      interval.cancel();\n    }\n    if (sacrificialFrameWin) {\n      // eslint-disable-next-line no-use-before-define\n      sacrificialFrameWin.removeEventListener(\"unload\", elementClosed);\n    }\n    if (sacrificialFrame) {\n      destroyElement(sacrificialFrame);\n    }\n  };\n\n  const elementClosed = () => {\n    if (!cancelled) {\n      handler();\n      cancel();\n    }\n  };\n\n  if (isElementClosed(element)) {\n    elementClosed();\n    return { cancel };\n  }\n\n  // Strategy 1: Mutation observer\n\n  if (window.MutationObserver) {\n    let mutationElement = element.parentElement;\n    while (mutationElement) {\n      const mutationObserver = new window.MutationObserver(() => {\n        if (isElementClosed(element)) {\n          elementClosed();\n        }\n      });\n\n      mutationObserver.observe(mutationElement, { childList: true });\n      mutationObservers.push(mutationObserver);\n      mutationElement = mutationElement.parentElement;\n    }\n  }\n\n  // Strategy 2: Sacrificial iframe\n\n  sacrificialFrame = document.createElement(\"iframe\");\n  sacrificialFrame.setAttribute(\"name\", `__detect_close_${uniqueID()}__`);\n  sacrificialFrame.style.display = \"none\";\n  awaitFrameWindow(sacrificialFrame).then((frameWin) => {\n    sacrificialFrameWin = assertSameDomain(frameWin);\n    sacrificialFrameWin.addEventListener(\"unload\", elementClosed);\n  });\n  element.appendChild(sacrificialFrame);\n\n  // Strategy 3: Poller\n\n  const check = () => {\n    if (isElementClosed(element)) {\n      elementClosed();\n    }\n  };\n  interval = safeInterval(check, 1000);\n\n  return { cancel };\n}\n\nexport function fixScripts(el: HTMLElement, doc: Document = window.document) {\n  for (const script of querySelectorAll(\"script\", el)) {\n    const parentNode = script.parentNode;\n\n    if (!parentNode) {\n      continue;\n    }\n\n    const newScript = doc.createElement(\"script\");\n    newScript.text = script.textContent;\n    parentNode.replaceChild(newScript, script);\n  }\n}\n\ntype OnResizeOptions = {|\n  width?: boolean,\n  height?: boolean,\n  interval?: number,\n  win?: SameDomainWindowType,\n|};\n\nexport function onResize(\n  el: HTMLElement,\n  handler: ({| width: number, height: number |}) => void,\n  {\n    width = true,\n    height = true,\n    interval = 100,\n    win = window,\n  }: OnResizeOptions = {}\n): {| cancel: () => void |} {\n  let currentWidth = el.offsetWidth;\n  let currentHeight = el.offsetHeight;\n  let canceled = false;\n\n  handler({ width: currentWidth, height: currentHeight });\n\n  const check = () => {\n    if (canceled || !isElementVisible(el)) {\n      return;\n    }\n\n    const newWidth = el.offsetWidth;\n    const newHeight = el.offsetHeight;\n\n    if (\n      (width && newWidth !== currentWidth) ||\n      (height && newHeight !== currentHeight)\n    ) {\n      handler({ width: newWidth, height: newHeight });\n    }\n\n    currentWidth = newWidth;\n    currentHeight = newHeight;\n  };\n\n  let observer;\n  let timeout;\n\n  win.addEventListener(\"resize\", check);\n\n  if (typeof win.ResizeObserver !== \"undefined\") {\n    observer = new win.ResizeObserver(check);\n    observer.observe(el);\n    timeout = safeInterval(check, interval * 10);\n  } else if (typeof win.MutationObserver !== \"undefined\") {\n    observer = new win.MutationObserver(check);\n    observer.observe(el, {\n      attributes: true,\n      childList: true,\n      subtree: true,\n      characterData: false,\n    });\n    timeout = safeInterval(check, interval * 10);\n  } else {\n    timeout = safeInterval(check, interval);\n  }\n\n  return {\n    cancel: () => {\n      canceled = true;\n      observer.disconnect();\n      window.removeEventListener(\"resize\", check);\n      timeout.cancel();\n    },\n  };\n}\n\nexport function getResourceLoadTime(url: string): ?number {\n  const performance = getPerformance();\n\n  if (!performance) {\n    return;\n  }\n\n  // $FlowFixMe[method-unbinding]\n  if (typeof performance.getEntries !== \"function\") {\n    return;\n  }\n\n  const entries = performance.getEntries();\n\n  for (let i = 0; i < entries.length; i++) {\n    const entry = entries[i];\n\n    if (\n      entry &&\n      entry.name &&\n      entry.name.indexOf(url) === 0 &&\n      typeof entry.duration === \"number\"\n    ) {\n      return Math.floor(entry.duration);\n    }\n  }\n}\n\nexport function isShadowElement(element: Node): boolean {\n  while (element.parentNode) {\n    element = element.parentNode;\n  }\n\n  return element.toString() === \"[object ShadowRoot]\";\n}\n\nexport function getShadowRoot(element: Node): ?Node {\n  while (element.parentNode) {\n    element = element.parentNode;\n  }\n\n  if (isShadowElement(element)) {\n    return element;\n  }\n}\n\nexport function getShadowHost(element: Node): ?HTMLElement {\n  const shadowRoot = getShadowRoot(element);\n\n  // $FlowFixMe\n  if (shadowRoot && shadowRoot.host) {\n    // $FlowFixMe\n    return shadowRoot.host;\n  }\n}\n\nexport function insertShadowSlot(element: HTMLElement): HTMLElement {\n  const shadowHost = getShadowHost(element);\n\n  if (!shadowHost) {\n    throw new Error(`Element is not in shadow dom`);\n  }\n\n  const slotName = `shadow-slot-${uniqueID()}`;\n  const slot = document.createElement(\"slot\");\n  slot.setAttribute(\"name\", slotName);\n  element.appendChild(slot);\n\n  const slotProvider = document.createElement(\"div\");\n  slotProvider.setAttribute(\"slot\", slotName);\n  shadowHost.appendChild(slotProvider);\n\n  if (isShadowElement(shadowHost)) {\n    return insertShadowSlot(slotProvider);\n  }\n\n  return slotProvider;\n}\n\nexport function preventClickFocus(el: HTMLElement) {\n  const onFocus = (event: Event) => {\n    el.removeEventListener(\"focus\", onFocus);\n    event.preventDefault();\n    el.blur();\n    return false;\n  };\n\n  el.addEventListener(\"mousedown\", () => {\n    el.addEventListener(\"focus\", onFocus);\n    setTimeout(() => {\n      el.removeEventListener(\"focus\", onFocus);\n    }, 1);\n  });\n}\n\nexport function getStackTrace(): string {\n  try {\n    throw new Error(\"_\");\n  } catch (err) {\n    return err.stack || \"\";\n  }\n}\n\nfunction inferCurrentScript(): ?HTMLScriptElement {\n  try {\n    const stack = getStackTrace();\n    const stackDetails = /.*at [^(]*\\((.*):(.+):(.+)\\)$/gi.exec(stack);\n    const scriptLocation = stackDetails && stackDetails[1];\n\n    if (!scriptLocation) {\n      return;\n    }\n\n    // $FlowFixMe[method-unbinding]\n    for (const script of Array.prototype.slice\n      .call(document.getElementsByTagName(\"script\"))\n      .reverse()) {\n      if (script.src && script.src === scriptLocation) {\n        return script;\n      }\n    }\n  } catch (err) {\n    // pass\n  }\n}\n\nlet currentScript =\n  // eslint-disable-next-line compat/compat\n  typeof document !== \"undefined\" ? document.currentScript : null;\n\ntype GetCurrentScript = () => HTMLScriptElement;\n\nexport const getCurrentScript: GetCurrentScript = memoize(() => {\n  if (currentScript) {\n    return currentScript;\n  }\n\n  currentScript = inferCurrentScript();\n\n  if (currentScript) {\n    return currentScript;\n  }\n\n  throw new Error(\"Can not determine current script\");\n});\n\nconst currentUID = uniqueID();\n\ntype GetCurrentScriptUID = () => string;\n\nexport const getCurrentScriptUID: GetCurrentScriptUID = memoize(() => {\n  let script;\n\n  try {\n    script = getCurrentScript();\n  } catch (err) {\n    return currentUID;\n  }\n\n  let uid = script.getAttribute(ATTRIBUTES.UID);\n\n  if (uid && typeof uid === \"string\") {\n    return uid;\n  }\n\n  uid = script.getAttribute(`${ATTRIBUTES.UID}-auto`);\n\n  if (uid && typeof uid === \"string\") {\n    return uid;\n  }\n\n  if (script.src) {\n    const { src, dataset } = script;\n    const stringToHash = JSON.stringify({ src, dataset });\n    const hashedString = strHashStr(stringToHash);\n    const hashResult = hashedString.slice(\n      hashedString.length - UID_HASH_LENGTH\n    );\n\n    uid = `uid_${hashResult}`;\n  } else {\n    uid = uniqueID();\n  }\n\n  script.setAttribute(`${ATTRIBUTES.UID}-auto`, uid);\n\n  return uid;\n});\n\ntype SubmitFormOptions = {|\n  url: string,\n  target: string,\n  body?: {| [string]: string | boolean |},\n  method?: string,\n|};\n\nexport function submitForm({\n  url,\n  target,\n  body,\n  method = \"post\",\n}: SubmitFormOptions) {\n  const form = document.createElement(\"form\");\n  form.setAttribute(\"target\", target);\n  form.setAttribute(\"method\", method);\n  form.setAttribute(\"action\", url);\n  form.style.display = \"none\";\n\n  if (body) {\n    for (const key of Object.keys(body)) {\n      const input = document.createElement(\"input\");\n      input.setAttribute(\"name\", key);\n      input.setAttribute(\"value\", body[key]?.toString());\n      form.appendChild(input);\n    }\n  }\n\n  getBody().appendChild(form);\n  form.submit();\n  getBody().removeChild(form);\n}\n","/* @flow */\n\nimport {\n  type CrossDomainWindowType,\n  type SameDomainWindowType,\n} from \"@krakenjs/cross-domain-utils/src\";\nimport { WeakMap } from \"@krakenjs/cross-domain-safe-weakmap/src\";\nimport { getOrSet, getCurrentScriptUID } from \"@krakenjs/belter/src\";\n\nexport function getGlobalKey(): string {\n  if (__POST_ROBOT__.__SCRIPT_NAMESPACE__) {\n    return `${__POST_ROBOT__.__GLOBAL_KEY__}_${getCurrentScriptUID()}`;\n  } else {\n    return __POST_ROBOT__.__GLOBAL_KEY__;\n  }\n}\n\nexport function getGlobal(win: SameDomainWindowType = window): Object {\n  const globalKey = getGlobalKey();\n\n  if (win !== window) {\n    return win[globalKey];\n  }\n  const global: Object = (win[globalKey] = win[globalKey] || {});\n  return global;\n}\n\nexport function deleteGlobal() {\n  const globalKey = getGlobalKey();\n  delete window[globalKey];\n}\n\ntype ObjectGetter = () => Object;\nconst getObj: ObjectGetter = () => ({});\n\ntype GetOrSet<T> = ((string, () => T) => T) & ((string, () => void) => void);\n\ntype GlobalStore<T> = {|\n  get: ((string, T) => T) & ((string, void) => T | void),\n  set: (string, T) => T,\n  has: (string) => boolean,\n  del: (string) => void,\n  getOrSet: GetOrSet<T>,\n  reset: () => void,\n  keys: () => $ReadOnlyArray<string>,\n|};\n\nexport function globalStore<T: mixed>(\n  key?: string = \"store\",\n  defStore?: ObjectGetter = getObj\n): GlobalStore<T> {\n  return getOrSet(getGlobal(), key, () => {\n    let store = defStore();\n\n    return {\n      has: (storeKey) => {\n        return store.hasOwnProperty(storeKey);\n      },\n      get: (storeKey, defVal) => {\n        // $FlowFixMe\n        return store.hasOwnProperty(storeKey) ? store[storeKey] : defVal;\n      },\n      set: (storeKey, val) => {\n        store[storeKey] = val;\n        return val;\n      },\n      del: (storeKey) => {\n        delete store[storeKey];\n      },\n      getOrSet: (storeKey, getter) => {\n        // $FlowFixMe\n        return getOrSet(store, storeKey, getter);\n      },\n      reset: () => {\n        store = defStore();\n      },\n      keys: () => {\n        return Object.keys(store);\n      },\n    };\n  });\n}\n\nexport class WildCard {}\n\nexport function getWildcard(): WildCard {\n  const global = getGlobal();\n  global.WINDOW_WILDCARD = global.WINDOW_WILDCARD || new WildCard();\n  return global.WINDOW_WILDCARD;\n}\n\ntype WindowStore<T> = {|\n  get: ((CrossDomainWindowType | WildCard, T) => T) &\n    ((CrossDomainWindowType | WildCard, void) => T | void),\n  set: (CrossDomainWindowType | WildCard, T) => T,\n  has: (CrossDomainWindowType | WildCard) => boolean,\n  del: (CrossDomainWindowType | WildCard) => void,\n  getOrSet: (CrossDomainWindowType | WildCard, () => T) => T,\n|};\n\nexport function windowStore<T>(\n  key?: string = \"store\",\n  defStore?: ObjectGetter = getObj\n): WindowStore<T> {\n  return globalStore(\"windowStore\").getOrSet(key, () => {\n    const winStore = new WeakMap();\n\n    const getStore = (win: CrossDomainWindowType | WildCard): ObjectGetter => {\n      return winStore.getOrSet(win, defStore);\n    };\n\n    return {\n      has: (win) => {\n        const store = getStore(win);\n        return store.hasOwnProperty(key);\n      },\n      get: (win, defVal) => {\n        const store = getStore(win);\n        // $FlowFixMe\n        return store.hasOwnProperty(key) ? store[key] : defVal;\n      },\n      set: (win, val) => {\n        const store = getStore(win);\n        store[key] = val;\n        return val;\n      },\n      del: (win) => {\n        const store = getStore(win);\n        delete store[key];\n      },\n      getOrSet: (win, getter) => {\n        const store = getStore(win);\n        return getOrSet(store, key, getter);\n      },\n    };\n  });\n}\n","/* @flow */\n\nexport const KEY_CODES = {\n  ENTER: 13,\n  SPACE: 32,\n};\n\nexport const ATTRIBUTES = {\n  UID: \"data-uid\",\n};\n\nexport const UID_HASH_LENGTH = 30;\n\n/* eslint-disable no-control-regex*/\nexport const invalidProtocolRegex: RegExp =\n  /([^\\w]*)(javascript|data|vbscript)/im;\nexport const htmlEntitiesRegex: RegExp = /&#(\\w+)(^\\w|;)?/g;\nexport const htmlCtrlEntityRegex: RegExp = /&(newline|tab);/gi;\nexport const ctrlCharactersRegex: RegExp =\n  /[\\u0000-\\u001F\\u007F-\\u009F\\u2000-\\u200D\\uFEFF]/gim;\nexport const urlSchemeRegex: RegExp = /^.+(:|&colon;)/gim;\nexport const relativeFirstCharacters = [\".\", \"/\"];\nexport const BLANK_URL = \"about:blank\";\n/* eslint-enable no-control-regex*/\n","/* @flow */\n\nimport {\n  getAncestor,\n  type CrossDomainWindowType,\n} from \"@krakenjs/cross-domain-utils/src\";\nimport { ZalgoPromise } from \"@krakenjs/zalgo-promise/src\";\nimport { uniqueID } from \"@krakenjs/belter/src\";\n\nimport { MESSAGE_NAME, WILDCARD } from \"../conf\";\nimport { windowStore, globalStore, getGlobal } from \"../global\";\nimport type { OnType, SendType, CancelableType } from \"../types\";\n\nfunction getInstanceID(): string {\n  return globalStore(\"instance\").getOrSet(\"instanceID\", uniqueID);\n}\n\nfunction getHelloPromise(\n  win: CrossDomainWindowType\n): ZalgoPromise<{| domain: string |}> {\n  const helloPromises = windowStore(\"helloPromises\");\n  return helloPromises.getOrSet(win, () => new ZalgoPromise());\n}\n\nfunction resolveHelloPromise(\n  win: CrossDomainWindowType,\n  { domain }\n): ZalgoPromise<{| domain: string |}> {\n  const helloPromises = windowStore(\"helloPromises\");\n  const existingPromise = helloPromises.get(win);\n  if (existingPromise) {\n    existingPromise.resolve({ domain });\n  }\n  const newPromise = ZalgoPromise.resolve({ domain });\n  helloPromises.set(win, newPromise);\n  return newPromise;\n}\n\nfunction listenForHello({ on }: {| on: OnType |}): CancelableType {\n  return on(MESSAGE_NAME.HELLO, { domain: WILDCARD }, ({ source, origin }) => {\n    resolveHelloPromise(source, { domain: origin });\n    return { instanceID: getInstanceID() };\n  });\n}\n\nexport function sayHello(\n  win: CrossDomainWindowType,\n  { send }: {| send: SendType |}\n): ZalgoPromise<{|\n  win: CrossDomainWindowType,\n  domain: string,\n  instanceID: string,\n|}> {\n  return send(\n    win,\n    MESSAGE_NAME.HELLO,\n    { instanceID: getInstanceID() },\n    { domain: WILDCARD, timeout: -1 }\n  ).then(({ origin, data: { instanceID } }) => {\n    resolveHelloPromise(win, { domain: origin });\n    return { win, domain: origin, instanceID };\n  });\n}\n\nexport function getWindowInstanceID(\n  win: CrossDomainWindowType,\n  { send }: {| send: SendType |}\n): ZalgoPromise<string> {\n  return windowStore(\"windowInstanceIDPromises\").getOrSet(win, () => {\n    return sayHello(win, { send }).then(({ instanceID }) => instanceID);\n  });\n}\n\nexport function initHello({\n  on,\n  send,\n}: {|\n  on: OnType,\n  send: SendType,\n|}): CancelableType {\n  return globalStore(\"builtinListeners\").getOrSet(\"helloListener\", () => {\n    const listener = listenForHello({ on });\n\n    const parent = getAncestor();\n    if (parent) {\n      sayHello(parent, { send }).catch((err) => {\n        // $FlowFixMe\n        if (__TEST__ && getGlobal(parent)) {\n          throw err;\n        }\n      });\n    }\n\n    return listener;\n  });\n}\n\nexport function awaitWindowHello(\n  win: CrossDomainWindowType,\n  timeout: number = 5000,\n  name: string = \"Window\"\n): ZalgoPromise<{| domain: string |}> {\n  let promise = getHelloPromise(win);\n\n  if (timeout !== -1) {\n    promise = promise.timeout(\n      timeout,\n      new Error(`${name} did not load after ${timeout}ms`)\n    );\n  }\n\n  return promise;\n}\n","/* @flow */\n\nexport const MESSAGE_TYPE = {\n  REQUEST: (\"postrobot_message_request\": \"postrobot_message_request\"),\n  RESPONSE: (\"postrobot_message_response\": \"postrobot_message_response\"),\n  ACK: (\"postrobot_message_ack\": \"postrobot_message_ack\"),\n};\n\nexport const MESSAGE_ACK = {\n  SUCCESS: (\"success\": \"success\"),\n  ERROR: (\"error\": \"error\"),\n};\n\nexport const MESSAGE_NAME = {\n  METHOD: (\"postrobot_method\": \"postrobot_method\"),\n  HELLO: (\"postrobot_hello\": \"postrobot_hello\"),\n  OPEN_TUNNEL: (\"postrobot_open_tunnel\": \"postrobot_open_tunnel\"),\n};\n\nexport const SEND_STRATEGY = {\n  POST_MESSAGE: (\"postrobot_post_message\": \"postrobot_post_message\"),\n  BRIDGE: (\"postrobot_bridge\": \"postrobot_bridge\"),\n  GLOBAL: (\"postrobot_global\": \"postrobot_global\"),\n};\n\nexport const BRIDGE_NAME_PREFIX = \"__postrobot_bridge__\";\nexport const POSTROBOT_PROXY = \"__postrobot_proxy__\";\n\nexport const WILDCARD = \"*\";\n\nexport const SERIALIZATION_TYPE = {\n  CROSS_DOMAIN_ZALGO_PROMISE:\n    (\"cross_domain_zalgo_promise\": \"cross_domain_zalgo_promise\"),\n  CROSS_DOMAIN_FUNCTION: (\"cross_domain_function\": \"cross_domain_function\"),\n  CROSS_DOMAIN_WINDOW: (\"cross_domain_window\": \"cross_domain_window\"),\n};\n\nexport const METHOD = {\n  GET: (\"get\": \"get\"),\n  POST: (\"post\": \"post\"),\n};\n","/* @flow */\n\nimport { type CrossDomainWindowType } from \"@krakenjs/cross-domain-utils/src\";\n\nimport { windowStore } from \"../global\";\n\nexport function markWindowKnown(win: CrossDomainWindowType) {\n  const knownWindows = windowStore(\"knownWindows\");\n  knownWindows.set(win, true);\n}\n\nexport function isWindowKnown(win: CrossDomainWindowType): boolean {\n  const knownWindows = windowStore(\"knownWindows\");\n  return knownWindows.get(win, false);\n}\n","/* @flow */\n\nimport { TYPE } from './constants';\nimport type { CustomSerializedType } from './types';\n\nexport function isSerializedType(item : mixed) : boolean {\n    return (typeof item === 'object' && item !== null && typeof item.__type__ === 'string');\n}\n\nexport function determineType(val : mixed) : $Values<typeof TYPE> | void {\n    if (typeof val === 'undefined') {\n        return TYPE.UNDEFINED;\n    }\n\n    if (val === null) {\n        return TYPE.NULL;\n    }\n\n    if (Array.isArray(val)) {\n        return TYPE.ARRAY;\n    }\n\n    if (typeof val === 'function') {\n        return TYPE.FUNCTION;\n    }\n\n    if (typeof val === 'object') {\n\n        if (val instanceof Error) {\n            return TYPE.ERROR;\n        }\n\n        if (typeof val.then === 'function') {\n            return TYPE.PROMISE;\n        }\n\n        // $FlowFixMe method-unbinding\n        if (Object.prototype.toString.call(val) === '[object RegExp]') {\n            return TYPE.REGEX;\n        }\n\n        // $FlowFixMe method-unbinding\n        if (Object.prototype.toString.call(val) === '[object Date]') {\n            return TYPE.DATE;\n        }\n\n        return TYPE.OBJECT;\n    }\n\n    if (typeof val === 'string') {\n        return TYPE.STRING;\n    }\n\n    if (typeof val === 'number') {\n        return TYPE.NUMBER;\n    }\n\n    if (typeof val === 'boolean') {\n        return TYPE.BOOLEAN;\n    }\n}\n\nexport function serializeType<T : string, V : mixed>(type : T, val : V) : CustomSerializedType<T, V> {\n    return {\n        __type__: type,\n        __val__:  val\n    };\n}\n","/* @flow */\n\nexport const TYPE = {\n    FUNCTION:  ('function' : 'function'),\n    ERROR:     ('error' : 'error'),\n    PROMISE:   ('promise' : 'promise'),\n    REGEX:     ('regex' : 'regex'),\n    DATE:      ('date' : 'date'),\n    ARRAY:     ('array' : 'array'),\n    OBJECT:    ('object' : 'object'),\n    STRING:    ('string' : 'string'),\n    NUMBER:    ('number' : 'number'),\n    BOOLEAN:   ('boolean' : 'boolean'),\n    NULL:      ('null' : 'null'),\n    UNDEFINED: ('undefined' : 'undefined')\n};\n","/* @flow */\n\nimport { TYPE } from './constants';\nimport type { Thenable, CustomSerializedType, NativeSerializedType } from './types';\nimport { determineType, isSerializedType } from './common';\nimport {\n    serializeFunction,\n    serializeError, type SerializedError,\n    serializePromise,\n    serializeRegex, type SerializedRegex,\n    serializeDate, type SerializedDate,\n    serializeArray,\n    serializeObject,\n    serializeString,\n    serializeNumber,\n    serializeBoolean,\n    serializeNull,\n    serializeUndefined\n} from './serializers';\n\ntype NativeSerializer<V : mixed, S : mixed, T : $Values<typeof TYPE>> = (value : V, key : string) => NativeSerializedType<T, S>;\ntype CustomSerializer<V : mixed, S : mixed, T : string> = (value : V, key : string) => CustomSerializedType<T, S>;\ntype PrimitiveSerializer<V : mixed, S : mixed> = (value : V, key : string) => S;\ntype CustomOrPrimitiveSerializer<V : mixed, T : string> = CustomSerializer<V, *, T> | PrimitiveSerializer<V, *>;\ntype NativeOrCustomOrPrimitiveSerializer<V : mixed, S : mixed, T : string> = NativeSerializer<V, S, T> | CustomOrPrimitiveSerializer<V, T>;\n\ntype Serializers = {|\n    function? : CustomOrPrimitiveSerializer<Function, typeof TYPE.FUNCTION>,\n    error? : NativeOrCustomOrPrimitiveSerializer<Error, SerializedError, typeof TYPE.ERROR>,\n    promise? : CustomOrPrimitiveSerializer<Thenable, typeof TYPE.PROMISE>,\n    regex? : NativeOrCustomOrPrimitiveSerializer<RegExp, SerializedRegex, typeof TYPE.REGEX>,\n    date? : NativeOrCustomOrPrimitiveSerializer<Date, SerializedDate, typeof TYPE.DATE>,\n    array? : CustomOrPrimitiveSerializer<$ReadOnlyArray<mixed>, typeof TYPE.ARRAY>,\n    object? : CustomOrPrimitiveSerializer<Object, typeof TYPE.OBJECT>,\n    string? : CustomOrPrimitiveSerializer<string, typeof TYPE.STRING>,\n    number? : CustomOrPrimitiveSerializer<number, typeof TYPE.NUMBER>,\n    boolean? : CustomOrPrimitiveSerializer<boolean, typeof TYPE.BOOLEAN>,\n    null? : CustomOrPrimitiveSerializer<null, typeof TYPE.NULL>,\n    undefined? : CustomOrPrimitiveSerializer<void, typeof TYPE.UNDEFINED>\n|};\n\nconst SERIALIZER : Serializers = {\n    [ TYPE.FUNCTION ]:  serializeFunction,\n    [ TYPE.ERROR ]:     serializeError,\n    [ TYPE.PROMISE ]:   serializePromise,\n    [ TYPE.REGEX ]:     serializeRegex,\n    [ TYPE.DATE ]:      serializeDate,\n    [ TYPE.ARRAY ]:     serializeArray,\n    [ TYPE.OBJECT ]:    serializeObject,\n    [ TYPE.STRING ]:    serializeString,\n    [ TYPE.NUMBER ]:    serializeNumber,\n    [ TYPE.BOOLEAN ]:   serializeBoolean,\n    [ TYPE.NULL ]:      serializeNull,\n    [ TYPE.UNDEFINED ]: serializeUndefined\n};\n\n// $FlowFixMe\nconst defaultSerializers : Serializers = {};\n\nexport function serialize<T : mixed>(obj : T, serializers : Serializers = defaultSerializers) : string {\n\n    function replacer(key) : ?mixed {\n        const val = this[key];\n\n        if (isSerializedType(this)) {\n            return val;\n        }\n        \n        const type = determineType(val);\n\n        if (!type) {\n            return val;\n        }\n\n        // $FlowFixMe\n        const serializer = serializers[type] || SERIALIZER[type];\n\n        if (!serializer) {\n            return val;\n        }\n\n        return serializer(val, key);\n    }\n\n    const result = JSON.stringify(obj, replacer);\n\n    if (typeof result === 'undefined') {\n        return TYPE.UNDEFINED;\n    }\n\n    return result;\n}\n","/* @flow */\n\nexport type SerializedFunction = void;\n\nexport function serializeFunction() : SerializedFunction {\n    // pass\n}\n\nexport function deserializeFunction() {\n    throw new Error(`Function serialization is not implemented; nothing to deserialize`);\n}\n","/* @flow */\n\nimport { serializeType } from '../common';\nimport { TYPE } from '../constants';\nimport type { NativeSerializedType } from '../types';\n\nimport { serializeObject } from './object';\n\nexport type SerializedError = {|\n    message : string,\n    stack : string,\n    code : string | number | void,\n    data : mixed\n|};\n\n// $FlowFixMe\nexport function serializeError({ message, stack, code, data } : Error) : NativeSerializedType<typeof TYPE.ERROR, SerializedError> {\n    return serializeType(TYPE.ERROR, { message, stack, code, data });\n}\n\nexport function deserializeError({ message, stack, code, data } : SerializedError) : Error {\n    const error = new Error(message);\n    // $FlowFixMe\n    error.code = code;\n\n    if (data) {\n        // $FlowFixMe\n        error.data = serializeObject(data);\n    }\n\n    error.stack = `${ stack }\\n\\n${ error.stack }`;\n    return error;\n}\n","/* @flow */\n\nimport type { Thenable } from '../types';\n\nexport type SerializedPromise = void;\n\nexport function serializePromise() : SerializedPromise {\n    // pass\n}\n\nexport function deserializePromise() : Thenable {\n    throw new Error(`Promise serialization is not implemented; nothing to deserialize`);\n}\n","/* @flow */\n\nimport { serializeType } from '../common';\nimport { TYPE } from '../constants';\nimport type { NativeSerializedType } from '../types';\n\nexport type SerializedRegex = string;\n\nexport function serializeRegex(val : RegExp) : NativeSerializedType<typeof TYPE.REGEX, SerializedRegex> {\n    return serializeType(TYPE.REGEX, val.source);\n}\n\nexport function deserializeRegex(val : string) : RegExp {\n    // eslint-disable-next-line security/detect-non-literal-regexp\n    return new RegExp(val);\n}\n","/* @flow */\n\nimport { serializeType } from '../common';\nimport { TYPE } from '../constants';\nimport type { NativeSerializedType } from '../types';\n\nexport type SerializedDate = string;\n\nexport function serializeDate(val : Date) : NativeSerializedType<typeof TYPE.DATE, SerializedDate> {\n    return serializeType(TYPE.DATE, val.toJSON());\n}\n\nexport function deserializeDate(val : string) : Date {\n    return new Date(val);\n}\n","/* @flow */\n\nexport type SerializedArray<T : mixed = mixed> = $ReadOnlyArray<T>;\n\nexport function serializeArray<T : mixed>(val : $ReadOnlyArray<T>) : SerializedArray<T> {\n    return val;\n}\n\nexport function deserializeArray<T : mixed>(val : SerializedArray<T>) : $ReadOnlyArray<T> {\n    return val;\n}\n","/* @flow */\n\nexport type SerializedObject = Object;\n\nexport function serializeObject(val : Object) : SerializedObject {\n    return val;\n}\n\nexport function deserializeObject(val : SerializedObject) : Object {\n    return val;\n}\n","/* @flow */\n\nexport type SerializedString = string;\n\nexport function serializeString(val : string) : SerializedString {\n    return val;\n}\n\nexport function deserializeString(val : SerializedString) : string {\n    return val;\n}\n","/* @flow */\n\nexport type SerializedNumber = number;\n\nexport function serializeNumber(val : number) : SerializedNumber {\n    return val;\n}\n\nexport function deserializeNumber(val : SerializedNumber) : number {\n    return val;\n}\n","/* @flow */\n\nexport type SerializedBoolean = boolean;\n\nexport function serializeBoolean(val : boolean) : SerializedBoolean {\n    return val;\n}\n\nexport function deserializeBoolean(val : SerializedBoolean) : boolean {\n    return val;\n}\n","/* @flow */\n\nexport type SerializedNull = null;\n\nexport function serializeNull(val : null) : SerializedNull {\n    return val;\n}\n\nexport function deserializeNull(val : SerializedNull) : null {\n    return val;\n}\n","/* @flow */\n\nimport type { NativeSerializedType } from '../types';\nimport { serializeType } from '../common';\nimport { TYPE } from '../constants';\n\nexport type SerializedUndefined = void;\n\nexport function serializeUndefined(val : void) : NativeSerializedType<typeof TYPE.UNDEFINED, SerializedUndefined> {\n    return serializeType(TYPE.UNDEFINED, val);\n}\n\nexport function deserializeUndefined() : void {\n    // pass\n}\n","/* @flow */\n\nimport type { Thenable } from './types';\nimport { TYPE } from './constants';\nimport { determineType, isSerializedType } from './common';\nimport {\n    deserializeFunction,\n    deserializeError, type SerializedError,\n    deserializePromise,\n    deserializeRegex, type SerializedRegex,\n    deserializeDate, type SerializedDate,\n    deserializeArray,\n    deserializeObject,\n    deserializeString,\n    deserializeNumber,\n    deserializeBoolean,\n    deserializeNull,\n    deserializeUndefined\n} from './serializers';\n\ntype Deserializer<V : mixed, S : mixed> = (serializedValue : S, key : string) => V;\ntype PrimitiveDeserializer<V, S = V> = (serializedValue : S, key : string) => V;\n\ntype Deserializers = {\n    function? : Deserializer<Function, *>,\n    error? : Deserializer<Error, SerializedError>,\n    promise? : Deserializer<Thenable, *>,\n    regex? : Deserializer<RegExp, SerializedRegex>,\n    date? : Deserializer<Date, SerializedDate>,\n    array? : PrimitiveDeserializer<$ReadOnlyArray<mixed>>,\n    object? : PrimitiveDeserializer<Object>,\n    string? : PrimitiveDeserializer<string>,\n    number? : PrimitiveDeserializer<number>,\n    boolean? : PrimitiveDeserializer<boolean>,\n    null? : PrimitiveDeserializer<null>,\n    [string] : Deserializer<mixed, *>,\n    undefined? : PrimitiveDeserializer<void>\n};\n\n// $FlowFixMe\nconst DESERIALIZER : Deserializers = {\n    [ TYPE.FUNCTION ]:  deserializeFunction,\n    [ TYPE.ERROR ]:     deserializeError,\n    [ TYPE.PROMISE ]:   deserializePromise,\n    [ TYPE.REGEX ]:     deserializeRegex,\n    [ TYPE.DATE ]:      deserializeDate,\n    [ TYPE.ARRAY ]:     deserializeArray,\n    [ TYPE.OBJECT ]:    deserializeObject,\n    [ TYPE.STRING ]:    deserializeString,\n    [ TYPE.NUMBER ]:    deserializeNumber,\n    [ TYPE.BOOLEAN ]:   deserializeBoolean,\n    [ TYPE.NULL ]:      deserializeNull,\n    [ TYPE.UNDEFINED ]: deserializeUndefined\n};\n\n// $FlowFixMe\nconst defaultDeserializers : Deserializers = {};\n\nexport function deserialize<T : mixed | null | void>(str : string, deserializers : Deserializers = defaultDeserializers) : T {\n    if (str === TYPE.UNDEFINED) {\n        // $FlowFixMe\n        return;\n    }\n\n    function replacer(key, val) : ?mixed {\n        if (isSerializedType(this)) {\n            return val;\n        }\n\n        let type;\n        let value;\n\n        if (isSerializedType(val)) {\n            type = val.__type__;\n            value = val.__val__;\n        } else {\n            type = determineType(val);\n            value = val;\n        }\n\n        if (!type) {\n            return value;\n        }\n\n        // $FlowFixMe\n        const deserializer = deserializers[type] || DESERIALIZER[type];\n\n        if (!deserializer) {\n            return value;\n        }\n\n        return deserializer(value, key);\n    }\n\n    return JSON.parse(str, replacer);\n}\n","/* @flow */\n/* eslint no-use-before-define: off */\n\nimport {\n  isSameDomain,\n  isWindowClosed,\n  type CrossDomainWindowType,\n  closeWindow,\n  type DomainMatcher,\n  getOpener,\n  WINDOW_TYPE,\n  isWindow,\n  assertSameDomain,\n  getFrameForWindow,\n} from \"@krakenjs/cross-domain-utils/src\";\nimport { ZalgoPromise } from \"@krakenjs/zalgo-promise/src\";\nimport {\n  uniqueID,\n  memoizePromise,\n  noop,\n  submitForm,\n} from \"@krakenjs/belter/src\";\nimport {\n  serializeType,\n  type CustomSerializedType,\n} from \"@krakenjs/universal-serialize/src\";\n\nimport { SERIALIZATION_TYPE, METHOD } from \"../conf\";\nimport { windowStore, globalStore } from \"../global\";\nimport { getWindowInstanceID } from \"../lib\";\nimport { linkWindow } from \"../bridge\";\nimport type { SendType } from \"../types\";\n\nfunction cleanupProxyWindows() {\n  const idToProxyWindow = globalStore(\"idToProxyWindow\");\n  for (const id of idToProxyWindow.keys()) {\n    // $FlowFixMe\n    if (idToProxyWindow.get(id).shouldClean()) {\n      idToProxyWindow.del(id);\n    }\n  }\n}\n\ntype SetLocationOptions = {|\n  method?: $Values<typeof METHOD>,\n  body?: {|\n    [string]: string | boolean,\n  |},\n|};\n\ntype SerializedWindowType = {|\n  id: string,\n  getType: () => ZalgoPromise<$Values<typeof WINDOW_TYPE>>,\n  close: () => ZalgoPromise<void>,\n  focus: () => ZalgoPromise<void>,\n  isClosed: () => ZalgoPromise<boolean>,\n  setLocation: (url: string, opts?: SetLocationOptions) => ZalgoPromise<void>,\n  getName: () => ZalgoPromise<?string>,\n  setName: (string) => ZalgoPromise<void>,\n  getInstanceID: () => ZalgoPromise<string>,\n|};\n\nfunction getSerializedWindow(\n  winPromise: ZalgoPromise<CrossDomainWindowType>,\n  { send, id = uniqueID() }: {| send: SendType, id?: string |}\n): SerializedWindowType {\n  let windowNamePromise = winPromise.then((win) => {\n    if (isSameDomain(win)) {\n      return assertSameDomain(win).name;\n    }\n  });\n\n  const windowTypePromise = winPromise.then((window) => {\n    if (!isWindowClosed(window)) {\n      return getOpener(window) ? WINDOW_TYPE.POPUP : WINDOW_TYPE.IFRAME;\n    } else {\n      throw new Error(`Window is closed, can not determine type`);\n    }\n  });\n\n  windowNamePromise.catch(noop);\n  windowTypePromise.catch(noop);\n\n  const getName = () =>\n    winPromise.then((win) => {\n      if (isWindowClosed(win)) {\n        return;\n      }\n\n      if (isSameDomain(win)) {\n        return assertSameDomain(win).name;\n      }\n\n      return windowNamePromise;\n    });\n\n  const getDefaultSetLocationOptions = () => {\n    // $FlowFixMe\n    return {};\n  };\n\n  const setLocation = (\n    href: string,\n    opts?: SetLocationOptions = getDefaultSetLocationOptions()\n  ) =>\n    winPromise.then((win) => {\n      const domain = `${window.location.protocol}//${window.location.host}`;\n      const { method = METHOD.GET, body } = opts;\n\n      if (href.indexOf(\"/\") === 0) {\n        href = `${domain}${href}`;\n      } else if (!href.match(/^https?:\\/\\//) && href.indexOf(domain) !== 0) {\n        throw new Error(\n          `Expected url to be http or https url, or absolute path, got ${JSON.stringify(\n            href\n          )}`\n        );\n      }\n\n      if (method === METHOD.POST) {\n        return getName().then((name) => {\n          if (!name) {\n            throw new Error(`Can not post to window without target name`);\n          }\n\n          submitForm({\n            url: href,\n            target: name,\n            method,\n            body,\n          });\n        });\n      } else if (method === METHOD.GET) {\n        if (isSameDomain(win)) {\n          try {\n            if (win.location && typeof win.location.replace === \"function\") {\n              // $FlowFixMe\n              win.location.replace(href);\n              return;\n            }\n          } catch (err) {\n            // pass\n          }\n        }\n\n        win.location = href;\n      } else {\n        throw new Error(`Unsupported method: ${method}`);\n      }\n    });\n\n  return {\n    id,\n    getType: () => {\n      return windowTypePromise;\n    },\n    getInstanceID: memoizePromise(() =>\n      winPromise.then((win) => getWindowInstanceID(win, { send }))\n    ),\n    close: () => winPromise.then(closeWindow),\n    getName,\n    focus: () =>\n      winPromise.then((win) => {\n        win.focus();\n      }),\n    isClosed: () =>\n      winPromise.then((win) => {\n        return isWindowClosed(win);\n      }),\n    setLocation,\n    setName: (name) =>\n      winPromise.then((win) => {\n        if (__POST_ROBOT__.__IE_POPUP_SUPPORT__) {\n          linkWindow({ win, name });\n        }\n\n        const sameDomain = isSameDomain(win);\n        const frame = getFrameForWindow(win);\n\n        if (!sameDomain) {\n          throw new Error(`Can not set name for cross-domain window: ${name}`);\n        }\n\n        assertSameDomain(win).name = name;\n        if (frame) {\n          frame.setAttribute(\"name\", name);\n        }\n\n        windowNamePromise = ZalgoPromise.resolve(name);\n      }),\n  };\n}\n\nexport class ProxyWindow {\n  id: string;\n  isProxyWindow: true = true;\n  serializedWindow: SerializedWindowType;\n  actualWindow: ?CrossDomainWindowType;\n  actualWindowPromise: ZalgoPromise<CrossDomainWindowType>;\n  send: SendType;\n  name: string;\n\n  constructor({\n    send,\n    win,\n    serializedWindow,\n  }: {|\n    win?: CrossDomainWindowType,\n    serializedWindow?: SerializedWindowType,\n    send: SendType,\n  |}) {\n    this.actualWindowPromise = new ZalgoPromise();\n    this.serializedWindow =\n      serializedWindow ||\n      getSerializedWindow(this.actualWindowPromise, { send });\n\n    globalStore(\"idToProxyWindow\").set(this.getID(), this);\n    if (win) {\n      this.setWindow(win, { send });\n    }\n  }\n\n  getID(): string {\n    return this.serializedWindow.id;\n  }\n\n  getType(): ZalgoPromise<$Values<typeof WINDOW_TYPE>> {\n    return this.serializedWindow.getType();\n  }\n\n  isPopup(): ZalgoPromise<boolean> {\n    return this.getType().then((type) => {\n      return type === WINDOW_TYPE.POPUP;\n    });\n  }\n\n  setLocation(\n    href: string,\n    opts?: SetLocationOptions\n  ): ZalgoPromise<ProxyWindow> {\n    return this.serializedWindow.setLocation(href, opts).then(() => this);\n  }\n\n  getName(): ZalgoPromise<?string> {\n    return this.serializedWindow.getName();\n  }\n\n  setName(name: string): ZalgoPromise<ProxyWindow> {\n    return this.serializedWindow.setName(name).then(() => this);\n  }\n\n  close(): ZalgoPromise<ProxyWindow> {\n    return this.serializedWindow.close().then(() => this);\n  }\n\n  focus(): ZalgoPromise<ProxyWindow> {\n    const isPopupPromise = this.isPopup();\n    const getNamePromise = this.getName();\n\n    const reopenPromise = ZalgoPromise.hash({\n      isPopup: isPopupPromise,\n      name: getNamePromise,\n    }).then(({ isPopup, name }) => {\n      if (isPopup && name) {\n        window.open(\"\", name, \"noopener\");\n      }\n    });\n    const focusPromise = this.serializedWindow.focus();\n\n    return ZalgoPromise.all([reopenPromise, focusPromise]).then(() => this);\n  }\n\n  isClosed(): ZalgoPromise<boolean> {\n    return this.serializedWindow.isClosed();\n  }\n\n  getWindow(): ?CrossDomainWindowType {\n    return this.actualWindow;\n  }\n\n  setWindow(win: CrossDomainWindowType, { send }: {| send: SendType |}) {\n    this.actualWindow = win;\n    this.actualWindowPromise.resolve(this.actualWindow);\n    this.serializedWindow = getSerializedWindow(this.actualWindowPromise, {\n      send,\n      id: this.getID(),\n    });\n    windowStore(\"winToProxyWindow\").set(win, this);\n  }\n\n  awaitWindow(): ZalgoPromise<CrossDomainWindowType> {\n    return this.actualWindowPromise;\n  }\n\n  matchWindow(\n    win: CrossDomainWindowType,\n    { send }: {| send: SendType |}\n  ): ZalgoPromise<boolean> {\n    return ZalgoPromise.try(() => {\n      if (this.actualWindow) {\n        return win === this.actualWindow;\n      }\n\n      return ZalgoPromise.hash({\n        proxyInstanceID: this.getInstanceID(),\n        knownWindowInstanceID: getWindowInstanceID(win, { send }),\n      }).then(({ proxyInstanceID, knownWindowInstanceID }) => {\n        const match = proxyInstanceID === knownWindowInstanceID;\n\n        if (match) {\n          this.setWindow(win, { send });\n        }\n\n        return match;\n      });\n    });\n  }\n\n  unwrap(): CrossDomainWindowType | ProxyWindow {\n    return this.actualWindow || this;\n  }\n\n  getInstanceID(): ZalgoPromise<string> {\n    return this.serializedWindow.getInstanceID();\n  }\n\n  shouldClean(): boolean {\n    return Boolean(this.actualWindow && isWindowClosed(this.actualWindow));\n  }\n\n  serialize(): SerializedWindowType {\n    return this.serializedWindow;\n  }\n\n  static unwrap(\n    win: CrossDomainWindowType | ProxyWindow\n  ): CrossDomainWindowType | ProxyWindow {\n    return ProxyWindow.isProxyWindow(win)\n      ? // $FlowFixMe\n        win.unwrap()\n      : win;\n  }\n\n  static serialize(\n    win: CrossDomainWindowType | ProxyWindow,\n    { send }: {| send: SendType |}\n  ): SerializedWindowType {\n    cleanupProxyWindows();\n    return ProxyWindow.toProxyWindow(win, { send }).serialize();\n  }\n\n  static deserialize(\n    serializedWindow: SerializedWindowType,\n    { send }: {| send: SendType |}\n  ): ProxyWindow {\n    cleanupProxyWindows();\n    return (\n      globalStore(\"idToProxyWindow\").get(serializedWindow.id) ||\n      new ProxyWindow({ serializedWindow, send })\n    );\n  }\n\n  static isProxyWindow(obj: CrossDomainWindowType | ProxyWindow): boolean {\n    // $FlowFixMe\n    return Boolean(obj && !isWindow(obj) && obj.isProxyWindow);\n  }\n\n  static toProxyWindow(\n    win: CrossDomainWindowType | ProxyWindow,\n    { send }: {| send: SendType |}\n  ): ProxyWindow {\n    cleanupProxyWindows();\n\n    if (ProxyWindow.isProxyWindow(win)) {\n      // $FlowFixMe\n      return win;\n    }\n\n    // $FlowFixMe\n    const actualWindow: CrossDomainWindowType = win;\n\n    return (\n      windowStore(\"winToProxyWindow\").get(actualWindow) ||\n      new ProxyWindow({ win: actualWindow, send })\n    );\n  }\n}\n\nexport type SerializedWindow = CustomSerializedType<\n  typeof SERIALIZATION_TYPE.CROSS_DOMAIN_WINDOW,\n  SerializedWindowType\n>;\n\nexport function serializeWindow(\n  destination: CrossDomainWindowType | ProxyWindow,\n  domain: DomainMatcher,\n  win: CrossDomainWindowType,\n  { send }: {| send: SendType |}\n): SerializedWindow {\n  return serializeType(\n    SERIALIZATION_TYPE.CROSS_DOMAIN_WINDOW,\n    ProxyWindow.serialize(win, { send })\n  );\n}\n\nexport function deserializeWindow(\n  source: CrossDomainWindowType | ProxyWindow,\n  origin: string,\n  win: SerializedWindowType,\n  { send }: {| send: SendType |}\n): ProxyWindow {\n  return ProxyWindow.deserialize(win, { send });\n}\n","/* @flow */\n\nimport { ZalgoPromise } from \"@krakenjs/zalgo-promise/src\";\nimport {\n  getDomain,\n  isSameDomain,\n  isOpener,\n  isSameTopWindow,\n  matchDomain,\n  getUserAgent,\n  getDomainFromUrl,\n  type CrossDomainWindowType,\n} from \"@krakenjs/cross-domain-utils/src\";\nimport { noop } from \"@krakenjs/belter/src\";\n\nimport { BRIDGE_NAME_PREFIX } from \"../conf\";\nimport { windowStore } from \"../global\";\n\nexport function needsBridgeForBrowser(): boolean {\n  if (getUserAgent(window).match(/MSIE|trident|edge\\/12|edge\\/13/i)) {\n    return true;\n  }\n\n  return false;\n}\n\nexport function needsBridgeForWin(win: CrossDomainWindowType): boolean {\n  if (!isSameTopWindow(window, win)) {\n    return true;\n  }\n\n  return false;\n}\n\nexport function needsBridgeForDomain(\n  domain: ?string,\n  win: ?CrossDomainWindowType\n): boolean {\n  if (domain) {\n    if (getDomain() !== getDomainFromUrl(domain)) {\n      return true;\n    }\n  } else if (win) {\n    if (!isSameDomain(win)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexport function needsBridge({\n  win,\n  domain,\n}: {|\n  win?: CrossDomainWindowType,\n  domain?: string,\n|}): boolean {\n  if (!needsBridgeForBrowser()) {\n    return false;\n  }\n\n  if (domain && !needsBridgeForDomain(domain, win)) {\n    return false;\n  }\n\n  if (win && !needsBridgeForWin(win)) {\n    return false;\n  }\n\n  return true;\n}\n\nexport function getBridgeName(domain: string): string {\n  domain = domain || getDomainFromUrl(domain);\n\n  const sanitizedDomain = domain.replace(/[^a-zA-Z0-9]+/g, \"_\");\n\n  const id = `${BRIDGE_NAME_PREFIX}_${sanitizedDomain}`;\n\n  return id;\n}\n\nexport function isBridge(): boolean {\n  return Boolean(window.name && window.name === getBridgeName(getDomain()));\n}\n\nexport const documentBodyReady: ZalgoPromise<HTMLBodyElement> =\n  new ZalgoPromise((resolve) => {\n    if (window.document && window.document.body) {\n      return resolve(window.document.body);\n    }\n\n    const interval = setInterval(() => {\n      if (window.document && window.document.body) {\n        clearInterval(interval);\n        return resolve(window.document.body);\n      }\n    }, 10);\n  });\n\nexport function registerRemoteWindow(win: CrossDomainWindowType) {\n  const remoteWindowPromises = windowStore(\"remoteWindowPromises\");\n  remoteWindowPromises.getOrSet(win, () => new ZalgoPromise());\n}\n\nexport function findRemoteWindow(\n  win: CrossDomainWindowType\n): ZalgoPromise<\n  (\n    remoteWin: CrossDomainWindowType,\n    message: string,\n    remoteDomain: string\n  ) => void\n> {\n  const remoteWindowPromises = windowStore(\"remoteWindowPromises\");\n  const remoteWinPromise = remoteWindowPromises.get(win);\n\n  if (!remoteWinPromise) {\n    throw new Error(`Remote window promise not found`);\n  }\n\n  return remoteWinPromise;\n}\n\ntype SendMessageType = {|\n  (string): void,\n  fireAndForget: (string) => void,\n|};\n\nexport function registerRemoteSendMessage(\n  win: CrossDomainWindowType,\n  domain: string,\n  sendMessage: SendMessageType\n) {\n  const sendMessageWrapper = (\n    remoteWin: CrossDomainWindowType,\n    remoteDomain: string,\n    message: string\n  ) => {\n    if (remoteWin !== win) {\n      throw new Error(`Remote window does not match window`);\n    }\n\n    if (!matchDomain(remoteDomain, domain)) {\n      throw new Error(\n        `Remote domain ${remoteDomain} does not match domain ${domain}`\n      );\n    }\n\n    sendMessage.fireAndForget(message);\n  };\n\n  findRemoteWindow(win).resolve(sendMessageWrapper);\n}\n\nexport function rejectRemoteSendMessage(\n  win: CrossDomainWindowType,\n  err: Error\n) {\n  findRemoteWindow(win).reject(err).catch(noop);\n}\n\nexport function sendBridgeMessage(\n  win: CrossDomainWindowType,\n  domain: string,\n  message: string\n): ZalgoPromise<void> {\n  const messagingChild = isOpener(window, win);\n  const messagingParent = isOpener(win, window);\n\n  if (!messagingChild && !messagingParent) {\n    throw new Error(\n      `Can only send messages to and from parent and popup windows`\n    );\n  }\n\n  return findRemoteWindow(win).then((sendMessage) => {\n    return sendMessage(win, domain, message);\n  });\n}\n","/* @flow */\n\nimport {\n  matchDomain,\n  getDomain,\n  type CrossDomainWindowType,\n  type DomainMatcher,\n} from \"@krakenjs/cross-domain-utils/src\";\nimport { ZalgoPromise } from \"@krakenjs/zalgo-promise/src\";\nimport { uniqueID, isRegex, arrayFrom } from \"@krakenjs/belter/src\";\nimport {\n  serializeType,\n  type CustomSerializedType,\n} from \"@krakenjs/universal-serialize/src\";\n\nimport { MESSAGE_NAME, WILDCARD, SERIALIZATION_TYPE } from \"../conf\";\nimport { windowStore, globalStore } from \"../global\";\nimport type { OnType, SendType, CancelableType } from \"../types\";\n\nimport { ProxyWindow } from \"./window\";\n\ntype StoredMethod = {|\n  name: string,\n  domain: DomainMatcher,\n  val: Function,\n  source: CrossDomainWindowType | ProxyWindow,\n|};\n\nfunction addMethod(\n  id: string,\n  val: Function,\n  name: string,\n  source: CrossDomainWindowType | ProxyWindow,\n  domain: DomainMatcher\n) {\n  const methodStore = windowStore(\"methodStore\");\n  const proxyWindowMethods = globalStore(\"proxyWindowMethods\");\n\n  if (ProxyWindow.isProxyWindow(source)) {\n    proxyWindowMethods.set(id, { val, name, domain, source });\n  } else {\n    proxyWindowMethods.del(id);\n    // $FlowFixMe\n    const methods = methodStore.getOrSet(source, () => ({}));\n    methods[id] = { domain, name, val, source };\n  }\n}\n\nfunction lookupMethod(\n  source: CrossDomainWindowType,\n  id: string\n): ?StoredMethod {\n  const methodStore = windowStore(\"methodStore\");\n  const proxyWindowMethods = globalStore(\"proxyWindowMethods\");\n  const methods = methodStore.getOrSet(source, () => ({}));\n  return methods[id] || proxyWindowMethods.get(id);\n}\n\nfunction stringifyArguments(args: $ReadOnlyArray<mixed> = []): string {\n  return arrayFrom(args)\n    .map((arg) => {\n      if (typeof arg === \"string\") {\n        return `'${arg}'`;\n      }\n      if (arg === undefined) {\n        return \"undefined\";\n      }\n      if (arg === null) {\n        return \"null\";\n      }\n      if (typeof arg === \"boolean\") {\n        return arg.toString();\n      }\n      if (Array.isArray(arg)) {\n        return \"[ ... ]\";\n      }\n      if (typeof arg === \"object\") {\n        return \"{ ... }\";\n      }\n      if (typeof arg === \"function\") {\n        return \"() => { ... }\";\n      }\n      return `<${typeof arg}>`;\n    })\n    .join(\", \");\n}\n\nfunction listenForFunctionCalls({\n  on,\n  send,\n}: {|\n  on: OnType,\n  send: SendType,\n|}): CancelableType {\n  return globalStore(\"builtinListeners\").getOrSet(\"functionCalls\", () => {\n    return on(\n      MESSAGE_NAME.METHOD,\n      { domain: WILDCARD },\n      ({\n        source,\n        origin,\n        data,\n      }: {|\n        source: CrossDomainWindowType,\n        origin: string,\n        data: Object,\n      |}) => {\n        const { id, name } = data;\n\n        const meth = lookupMethod(source, id);\n\n        if (!meth) {\n          throw new Error(\n            `Could not find method '${name}' with id: ${data.id} in ${getDomain(\n              window\n            )}`\n          );\n        }\n\n        const { source: methodSource, domain, val } = meth;\n\n        return ZalgoPromise.try(() => {\n          if (!matchDomain(domain, origin)) {\n            throw new Error(\n              `Method '${data.name}' domain ${JSON.stringify(\n                // $FlowFixMe\n                isRegex(meth.domain) ? meth.domain.source : meth.domain\n              )} does not match origin ${origin} in ${getDomain(window)}`\n            );\n          }\n\n          if (ProxyWindow.isProxyWindow(methodSource)) {\n            // $FlowFixMe\n            return methodSource.matchWindow(source, { send }).then((match) => {\n              if (!match) {\n                throw new Error(\n                  `Method call '${\n                    data.name\n                  }' failed - proxy window does not match source in ${getDomain(\n                    window\n                  )}`\n                );\n              }\n            });\n          }\n        })\n          .then(\n            () => {\n              return val.apply({ source, origin }, data.args);\n            },\n            (err) => {\n              return ZalgoPromise.try(() => {\n                if (val.onError) {\n                  return val.onError(err);\n                }\n              }).then(() => {\n                // $FlowFixMe\n                if (err.stack) {\n                  // $FlowFixMe\n                  err.stack = `Remote call to ${name}(${stringifyArguments(\n                    data.args\n                    // $FlowFixMe\n                  )}) failed\\n\\n${err.stack}`;\n                }\n\n                throw err;\n              });\n            }\n          )\n          .then((result) => {\n            return { result, id, name };\n          });\n      }\n    );\n  });\n}\n\nexport type SerializedFunction = CustomSerializedType<\n  typeof SERIALIZATION_TYPE.CROSS_DOMAIN_FUNCTION,\n  {|\n    id: string,\n    name: string,\n  |}\n>;\n\n// eslint-disable-next-line flowtype/require-exact-type\ntype SerializableFunction<T> = {\n  (): ZalgoPromise<T> | T,\n  __id__?: string,\n  __name__?: string,\n};\n\nexport function serializeFunction<T>(\n  destination: CrossDomainWindowType | ProxyWindow,\n  domain: DomainMatcher,\n  val: SerializableFunction<T>,\n  key: string,\n  { on, send }: {| on: OnType, send: SendType |}\n): SerializedFunction {\n  listenForFunctionCalls({ on, send });\n\n  const id = val.__id__ || uniqueID();\n  destination = ProxyWindow.unwrap(destination);\n  let name = val.__name__ || val.name || key;\n\n  if (\n    typeof name === \"string\" &&\n    typeof name.indexOf === \"function\" &&\n    name.indexOf(\"anonymous::\") === 0\n  ) {\n    name = name.replace(\"anonymous::\", `${key}::`);\n  }\n\n  if (ProxyWindow.isProxyWindow(destination)) {\n    addMethod(id, val, name, destination, domain);\n\n    // $FlowFixMe\n    destination.awaitWindow().then((win) => {\n      addMethod(id, val, name, win, domain);\n    });\n  } else {\n    addMethod(id, val, name, destination, domain);\n  }\n\n  return serializeType(SERIALIZATION_TYPE.CROSS_DOMAIN_FUNCTION, { id, name });\n}\n\nexport function deserializeFunction<T>(\n  source: CrossDomainWindowType | ProxyWindow,\n  origin: string,\n  { id, name }: {| id: string, name: string |},\n  { send }: {| send: SendType |}\n): (...args: $ReadOnlyArray<mixed>) => ZalgoPromise<T> {\n  const getDeserializedFunction = (opts?: Object = {}) => {\n    function crossDomainFunctionWrapper<X: mixed>(): ZalgoPromise<X> {\n      let originalStack;\n\n      if (__DEBUG__) {\n        originalStack = new Error(`Original call to ${name}():`).stack;\n      }\n\n      return ProxyWindow.toProxyWindow(source, { send })\n        .awaitWindow()\n        .then((win) => {\n          const meth = lookupMethod(win, id);\n\n          if (meth && meth.val !== crossDomainFunctionWrapper) {\n            return meth.val.apply(\n              { source: window, origin: getDomain() },\n              arguments\n            );\n          } else {\n            // $FlowFixMe[method-unbinding]\n            const args = Array.prototype.slice.call(arguments);\n\n            if (opts.fireAndForget) {\n              return send(\n                win,\n                MESSAGE_NAME.METHOD,\n                { id, name, args },\n                { domain: origin, fireAndForget: true }\n              );\n            } else {\n              return send(\n                win,\n                MESSAGE_NAME.METHOD,\n                { id, name, args },\n                { domain: origin, fireAndForget: false }\n              ).then((res) => res.data.result);\n            }\n          }\n        })\n        .catch((err) => {\n          // $FlowFixMe\n          if (__DEBUG__ && originalStack && err.stack) {\n            // $FlowFixMe\n            err.stack = `Remote call to ${name}(${stringifyArguments(\n              arguments\n              // $FlowFixMe\n            )}) failed\\n\\n${err.stack}\\n\\n${originalStack}`;\n          }\n          throw err;\n        });\n    }\n\n    crossDomainFunctionWrapper.__name__ = name;\n    crossDomainFunctionWrapper.__origin__ = origin;\n    crossDomainFunctionWrapper.__source__ = source;\n    crossDomainFunctionWrapper.__id__ = id;\n\n    crossDomainFunctionWrapper.origin = origin;\n\n    return crossDomainFunctionWrapper;\n  };\n\n  const crossDomainFunctionWrapper = getDeserializedFunction();\n  crossDomainFunctionWrapper.fireAndForget = getDeserializedFunction({\n    fireAndForget: true,\n  });\n\n  return crossDomainFunctionWrapper;\n}\n","/* @flow */\n\nimport {\n  type CrossDomainWindowType,\n  isWindow,\n  type DomainMatcher,\n} from \"@krakenjs/cross-domain-utils/src\";\nimport {\n  TYPE,\n  serialize,\n  deserialize,\n  type Thenable,\n} from \"@krakenjs/universal-serialize/src\";\n\nimport { SERIALIZATION_TYPE } from \"../conf\";\nimport type { OnType, SendType } from \"../types\";\n\nimport {\n  serializeFunction,\n  deserializeFunction,\n  type SerializedFunction,\n} from \"./function\";\nimport {\n  serializePromise,\n  deserializePromise,\n  type SerializedPromise,\n} from \"./promise\";\nimport {\n  serializeWindow,\n  deserializeWindow,\n  type SerializedWindow,\n  ProxyWindow,\n} from \"./window\";\n\nexport function serializeMessage<T: mixed>(\n  destination: CrossDomainWindowType | ProxyWindow,\n  domain: DomainMatcher,\n  obj: T,\n  { on, send }: {| on: OnType, send: SendType |}\n): string {\n  return serialize(obj, {\n    [TYPE.PROMISE]: (val: Thenable, key: string): SerializedPromise =>\n      serializePromise(destination, domain, val, key, { on, send }),\n    [TYPE.FUNCTION]: (val: Function, key: string): SerializedFunction =>\n      serializeFunction(destination, domain, val, key, { on, send }),\n    [TYPE.OBJECT]: (val: CrossDomainWindowType): Object | SerializedWindow => {\n      return isWindow(val) || ProxyWindow.isProxyWindow(val)\n        ? serializeWindow(destination, domain, val, { send })\n        : val;\n    },\n  });\n}\n\nexport function deserializeMessage<T: mixed>(\n  source: CrossDomainWindowType | ProxyWindow,\n  origin: string,\n  message: string,\n  { send }: {| on: OnType, send: SendType |}\n): T {\n  return deserialize(message, {\n    [SERIALIZATION_TYPE.CROSS_DOMAIN_ZALGO_PROMISE]: (serializedPromise) =>\n      deserializePromise(source, origin, serializedPromise),\n    [SERIALIZATION_TYPE.CROSS_DOMAIN_FUNCTION]: (serializedFunction) =>\n      deserializeFunction(source, origin, serializedFunction, { send }),\n    [SERIALIZATION_TYPE.CROSS_DOMAIN_WINDOW]: (serializedWindow) =>\n      deserializeWindow(source, origin, serializedWindow, { send }),\n  });\n}\n","/* @flow */\n\nimport {\n  type CrossDomainWindowType,\n  type DomainMatcher,\n} from \"@krakenjs/cross-domain-utils/src\";\nimport { ZalgoPromise } from \"@krakenjs/zalgo-promise/src\";\nimport {\n  serializeType,\n  type CustomSerializedType,\n  type Thenable,\n} from \"@krakenjs/universal-serialize/src\";\n\nimport { SERIALIZATION_TYPE } from \"../conf\";\nimport type { OnType, SendType } from \"../types\";\n\nimport { serializeFunction, type SerializedFunction } from \"./function\";\nimport { ProxyWindow } from \"./window\";\n\nexport type SerializedPromise = CustomSerializedType<\n  typeof SERIALIZATION_TYPE.CROSS_DOMAIN_ZALGO_PROMISE,\n  {|\n    then: SerializedFunction,\n  |}\n>;\n\nexport function serializePromise(\n  destination: CrossDomainWindowType | ProxyWindow,\n  domain: DomainMatcher,\n  val: Thenable,\n  key: string,\n  { on, send }: {| on: OnType, send: SendType |}\n): SerializedPromise {\n  return serializeType(SERIALIZATION_TYPE.CROSS_DOMAIN_ZALGO_PROMISE, {\n    then: serializeFunction(\n      destination,\n      domain,\n      (resolve, reject) => val.then(resolve, reject),\n      key,\n      { on, send }\n    ),\n  });\n}\n\nexport function deserializePromise<T>(\n  source: CrossDomainWindowType | ProxyWindow,\n  origin: string,\n  { then }: {| then: Function |}\n): ZalgoPromise<T> {\n  return new ZalgoPromise(then);\n}\n","/* @flow */\n\nimport {\n  isSameDomain,\n  isSameTopWindow,\n  isActuallySameDomain,\n  getActualDomain,\n  getDomain,\n  type CrossDomainWindowType,\n  PROTOCOL,\n} from \"@krakenjs/cross-domain-utils/src\";\n\nimport { SEND_STRATEGY, WILDCARD } from \"../../conf\";\nimport { needsGlobalMessagingForBrowser } from \"../../lib\";\nimport { getGlobal } from \"../../global\";\nimport {\n  sendBridgeMessage,\n  needsBridgeForBrowser,\n  isBridge,\n} from \"../../bridge\";\n\ntype SendStrategies = {|\n  [$Values<typeof SEND_STRATEGY>]: (\n    CrossDomainWindowType,\n    string,\n    string\n  ) => void,\n|};\n\nexport const SEND_MESSAGE_STRATEGIES: SendStrategies = {};\n\nSEND_MESSAGE_STRATEGIES[SEND_STRATEGY.POST_MESSAGE] = (\n  win: CrossDomainWindowType,\n  serializedMessage: string,\n  domain: string\n) => {\n  if (domain.indexOf(PROTOCOL.FILE) === 0) {\n    domain = WILDCARD;\n  }\n\n  if (__TEST__) {\n    if (\n      needsGlobalMessagingForBrowser() &&\n      isSameTopWindow(window, win) === false\n    ) {\n      return;\n    }\n\n    if (domain.indexOf(PROTOCOL.MOCK) === 0) {\n      if (!isActuallySameDomain(win)) {\n        throw new Error(\n          `Attempting to send message to mock domain ${domain}, but window is actually cross-domain`\n        );\n      }\n\n      // $FlowFixMe\n      const windowDomain = getDomain(win);\n\n      if (windowDomain !== domain) {\n        throw new Error(\n          `Mock domain target ${domain} does not match window domain ${windowDomain}`\n        );\n      }\n\n      // $FlowFixMe\n      domain = getActualDomain(win);\n    }\n  }\n\n  win.postMessage(serializedMessage, domain);\n};\n\nif (__POST_ROBOT__.__IE_POPUP_SUPPORT__) {\n  SEND_MESSAGE_STRATEGIES[SEND_STRATEGY.BRIDGE] = (\n    win: CrossDomainWindowType,\n    serializedMessage: string,\n    domain: string\n  ) => {\n    if (!needsBridgeForBrowser() && !isBridge()) {\n      throw new Error(`Bridge not needed for browser`);\n    }\n\n    if (isSameDomain(win)) {\n      throw new Error(\n        `Post message through bridge disabled between same domain windows`\n      );\n    }\n\n    if (isSameTopWindow(window, win) !== false) {\n      throw new Error(\n        `Can only use bridge to communicate between two different windows, not between frames`\n      );\n    }\n\n    sendBridgeMessage(win, domain, serializedMessage);\n  };\n}\n\nif (\n  __POST_ROBOT__.__IE_POPUP_SUPPORT__ ||\n  __POST_ROBOT__.__GLOBAL_MESSAGE_SUPPORT__\n) {\n  SEND_MESSAGE_STRATEGIES[SEND_STRATEGY.GLOBAL] = (\n    win: CrossDomainWindowType,\n    serializedMessage: string\n  ) => {\n    if (!needsGlobalMessagingForBrowser()) {\n      throw new Error(`Global messaging not needed for browser`);\n    }\n\n    if (!isSameDomain(win)) {\n      throw new Error(\n        `Post message through global disabled between different domain windows`\n      );\n    }\n\n    if (isSameTopWindow(window, win) !== false) {\n      throw new Error(\n        `Can only use global to communicate between two different windows, not between frames`\n      );\n    }\n\n    // $FlowFixMe\n    const foreignGlobal = getGlobal(win);\n\n    if (!foreignGlobal) {\n      throw new Error(`Can not find postRobot global on foreign window`);\n    }\n\n    foreignGlobal.receiveMessage({\n      source: window,\n      origin: getDomain(),\n      data: serializedMessage,\n    });\n  };\n}\n","/* @flow */\n\nimport { ZalgoPromise } from \"@krakenjs/zalgo-promise/src\";\nimport {\n  isWindowClosed,\n  type CrossDomainWindowType,\n} from \"@krakenjs/cross-domain-utils/src\";\nimport { stringifyError, noop } from \"@krakenjs/belter/src\";\n\nimport { serializeMessage } from \"../../serialize\";\nimport { windowStore, getGlobalKey } from \"../../global\";\nimport type { Message, PackedMessages } from \"../types\";\nimport type { OnType, SendType } from \"../../types\";\n\nimport { SEND_MESSAGE_STRATEGIES } from \"./strategies\";\n\nfunction packMessages(messages: $ReadOnlyArray<Message>): PackedMessages {\n  return {\n    [getGlobalKey()]: messages,\n  };\n}\n\nexport function sendMessage(\n  win: CrossDomainWindowType,\n  domain: string,\n  message: Message,\n  { on, send }: {| on: OnType, send: SendType |}\n): ZalgoPromise<void> {\n  return ZalgoPromise.try(() => {\n    const messageBuffer = windowStore();\n\n    const domainBuffer = messageBuffer.getOrSet(win, () => ({}));\n\n    domainBuffer.buffer = domainBuffer.buffer || [];\n    domainBuffer.buffer.push(message);\n\n    domainBuffer.flush =\n      domainBuffer.flush ||\n      ZalgoPromise.flush().then(() => {\n        if (isWindowClosed(win)) {\n          throw new Error(\"Window is closed\");\n        }\n\n        const serializedMessage = serializeMessage(\n          win,\n          domain,\n          packMessages(domainBuffer.buffer || []),\n          { on, send }\n        );\n        delete domainBuffer.buffer;\n\n        const strategies = Object.keys(SEND_MESSAGE_STRATEGIES);\n        const errors = [];\n\n        for (const strategyName of strategies) {\n          try {\n            SEND_MESSAGE_STRATEGIES[strategyName](\n              win,\n              serializedMessage,\n              domain\n            );\n          } catch (err) {\n            errors.push(err);\n          }\n        }\n\n        if (errors.length === strategies.length) {\n          throw new Error(\n            `All post-robot messaging strategies failed:\\n\\n${errors\n              .map((err, i) => `${i}. ${stringifyError(err)}`)\n              .join(\"\\n\\n\")}`\n          );\n        }\n      });\n\n    return domainBuffer.flush.then(() => {\n      delete domainBuffer.flush;\n    });\n  }).then(noop);\n}\n","/* @flow */\n\nimport { type ZalgoPromise } from \"@krakenjs/zalgo-promise/src\";\nimport {\n  matchDomain,\n  type CrossDomainWindowType,\n  type DomainMatcher,\n} from \"@krakenjs/cross-domain-utils/src\";\nimport { isRegex, getOrSet, noop } from \"@krakenjs/belter/src\";\n\nimport {\n  getWildcard,\n  type WildCard,\n  globalStore,\n  windowStore,\n} from \"../global\";\nimport { WILDCARD } from \"../conf\";\nimport { ProxyWindow } from \"../serialize/window\";\n\nexport function resetListeners() {\n  const responseListeners = globalStore(\"responseListeners\");\n  const erroredResponseListeners = globalStore(\"erroredResponseListeners\");\n  responseListeners.reset();\n  erroredResponseListeners.reset();\n}\n\nconst __DOMAIN_REGEX__ = \"__domain_regex__\";\n\nexport type RequestListenerType = {|\n  handler: ({|\n    source: CrossDomainWindowType,\n    origin: string,\n    data: mixed,\n  |}) => mixed | ZalgoPromise<mixed>,\n  handleError: (err: mixed) => void,\n|};\n\nexport type ResponseListenerType = {|\n  name: string,\n  win: CrossDomainWindowType,\n  domain: DomainMatcher,\n  promise: ZalgoPromise<*>,\n  ack?: ?boolean,\n  cancelled?: ?boolean,\n|};\n\nexport function addResponseListener(\n  hash: string,\n  listener: ResponseListenerType\n) {\n  const responseListeners = globalStore(\"responseListeners\");\n  responseListeners.set(hash, listener);\n}\n\nexport function getResponseListener(hash: string): ?ResponseListenerType {\n  const responseListeners = globalStore(\"responseListeners\");\n  return responseListeners.get(hash);\n}\n\nexport function deleteResponseListener(hash: string) {\n  const responseListeners = globalStore(\"responseListeners\");\n  responseListeners.del(hash);\n}\n\nexport function cancelResponseListeners() {\n  const responseListeners = globalStore(\"responseListeners\");\n  for (const hash of responseListeners.keys()) {\n    const listener = responseListeners.get(hash);\n    if (listener) {\n      listener.cancelled = true;\n    }\n    responseListeners.del(hash);\n  }\n}\n\nexport function markResponseListenerErrored(hash: string) {\n  const erroredResponseListeners = globalStore(\"erroredResponseListeners\");\n  erroredResponseListeners.set(hash, true);\n}\n\nexport function isResponseListenerErrored(hash: string): boolean {\n  const erroredResponseListeners = globalStore(\"erroredResponseListeners\");\n  return erroredResponseListeners.has(hash);\n}\n\nexport function getRequestListener({\n  name,\n  win,\n  domain,\n}: {|\n  name: string,\n  win: ?(CrossDomainWindowType | WildCard),\n  domain: ?(string | RegExp),\n|}): ?RequestListenerType {\n  const requestListeners = windowStore(\"requestListeners\");\n\n  if (win === WILDCARD) {\n    win = null;\n  }\n\n  if (domain === WILDCARD) {\n    domain = null;\n  }\n\n  if (!name) {\n    throw new Error(`Name required to get request listener`);\n  }\n\n  for (const winQualifier of [win, getWildcard()]) {\n    if (!winQualifier) {\n      continue;\n    }\n\n    const nameListeners = requestListeners.get(winQualifier);\n\n    if (!nameListeners) {\n      continue;\n    }\n\n    const domainListeners = nameListeners[name];\n\n    if (!domainListeners) {\n      continue;\n    }\n\n    if (domain && typeof domain === \"string\") {\n      if (domainListeners[domain]) {\n        return domainListeners[domain];\n      }\n\n      if (domainListeners[__DOMAIN_REGEX__]) {\n        for (const { regex, listener } of domainListeners[__DOMAIN_REGEX__]) {\n          if (matchDomain(regex, domain)) {\n            return listener;\n          }\n        }\n      }\n    }\n\n    if (domainListeners[WILDCARD]) {\n      return domainListeners[WILDCARD];\n    }\n  }\n}\n\n// eslint-disable-next-line complexity\nexport function addRequestListener(\n  {\n    name,\n    win: winCandidate,\n    domain,\n  }: {|\n    name: string,\n    win: ?(CrossDomainWindowType | WildCard | ProxyWindow),\n    domain: ?DomainMatcher,\n  |},\n  listener: RequestListenerType\n): {| cancel: () => void |} {\n  const requestListeners = windowStore(\"requestListeners\");\n\n  if (!name || typeof name !== \"string\") {\n    throw new Error(`Name required to add request listener`);\n  }\n\n  if (\n    winCandidate &&\n    winCandidate !== WILDCARD &&\n    // $FlowFixMe\n    ProxyWindow.isProxyWindow(winCandidate)\n  ) {\n    // $FlowFixMe\n    const proxyWin: ProxyWindow = winCandidate;\n\n    const requestListenerPromise = proxyWin.awaitWindow().then((actualWin) => {\n      return addRequestListener({ name, win: actualWin, domain }, listener);\n    });\n\n    return {\n      cancel: () => {\n        requestListenerPromise.then(\n          (requestListener) => requestListener.cancel(),\n          noop\n        );\n      },\n    };\n  }\n\n  // $FlowFixMe\n  let win: ?(CrossDomainWindowType | WildCard) = winCandidate;\n\n  if (Array.isArray(win)) {\n    const listenersCollection = [];\n\n    for (const item of win) {\n      listenersCollection.push(\n        addRequestListener({ name, domain, win: item }, listener)\n      );\n    }\n\n    return {\n      cancel() {\n        for (const cancelListener of listenersCollection) {\n          cancelListener.cancel();\n        }\n      },\n    };\n  }\n\n  if (Array.isArray(domain)) {\n    const listenersCollection = [];\n\n    for (const item of domain) {\n      listenersCollection.push(\n        addRequestListener({ name, win, domain: item }, listener)\n      );\n    }\n\n    return {\n      cancel() {\n        for (const cancelListener of listenersCollection) {\n          cancelListener.cancel();\n        }\n      },\n    };\n  }\n\n  const existingListener = getRequestListener({ name, win, domain });\n\n  if (!win || win === WILDCARD) {\n    win = getWildcard();\n  }\n\n  domain = domain || WILDCARD;\n  const strDomain = domain.toString();\n\n  if (existingListener) {\n    if (win && domain) {\n      throw new Error(\n        `Request listener already exists for ${name} on domain ${domain.toString()} for ${\n          win === getWildcard() ? \"wildcard\" : \"specified\"\n        } window`\n      );\n    } else if (win) {\n      throw new Error(\n        `Request listener already exists for ${name} for ${\n          win === getWildcard() ? \"wildcard\" : \"specified\"\n        } window`\n      );\n    } else if (domain) {\n      throw new Error(\n        `Request listener already exists for ${name} on domain ${domain.toString()}`\n      );\n    } else {\n      throw new Error(`Request listener already exists for ${name}`);\n    }\n  }\n\n  const winNameListeners = requestListeners.getOrSet(win, () => ({}));\n  const winNameDomainListeners = getOrSet(winNameListeners, name, () => ({}));\n\n  let winNameDomainRegexListeners;\n  let winNameDomainRegexListener;\n\n  if (isRegex(domain)) {\n    winNameDomainRegexListeners = getOrSet(\n      winNameDomainListeners,\n      __DOMAIN_REGEX__,\n      () => []\n    );\n    winNameDomainRegexListener = { regex: domain, listener };\n    winNameDomainRegexListeners.push(winNameDomainRegexListener);\n  } else {\n    winNameDomainListeners[strDomain] = listener;\n  }\n\n  return {\n    cancel() {\n      delete winNameDomainListeners[strDomain];\n\n      if (winNameDomainRegexListener) {\n        winNameDomainRegexListeners.splice(\n          winNameDomainRegexListeners.indexOf(winNameDomainRegexListener, 1)\n        );\n\n        if (!winNameDomainRegexListeners.length) {\n          delete winNameDomainListeners[__DOMAIN_REGEX__];\n        }\n      }\n\n      if (!Object.keys(winNameDomainListeners).length) {\n        delete winNameListeners[name];\n      }\n\n      if (win && !Object.keys(winNameListeners).length) {\n        requestListeners.del(win);\n      }\n    },\n  };\n}\n","/* @flow */\n\nimport { ZalgoPromise } from \"@krakenjs/zalgo-promise/src\";\nimport {\n  isWindowClosed,\n  type CrossDomainWindowType,\n  getDomain,\n  isSameTopWindow,\n  PROTOCOL,\n} from \"@krakenjs/cross-domain-utils/src\";\nimport { addEventListener, noop } from \"@krakenjs/belter/src\";\n\nimport type { Message } from \"../types\";\nimport { MESSAGE_TYPE } from \"../../conf\";\nimport { markWindowKnown, needsGlobalMessagingForBrowser } from \"../../lib\";\nimport { deserializeMessage } from \"../../serialize\";\nimport { getGlobal, globalStore, getGlobalKey } from \"../../global\";\nimport type {\n  OnType,\n  SendType,\n  MessageEvent,\n  CancelableType,\n} from \"../../types\";\n\nimport { handleRequest, handleResponse, handleAck } from \"./types\";\n\nfunction deserializeMessages(\n  message: string,\n  source: CrossDomainWindowType,\n  origin: string,\n  { on, send }: {| on: OnType, send: SendType |}\n): ?$ReadOnlyArray<Message> {\n  let parsedMessage;\n\n  try {\n    parsedMessage = deserializeMessage(source, origin, message, { on, send });\n  } catch (err) {\n    return;\n  }\n\n  if (!parsedMessage) {\n    return;\n  }\n\n  if (typeof parsedMessage !== \"object\" || parsedMessage === null) {\n    return;\n  }\n\n  const parseMessages = parsedMessage[getGlobalKey()];\n\n  if (!Array.isArray(parseMessages)) {\n    return;\n  }\n\n  return parseMessages;\n}\n\nexport function receiveMessage(\n  event: MessageEvent,\n  { on, send }: {| on: OnType, send: SendType |}\n) {\n  const receivedMessages = globalStore(\"receivedMessages\");\n\n  try {\n    if (!window || window.closed || !event.source) {\n      return;\n    }\n  } catch (err) {\n    return;\n  }\n\n  let { source, origin, data } = event;\n\n  if (__TEST__) {\n    if (isWindowClosed(source)) {\n      return;\n    }\n\n    // $FlowFixMe\n    origin = getDomain(source);\n  }\n\n  const messages = deserializeMessages(data, source, origin, { on, send });\n\n  if (!messages) {\n    return;\n  }\n\n  markWindowKnown(source);\n\n  for (const message of messages) {\n    if (receivedMessages.has(message.id)) {\n      return;\n    }\n\n    receivedMessages.set(message.id, true);\n\n    if (isWindowClosed(source) && !message.fireAndForget) {\n      return;\n    }\n\n    if (message.origin.indexOf(PROTOCOL.FILE) === 0) {\n      origin = `${PROTOCOL.FILE}//`;\n    }\n\n    try {\n      if (message.type === MESSAGE_TYPE.REQUEST) {\n        handleRequest(source, origin, message, { on, send });\n      } else if (message.type === MESSAGE_TYPE.RESPONSE) {\n        handleResponse(source, origin, message);\n      } else if (message.type === MESSAGE_TYPE.ACK) {\n        handleAck(source, origin, message);\n      }\n    } catch (err) {\n      setTimeout(() => {\n        throw err;\n      }, 0);\n    }\n  }\n}\n\nexport function setupGlobalReceiveMessage({\n  on,\n  send,\n}: {|\n  on: OnType,\n  send: SendType,\n|}) {\n  const global = getGlobal();\n  global.receiveMessage =\n    global.receiveMessage ||\n    ((message) => receiveMessage(message, { on, send }));\n}\n\ntype ListenerEvent = {|\n  source: CrossDomainWindowType,\n  origin: string,\n  data: string,\n  sourceElement: CrossDomainWindowType,\n  originalEvent?: {| origin: string |},\n|};\n\nexport function messageListener(\n  event: ListenerEvent,\n  { on, send }: {| on: OnType, send: SendType |}\n) {\n  ZalgoPromise.try(() => {\n    try {\n      noop(event.source);\n    } catch (err) {\n      return;\n    }\n\n    const source = event.source || event.sourceElement;\n    let origin =\n      event.origin || (event.originalEvent && event.originalEvent.origin);\n    const data = event.data;\n\n    if (origin === \"null\") {\n      origin = `${PROTOCOL.FILE}//`;\n    }\n\n    if (!source) {\n      return;\n    }\n\n    if (!origin) {\n      throw new Error(`Post message did not have origin domain`);\n    }\n\n    if (__TEST__) {\n      if (\n        needsGlobalMessagingForBrowser() &&\n        isSameTopWindow(source, window) === false\n      ) {\n        return;\n      }\n    }\n\n    receiveMessage({ source, origin, data }, { on, send });\n  });\n}\n\nexport function listenForMessages({\n  on,\n  send,\n}: {|\n  on: OnType,\n  send: SendType,\n|}): CancelableType {\n  return globalStore().getOrSet(\"postMessageListener\", () => {\n    return addEventListener(window, \"message\", (event) => {\n      // $FlowFixMe\n      messageListener(event, { on, send });\n    });\n  });\n}\n\nexport function stopListenForMessages() {\n  const listener = globalStore().get(\"postMessageListener\");\n  if (listener) {\n    listener.cancel();\n  }\n}\n","/* @flow */\n\nimport { ZalgoPromise } from \"@krakenjs/zalgo-promise/src\";\nimport {\n  getDomain,\n  isWindowClosed,\n  matchDomain,\n  stringifyDomainPattern,\n  type CrossDomainWindowType,\n} from \"@krakenjs/cross-domain-utils/src\";\nimport { noop, stringifyError, uniqueID } from \"@krakenjs/belter/src\";\n\nimport { MESSAGE_TYPE, MESSAGE_ACK, MESSAGE_NAME } from \"../../conf\";\nimport { sendMessage } from \"../send\";\nimport {\n  getRequestListener,\n  getResponseListener,\n  deleteResponseListener,\n  isResponseListenerErrored,\n} from \"../listeners\";\nimport type {\n  RequestMessage,\n  AckResponseMessage,\n  ResponseMessage,\n} from \"../types\";\nimport type { OnType, SendType } from \"../../types\";\n\nexport function handleRequest(\n  source: CrossDomainWindowType,\n  origin: string,\n  message: RequestMessage,\n  { on, send }: {| on: OnType, send: SendType |}\n): ZalgoPromise<void> {\n  const options = getRequestListener({\n    name: message.name,\n    win: source,\n    domain: origin,\n  });\n\n  const logName =\n    message.name === MESSAGE_NAME.METHOD &&\n    message.data &&\n    typeof message.data.name === \"string\"\n      ? `${message.data.name}()`\n      : message.name;\n\n  if (__DEBUG__) {\n    // eslint-disable-next-line no-console\n    console.info(\"receive::req\", logName, origin, \"\\n\\n\", message.data);\n  }\n\n  function sendAck(): ZalgoPromise<void> {\n    return ZalgoPromise.flush().then(() => {\n      if (message.fireAndForget || isWindowClosed(source)) {\n        return;\n      }\n\n      try {\n        return sendMessage(\n          source,\n          origin,\n          {\n            id: uniqueID(),\n            origin: getDomain(window),\n            type: MESSAGE_TYPE.ACK,\n            hash: message.hash,\n            name: message.name,\n          },\n          { on, send }\n        );\n      } catch (err) {\n        throw new Error(\n          `Send ack message failed for ${logName} in ${getDomain()}\\n\\n${stringifyError(\n            err\n          )}`\n        );\n      }\n    });\n  }\n\n  function sendResponse(\n    ack: $Values<typeof MESSAGE_ACK>,\n    data: ?Object,\n    error: ?mixed\n  ): ZalgoPromise<void> {\n    return ZalgoPromise.flush().then(() => {\n      if (message.fireAndForget || isWindowClosed(source)) {\n        return;\n      }\n\n      if (__DEBUG__) {\n        if (ack === MESSAGE_ACK.SUCCESS) {\n          console.info(\"respond::res\", logName, origin, \"\\n\\n\", data); // eslint-disable-line no-console\n        } else if (ack === MESSAGE_ACK.ERROR) {\n          console.error(\"respond::err\", logName, origin, \"\\n\\n\", error); // eslint-disable-line no-console\n        }\n      }\n\n      try {\n        return sendMessage(\n          source,\n          origin,\n          {\n            id: uniqueID(),\n            origin: getDomain(window),\n            type: MESSAGE_TYPE.RESPONSE,\n            hash: message.hash,\n            name: message.name,\n            ack,\n            data,\n            error,\n          },\n          { on, send }\n        );\n      } catch (err) {\n        throw new Error(\n          `Send response message failed for ${logName} in ${getDomain()}\\n\\n${stringifyError(\n            err\n          )}`\n        );\n      }\n    });\n  }\n\n  return ZalgoPromise.all([\n    sendAck(),\n\n    ZalgoPromise.try(() => {\n      if (!options) {\n        throw new Error(\n          `No handler found for post message: ${message.name} from ${origin} in ${window.location.protocol}//${window.location.host}${window.location.pathname}`\n        );\n      }\n\n      const data = message.data;\n\n      return options.handler({ source, origin, data });\n    }).then(\n      (data) => {\n        return sendResponse(MESSAGE_ACK.SUCCESS, data);\n      },\n      (error) => {\n        return sendResponse(MESSAGE_ACK.ERROR, null, error);\n      }\n    ),\n  ])\n    .then(noop)\n    .catch((err) => {\n      if (options && options.handleError) {\n        return options.handleError(err);\n      } else {\n        throw err;\n      }\n    });\n}\n\nexport function handleAck(\n  source: CrossDomainWindowType,\n  origin: string,\n  message: AckResponseMessage\n) {\n  if (isResponseListenerErrored(message.hash)) {\n    return;\n  }\n\n  const options = getResponseListener(message.hash);\n\n  if (!options) {\n    throw new Error(\n      `No handler found for post message ack for message: ${message.name} from ${origin} in ${window.location.protocol}//${window.location.host}${window.location.pathname}`\n    );\n  }\n\n  try {\n    if (!matchDomain(options.domain, origin)) {\n      throw new Error(\n        `Ack origin ${origin} does not match domain ${options.domain.toString()}`\n      );\n    }\n\n    if (source !== options.win) {\n      throw new Error(`Ack source does not match registered window`);\n    }\n  } catch (err) {\n    options.promise.reject(err);\n  }\n\n  options.ack = true;\n}\n\nexport function handleResponse(\n  source: CrossDomainWindowType,\n  origin: string,\n  message: ResponseMessage\n): void | ZalgoPromise<void> {\n  if (isResponseListenerErrored(message.hash)) {\n    return;\n  }\n\n  const options = getResponseListener(message.hash);\n\n  if (!options) {\n    throw new Error(\n      `No handler found for post message response for message: ${message.name} from ${origin} in ${window.location.protocol}//${window.location.host}${window.location.pathname}`\n    );\n  }\n\n  if (!matchDomain(options.domain, origin)) {\n    throw new Error(\n      `Response origin ${origin} does not match domain ${stringifyDomainPattern(\n        options.domain\n      )}`\n    );\n  }\n\n  if (source !== options.win) {\n    throw new Error(`Response source does not match registered window`);\n  }\n\n  deleteResponseListener(message.hash);\n\n  const logName =\n    message.name === MESSAGE_NAME.METHOD &&\n    message.data &&\n    typeof message.data.name === \"string\"\n      ? `${message.data.name}()`\n      : message.name;\n\n  if (message.ack === MESSAGE_ACK.ERROR) {\n    if (__DEBUG__) {\n      console.error(\"receive::err\", logName, origin, \"\\n\\n\", message.error); // eslint-disable-line no-console\n    }\n\n    options.promise.reject(message.error);\n  } else if (message.ack === MESSAGE_ACK.SUCCESS) {\n    if (__DEBUG__) {\n      console.info(\"receive::res\", logName, origin, \"\\n\\n\", message.data); // eslint-disable-line no-console\n    }\n\n    options.promise.resolve({ source, origin, data: message.data });\n  }\n}\n","/* @flow */\n\nimport { ZalgoPromise } from \"@krakenjs/zalgo-promise/src\";\n\nimport { addRequestListener } from \"../drivers\";\nimport { WILDCARD } from \"../conf\";\nimport type { ServerOptionsType, HandlerType, CancelableType } from \"../types\";\n\nconst getDefaultServerOptions = (): ServerOptionsType => {\n  // $FlowFixMe\n  return {};\n};\n\nexport function on(\n  name: string,\n  options: ServerOptionsType | HandlerType,\n  handler: ?HandlerType\n): CancelableType {\n  if (!name) {\n    throw new Error(\"Expected name\");\n  }\n\n  options = options || getDefaultServerOptions();\n  if (typeof options === \"function\") {\n    handler = options;\n    options = getDefaultServerOptions();\n  }\n\n  if (!handler) {\n    throw new Error(\"Expected handler\");\n  }\n\n  const winOrProxyWin = options.window;\n  const domain = options.domain || WILDCARD;\n\n  const successHandler = handler || options.handler;\n  const errorHandler =\n    options.errorHandler ||\n    ((err) => {\n      throw err;\n    });\n\n  const requestListener = addRequestListener(\n    { name, win: winOrProxyWin, domain },\n    {\n      handler: successHandler,\n      handleError: errorHandler,\n    }\n  );\n\n  return {\n    cancel() {\n      requestListener.cancel();\n    },\n  };\n}\n\ntype CancelableZalgoPromise<T> = ZalgoPromise<T> & {|\n  cancel: () => void,\n|};\n\nexport function once(\n  name: string,\n  options?: ServerOptionsType | HandlerType,\n  handler?: HandlerType\n): CancelableZalgoPromise<{| source: mixed, origin: string, data: Object |}> {\n  options = options || getDefaultServerOptions();\n  if (typeof options === \"function\") {\n    handler = options;\n    options = getDefaultServerOptions();\n  }\n\n  const promise = new ZalgoPromise();\n  let listener; // eslint-disable-line prefer-const\n\n  options.errorHandler = (err) => {\n    listener.cancel();\n    promise.reject(err);\n  };\n\n  listener = on(name, options, (event) => {\n    listener.cancel();\n    promise.resolve(event);\n    if (handler) {\n      return handler(event);\n    }\n  });\n\n  // $FlowFixMe\n  promise.cancel = listener.cancel;\n\n  // $FlowFixMe\n  return promise;\n}\n","/* @flow */\n\nimport { ZalgoPromise } from \"@krakenjs/zalgo-promise/src\";\nimport {\n  isAncestor,\n  isWindowClosed,\n  getDomain,\n  matchDomain,\n  type CrossDomainWindowType,\n  type DomainMatcher,\n} from \"@krakenjs/cross-domain-utils/src\";\nimport {\n  uniqueID,\n  isRegex,\n  noop,\n  safeInterval,\n  stringify,\n  stringifyError,\n} from \"@krakenjs/belter/src\";\n\nimport {\n  CHILD_WINDOW_TIMEOUT,\n  MESSAGE_TYPE,\n  WILDCARD,\n  MESSAGE_NAME,\n  ACK_TIMEOUT,\n  RES_TIMEOUT,\n  ACK_TIMEOUT_KNOWN,\n  RESPONSE_CYCLE_TIME,\n} from \"../conf\";\nimport {\n  sendMessage,\n  addResponseListener,\n  deleteResponseListener,\n  markResponseListenerErrored,\n  type ResponseListenerType,\n} from \"../drivers\";\nimport { awaitWindowHello, sayHello, isWindowKnown } from \"../lib\";\nimport { windowStore } from \"../global\";\nimport { ProxyWindow } from \"../serialize/window\";\nimport type { SendType } from \"../types\";\n\nimport { on } from \"./on\";\n\nfunction validateOptions(\n  name: string,\n  win: CrossDomainWindowType,\n  domain: ?DomainMatcher\n) {\n  if (!name) {\n    throw new Error(\"Expected name\");\n  }\n\n  if (domain) {\n    if (\n      typeof domain !== \"string\" &&\n      !Array.isArray(domain) &&\n      !isRegex(domain)\n    ) {\n      throw new TypeError(\n        `Can not send ${name}. Expected domain ${JSON.stringify(\n          domain\n        )} to be a string, array, or regex`\n      );\n    }\n  }\n\n  if (isWindowClosed(win)) {\n    throw new Error(`Can not send ${name}. Target window is closed`);\n  }\n}\n\nfunction normalizeDomain(\n  win: CrossDomainWindowType,\n  targetDomain: DomainMatcher,\n  actualDomain: ?string,\n  { send }: {| send: SendType |}\n): ZalgoPromise<string> {\n  return ZalgoPromise.try(() => {\n    if (typeof targetDomain === \"string\") {\n      return targetDomain;\n    }\n\n    return ZalgoPromise.try(() => {\n      return (\n        actualDomain || sayHello(win, { send }).then(({ domain }) => domain)\n      );\n    }).then((normalizedDomain) => {\n      if (!matchDomain(targetDomain, targetDomain)) {\n        throw new Error(\n          `Domain ${stringify(targetDomain)} does not match ${stringify(\n            targetDomain\n          )}`\n        );\n      }\n\n      return normalizedDomain;\n    });\n  });\n}\n\nexport const send: SendType = (winOrProxyWin, name, data, options) => {\n  options = options || {};\n  const domainMatcher = options.domain || WILDCARD;\n  const responseTimeout = options.timeout || RES_TIMEOUT;\n  const childTimeout = options.timeout || CHILD_WINDOW_TIMEOUT;\n  const fireAndForget = options.fireAndForget || false;\n\n  return ProxyWindow.toProxyWindow(winOrProxyWin, { send })\n    .awaitWindow()\n    .then((win) => {\n      // $FlowFixMe\n      return ZalgoPromise.try(() => {\n        validateOptions(name, win, domainMatcher);\n\n        if (isAncestor(window, win)) {\n          return awaitWindowHello(win, childTimeout);\n        }\n      })\n        .then(({ domain: actualDomain } = {}) => {\n          return normalizeDomain(win, domainMatcher, actualDomain, { send });\n        })\n        .then((targetDomain) => {\n          const domain = targetDomain;\n\n          const logName =\n            name === MESSAGE_NAME.METHOD &&\n            data &&\n            typeof data.name === \"string\"\n              ? `${data.name}()`\n              : name;\n\n          if (__DEBUG__) {\n            console.info(\"send::req\", logName, domain, \"\\n\\n\", data); // eslint-disable-line no-console\n          }\n\n          const promise = new ZalgoPromise();\n          const hash = `${name}_${uniqueID()}`;\n\n          if (!fireAndForget) {\n            const responseListener: ResponseListenerType = {\n              name,\n              win,\n              domain,\n              promise,\n            };\n            addResponseListener(hash, responseListener);\n\n            const reqPromises = windowStore(\"requestPromises\").getOrSet(\n              win,\n              () => []\n            );\n            reqPromises.push(promise);\n\n            promise.catch(() => {\n              markResponseListenerErrored(hash);\n              deleteResponseListener(hash);\n            });\n\n            const totalAckTimeout = isWindowKnown(win)\n              ? ACK_TIMEOUT_KNOWN\n              : ACK_TIMEOUT;\n            const totalResTimeout = responseTimeout;\n\n            let ackTimeout = totalAckTimeout;\n            let resTimeout = totalResTimeout;\n\n            const interval = safeInterval(() => {\n              if (isWindowClosed(win)) {\n                return promise.reject(\n                  new Error(\n                    `Window closed for ${name} before ${\n                      responseListener.ack ? \"response\" : \"ack\"\n                    }`\n                  )\n                );\n              }\n\n              if (responseListener.cancelled) {\n                return promise.reject(\n                  new Error(`Response listener was cancelled for ${name}`)\n                );\n              }\n\n              ackTimeout = Math.max(ackTimeout - RESPONSE_CYCLE_TIME, 0);\n              if (resTimeout !== -1) {\n                resTimeout = Math.max(resTimeout - RESPONSE_CYCLE_TIME, 0);\n              }\n\n              if (!responseListener.ack && ackTimeout === 0) {\n                return promise.reject(\n                  new Error(\n                    `No ack for postMessage ${logName} in ${getDomain()} in ${totalAckTimeout}ms`\n                  )\n                );\n              } else if (resTimeout === 0) {\n                return promise.reject(\n                  new Error(\n                    `No response for postMessage ${logName} in ${getDomain()} in ${totalResTimeout}ms`\n                  )\n                );\n              }\n            }, RESPONSE_CYCLE_TIME);\n\n            promise\n              .finally(() => {\n                interval.cancel();\n                reqPromises.splice(reqPromises.indexOf(promise, 1));\n              })\n              .catch(noop);\n          }\n\n          return sendMessage(\n            win,\n            domain,\n            {\n              id: uniqueID(),\n              origin: getDomain(window),\n              type: MESSAGE_TYPE.REQUEST,\n              hash,\n              name,\n              data,\n              fireAndForget,\n            },\n            { on, send }\n          ).then(\n            () => {\n              return fireAndForget ? promise.resolve() : promise;\n            },\n            (err) => {\n              throw new Error(\n                `Send request message failed for ${logName} in ${getDomain()}\\n\\n${stringifyError(\n                  err\n                )}`\n              );\n            }\n          );\n        });\n    });\n};\n","/* @flow */\n\nexport const BRIDGE_TIMEOUT = 5000;\nexport const CHILD_WINDOW_TIMEOUT = 5000;\n\nexport const ACK_TIMEOUT = 2000;\nexport const ACK_TIMEOUT_KNOWN = 10000;\nexport const RES_TIMEOUT: number = __TEST__ ? 2000 : -1;\nexport const RESPONSE_CYCLE_TIME = 500;\n","/* @flow */\n\nimport type {\n  CrossDomainWindowType,\n  DomainMatcher,\n} from \"@krakenjs/cross-domain-utils/src\";\n\nimport { initHello } from \"./lib\";\nimport {\n  listenForMessages,\n  stopListenForMessages,\n  receiveMessage,\n  setupGlobalReceiveMessage,\n  cancelResponseListeners,\n} from \"./drivers\";\nimport { getGlobal, deleteGlobal } from \"./global\";\nimport { on, send } from \"./public\";\nimport { setupBridge } from \"./bridge\";\nimport {\n  serializeMessage as internalSerializeMessage,\n  deserializeMessage as internalDeserializeMessage,\n  ProxyWindow,\n} from \"./serialize\";\n\nexport function serializeMessage<T>(\n  destination: CrossDomainWindowType | ProxyWindow,\n  domain: DomainMatcher,\n  obj: T\n): string {\n  return internalSerializeMessage(destination, domain, obj, { on, send });\n}\n\nexport function deserializeMessage<T: mixed>(\n  source: CrossDomainWindowType | ProxyWindow,\n  origin: string,\n  message: string\n): T {\n  return internalDeserializeMessage(source, origin, message, { on, send });\n}\n\nexport function createProxyWindow(win?: CrossDomainWindowType): ProxyWindow {\n  return new ProxyWindow({ send, win });\n}\n\nexport function toProxyWindow(\n  win: CrossDomainWindowType | ProxyWindow\n): ProxyWindow {\n  return ProxyWindow.toProxyWindow(win, { send });\n}\n\nexport function setup() {\n  if (!getGlobal().initialized) {\n    getGlobal().initialized = true;\n\n    setupGlobalReceiveMessage({ on, send });\n    listenForMessages({ on, send });\n\n    if (__POST_ROBOT__.__IE_POPUP_SUPPORT__) {\n      setupBridge({ on, send, receiveMessage });\n    }\n\n    initHello({ on, send });\n  }\n}\n\nexport function destroy() {\n  cancelResponseListeners();\n  stopListenForMessages();\n  deleteGlobal();\n}\n","/* @flow */\n\nimport type { ZalgoPromise } from \"@krakenjs/zalgo-promise/src\";\nimport type {\n  CrossDomainWindowType,\n  DomainMatcher,\n} from \"@krakenjs/cross-domain-utils/src\";\n\nimport type { ProxyWindow } from \"./serialize/window\";\n\n// export something to force webpack to see this as an ES module\nexport const TYPES = true;\n\n// eslint-disable-next-line flowtype/require-exact-type\nexport type CancelableType = {\n  cancel: () => void,\n};\n\nexport type ErrorHandlerType = (err: mixed) => void;\n\nexport type HandlerType = ({|\n  source: CrossDomainWindowType,\n  origin: string,\n  data: any, // eslint-disable-line flowtype/no-weak-types\n|}) => void | any | ZalgoPromise<any>; // eslint-disable-line flowtype/no-weak-types\n\nexport type ServerOptionsType = {|\n  handler?: ?HandlerType,\n  errorHandler?: ?ErrorHandlerType,\n  window?: CrossDomainWindowType | ProxyWindow,\n  name?: ?string,\n  domain?: ?DomainMatcher,\n  once?: ?boolean,\n  errorOnClose?: ?boolean,\n|};\n\nexport type OnType = (\n  name: string,\n  options: ServerOptionsType | HandlerType,\n  handler: ?HandlerType\n) => CancelableType;\n\ntype RegularRequestOptionsType = {|\n  domain?: ?DomainMatcher,\n  fireAndForget?: false,\n  timeout?: ?number,\n|};\n\ntype FireAndForgetRequestOptionsType = {|\n  domain?: ?DomainMatcher,\n  fireAndForget: true,\n  timeout?: ?number,\n|};\n\nexport type RequestOptionsType =\n  | RegularRequestOptionsType\n  | FireAndForgetRequestOptionsType;\n\nexport type ResponseMessageEvent = {|\n  source: CrossDomainWindowType,\n  origin: string,\n  data: Object,\n|};\n\ntype RegularSendType = (\n  win: CrossDomainWindowType | ProxyWindow,\n  name: string,\n  data: ?Object,\n  options?: RegularRequestOptionsType\n) => ZalgoPromise<ResponseMessageEvent>;\n\ntype FireAndForgetSendType = (\n  win: CrossDomainWindowType | ProxyWindow,\n  name: string,\n  data: ?Object,\n  options?: FireAndForgetRequestOptionsType\n) => ZalgoPromise<void>;\n\nexport type SendType = RegularSendType & FireAndForgetSendType;\n\nexport type MessageEvent = {|\n  source: CrossDomainWindowType,\n  origin: string,\n  data: string,\n|};\n\n// eslint-disable-next-line flowtype/require-exact-type\nexport type CrossDomainFunctionType<A, R> = {\n  (...args: A): ZalgoPromise<R>,\n  fireAndForget: (...args: A) => ZalgoPromise<void>,\n  __id__?: string,\n  __name__?: string,\n};\n\nexport type ReceiveMessageType = (\n  MessageEvent,\n  {| on: OnType, send: SendType |}\n) => void;\n","/* @flow */\n\nimport {\n  type CrossDomainWindowType,\n  isWindowClosed,\n} from \"@krakenjs/cross-domain-utils/src\";\nimport { noop } from \"@krakenjs/belter/src\";\n\nimport { windowStore } from \"./global\";\n\nexport function cleanUpWindow(win: CrossDomainWindowType) {\n  const requestPromises = windowStore(\"requestPromises\");\n  for (const promise of requestPromises.get(win, [])) {\n    promise\n      .reject(\n        new Error(\n          `Window ${\n            isWindowClosed(win) ? \"closed\" : \"cleaned up\"\n          } before response`\n        )\n      )\n      .catch(noop);\n  }\n}\n","/* @flow */\n\nimport { setup } from \"./setup\";\nimport {\n  setupBridge,\n  openBridge,\n  linkWindow,\n  linkUrl,\n  isBridge,\n  needsBridge,\n  needsBridgeForBrowser,\n  hasBridge,\n  needsBridgeForWin,\n  needsBridgeForDomain,\n  destroyBridges,\n} from \"./bridge\";\n\nexport { ZalgoPromise as Promise } from \"@krakenjs/zalgo-promise/src\";\n\nexport * from \"./types\";\nexport { ProxyWindow } from \"./serialize\";\nexport {\n  setup,\n  destroy,\n  serializeMessage,\n  deserializeMessage,\n  createProxyWindow,\n  toProxyWindow,\n} from \"./setup\";\nexport { on, once, send } from \"./public\";\nexport { markWindowKnown } from \"./lib\";\nexport { cleanUpWindow } from \"./clean\";\n\n// $FlowFixMe\nexport let bridge;\n\nif (__POST_ROBOT__.__IE_POPUP_SUPPORT__) {\n  bridge = {\n    setupBridge,\n    openBridge,\n    linkWindow,\n    linkUrl,\n    isBridge,\n    needsBridge,\n    needsBridgeForBrowser,\n    hasBridge,\n    needsBridgeForWin,\n    needsBridgeForDomain,\n    destroyBridges,\n  };\n}\n\nif (__POST_ROBOT__.__AUTO_SETUP__) {\n  setup();\n}\n"],"sourceRoot":""}